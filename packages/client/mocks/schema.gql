scalar BigInt
scalar Bytes

type Token {
  id: Bytes!
  address: Bytes!
  symbol: String!
  createdAt: BigInt!
  priceUSD: BigInt!
  isPoolToken: Boolean!
  # handled by client
  priceUSD24hAgo: BigInt!
  priceUSDOracle: Float!
}

type DebtTokenMeta {
  id: String!
  token: Token!
  timestamp: BigInt!
  # handled by client
  walletAmount: Float!
  troveMintedAmount: Float!
  providedStability: Float!
  compoundedDeposit: Float!
  stabilityCompoundAmount: Float!
  troveRepableDebtAmount: Float!

  # global
  stabilityDepositAPY: StabilityDepositAPY!
  totalDepositedStability: BigInt!
  totalReserve: BigInt!
  # only defined for gov and stableDebtToken
  totalReserve30dAverage: TotalReserveAverage
  totalSupplyUSD: BigInt!
  totalSupplyUSD30dAverage: TotalSupplyAverage!
}

type TotalReserveAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type TotalSupplyAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type StabilityDepositAPY {
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

type CollateralTokenMeta {
  id: String!
  token: Token!
  timestamp: BigInt!
  # borrower specific
  walletAmount: Float!
  troveLockedAmount: Float!
  stabilityGainedAmount: Float!

  # global
  totalValueLockedUSD: BigInt!
  totalValueLockedUSD30dAverage: TotalValueLockedAverage!
}

type TotalValueLockedAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type Query {
  # without borrower address troveAmount and walletAmount are always undefined
  # every token is returned, even if it is not used by the borrower (troveAmount, walletAmount = 0)
  # the same token can be returned twice, if it is used as debt and collateral
  getDebtTokens(borrower: String): [DebtTokenMeta!]!
  getCollateralTokens(borrower: String): [CollateralTokenMeta!]!
  # TODO: Rename this for the subgraph query
  getToken(address: String!): Token!
}

enum LongShortDirection {
  LONG
  SHORT
}

type SwapEvent {
  id: ID!
  borrower: String!
  timestamp: Int!
  #
  token: Token!
  direction: LongShortDirection! # Indicates whether the swap is LONG or SHORT
  size: Float! # always positive, applied by direction. The size of the "non-stable" coin involved in the swap
  totalPriceInStable: Float! # The total price at the time of the swap, always in stable coin
  swapFee: Float! # protocol fees, without gas. Long => jUSD / Short => DebtToken
}

type SwapEventPage {
  swaps: [SwapEvent!]!
  pageInfo: PageInfo!
}

# General meta info for pagination
type PageInfo {
  totalCount: Int!
  hasNextPage: Boolean!
  endCursor: String!
}

type Query {
  # returns 30 elements, cursor based pagination
  # sorted by position.timestamp DESC
  getSwaps(borrower: String!, cursor: String): SwapEventPage!
}

type PoolLiquidity {
  id: ID!
  token: Token!
  totalAmount: Float!
}

type PoolReward {
  id: ID!
  token: Token!
  amount: Float!
}

type Pool {
  # TradingPair contract address
  id: ID!
  # Percent value applied when opening the first position for this pool. Can be negative and positive.
  swapFee: Float!
  liquidity: [PoolLiquidity!]!
  rewards: [PoolReward!]!
  liquidityDepositAPY: Float!
  volume30dUSD: Float!
  volume30dUSD30dAgo: Float!

  totalSupply: Float!
  # client side
  borrowerAmount: Float!
}

type Query {
  # every pool is returned, even if it is empty
  # without borrower address borrowerLiquidity and borrowerRewards are always undefined
  # with borrower address only the pools are returned, where the borrower has liquidity or rewards
  getPools(borrower: String): [Pool!]!
  getPoolPriceHistory(poolId: String!): [[Int!]!]! # [[timestamp, value], [...], ...] todo time range filter needed?
  #
  getCollateralUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
  getDebtUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
  getCollateralRatioHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
  getReserveUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
}

type TokenAmount {
  token: Token!
  amount: Float!
}

enum BorrowerHistoryType {
  DEPOSITED
  WITHDRAWN
  CLAIMED_REWARDS
}

type BorrowerHistory {
  id: ID!
  timestamp: Int!
  type: BorrowerHistoryType!
  values: [TokenAmount!]!
  # worth of the claimed tokens in USD at the time of the event, only set on CLAIMED_REWARDS
  claimInUSD: Float
  # worth of the lost debtToken in USD at the time of the event, only set on CLAIMED_REWARDS
  lostDepositInUSD: Float
}

type PoolHistoryPage {
  history: [BorrowerHistory!]!
  pageInfo: PageInfo!
}

type Query {
  getBorrowerPoolHistory(poolId: String!, borrower: String!, cursor: String): PoolHistoryPage!
  getBorrowerStabilityHistory(borrower: String!, cursor: String): PoolHistoryPage!
}

# ---------------- Client side contract calls ----------------

type TroveManager {
  id: ID!
  borrowingRate: Float!
}

type SystemInfo {
  id: ID!
  recoveryModeActive: Boolean!
  totalCollateralRatio: Float!
}

type Query {
  getTroveManager: TroveManager!
  getSystemInfo: SystemInfo!
}

# TRADING VIEW

# 1min, 10min, 1hour, 6hour, 1day, 1week
# const CandleSizes = [1, 10, 60, 360, 1440, 10080];
type TokenCandle {
  id: Bytes!
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  low: BigInt!
  open: BigInt!
  timestamp: Int!
  token: Token!
  volume: BigInt!
}
type TokenCandleSingleton {
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  id: String!
  low: BigInt!
  open: BigInt!
  timestamp: Int!
  token: Bytes!
  volume: BigInt!
}

input TokenCandle_filter {
  candleSize: Int
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
}

enum TokenCandle_orderBy {
  candleSize
  close
  high
  id
  low
  open
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  volume
}

enum OrderDirection {
  asc
  desc
}

type Query {
  tokenCandles(orderBy: TokenCandle_orderBy, orderDirection: OrderDirection, where: TokenCandle_filter): [TokenCandle!]!
  tokenCandleSingleton(id: ID!): TokenCandleSingleton!
}
