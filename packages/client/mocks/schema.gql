scalar BigInt
scalar Bytes

type Token {
  id: Bytes!
  address: Bytes!
  symbol: String!
  createdAt: BigInt!
  priceUSD: BigInt!
  isPoolToken: Boolean!
  # handled by client
  priceUSD24hAgo: BigInt!
  priceUSDOracle: Float!
}

type DebtTokenMeta {
  id: String!
  token: Token!
  timestamp: BigInt!
  # handled by client
  walletAmount: Float!
  troveMintedAmount: Float!
  providedStability: Float!
  compoundedDeposit: Float!
  stabilityCompoundAmount: Float!
  troveRepableDebtAmount: Float!

  # global
  stabilityDepositAPY: StabilityDepositAPY!
  totalDepositedStability: BigInt!
  totalReserve: BigInt!
  # only defined for gov and stableDebtToken
  totalReserve30dAverage: TotalReserveAverage
  totalSupplyUSD: BigInt!
  totalSupplyUSD30dAverage: TotalSupplyAverage!
}

type TotalReserveAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type TotalSupplyAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type StabilityDepositAPY {
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

type CollateralTokenMeta {
  id: String!
  token: Token!
  timestamp: BigInt!
  # borrower specific
  walletAmount: Float!
  troveLockedAmount: Float!
  stabilityGainedAmount: Float!

  # global
  totalValueLockedUSD: BigInt!
  totalValueLockedUSD30dAverage: TotalValueLockedAverage!
}

type TotalValueLockedAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type Query {
  # without borrower address troveAmount and walletAmount are always undefined
  # every token is returned, even if it is not used by the borrower (troveAmount, walletAmount = 0)
  # the same token can be returned twice, if it is used as debt and collateral
  debtTokenMetas(borrower: String): [DebtTokenMeta!]!
  collateralTokenMetas(borrower: String): [CollateralTokenMeta!]!
  # TODO: Rename this for the subgraph query
  token(address: String!): Token!
}

enum LongShortDirection {
  LONG
  SHORT
}

type SwapEvent {
  id: Bytes!
  borrower: Bytes!
  timestamp: BigInt!
  #
  token: Token!
  direction: LongShortDirection! # Indicates whether the swap is LONG or SHORT
  size: BigInt! # always positive, applied by direction. The size of the "non-stable" coin involved in the swap
  totalPriceInStable: BigInt! # The total price at the time of the swap, always in stable coin
  swapFee: BigInt! # protocol fees, without gas. Long => jUSD / Short => DebtToken
}

input SwapEvent_filter {
  borrower: Bytes
}

enum SwapEvent_orderBy {
  timestamp
}

type Query {
  swapEvents(
    first: Int = 100
    orderBy: SwapEvent_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: SwapEvent_filter
  ): [SwapEvent!]!
}

type PoolLiquidity {
  id: Bytes!
  token: Token!
  totalAmount: BigInt!
}

type Pool {
  # `Pool-${token0.toHexString()}-${token1.toHexString()}`
  id: String!
  # SwapPair contract address
  address: Bytes!
  liquidity: [PoolLiquidity!]!
  liquidityDepositAPY: BigInt!
  volume30dUSD: PoolVolume30d!
  volume30dUSD30dAgo: PoolVolume30d!
  totalSupply: BigInt!

  # client side
  borrowerAmount: Float!
  # Percent value applied when opening the first position for this pool. Can be negative and positive.
  swapFee: BigInt!
}

type PoolVolume30d {
  id: Bytes!
  feeUSD: BigInt!
  lastIndex: Int!
  leadingIndex: Int!
  value: BigInt!
}

type Query {
  # every pool is returned, even if it is empty
  # without borrower address borrowerLiquidity and borrowerRewards are always undefined
  # with borrower address only the pools are returned, where the borrower has liquidity or rewards
  pools(borrower: String): [Pool!]!
  #
  getCollateralUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
  getDebtUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
  getReserveUSDHistory: [[Int!]!]! # [[timestamp, value], [...], ...]
}

type TokenAmount {
  id: Bytes!
  token: Token!
  amount: BigInt!
}

enum BorrowerHistoryType {
  DEPOSITED
  WITHDRAWN
  CLAIMED_REWARDS
}

type BorrowerHistory {
  id: Bytes!
  borrower: Bytes!
  pool: Bytes!
  timestamp: BigInt!
  type: BorrowerHistoryType!
  values: [TokenAmount!]!
  # worth of the claimed tokens in USD at the time of the event, only set on CLAIMED_REWARDS
  claimInUSD: BigInt
  # worth of the lost debtToken in USD at the time of the event, only set on CLAIMED_REWARDS
  lostDepositInUSD: BigInt
}

enum BorrowerHistory_orderBy {
  timestamp
}

input BorrowerHistory_filter {
  borrower: Bytes
}

type Query {
  borrowerHistories(
    first: Int = 100
    orderBy: BorrowerHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: BorrowerHistory_filter
  ): [BorrowerHistory!]!
}

# ---------------- Client side contract calls ----------------

type TroveManager {
  id: ID!
  borrowingRate: Float!
}

type SystemInfo {
  id: ID!
  recoveryModeActive: Boolean!
  totalCollateralRatio: Float!
}

type Query {
  getTroveManager: TroveManager!
  getSystemInfo: SystemInfo!
}

# TRADING VIEW

# 1min, 10min, 1hour, 6hour, 1day, 1week
# const CandleSizes = [1, 10, 60, 360, 1440, 10080];
type TokenCandle {
  id: Bytes!
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  low: BigInt!
  open: BigInt!
  timestamp: Int!
  token: Token!
  volume: BigInt!
}
type TokenCandleSingleton {
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  id: String!
  low: BigInt!
  open: BigInt!
  timestamp: Int!
  token: Bytes!
  volume: BigInt!
}

input TokenCandle_filter {
  candleSize: Int
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
}

enum TokenCandle_orderBy {
  candleSize
  close
  high
  id
  low
  open
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  volume
}

enum OrderDirection {
  asc
  desc
}

type Query {
  tokenCandles(orderBy: TokenCandle_orderBy, orderDirection: OrderDirection, where: TokenCandle_filter): [TokenCandle!]!
  tokenCandleSingleton(id: ID!): TokenCandleSingleton!
}
