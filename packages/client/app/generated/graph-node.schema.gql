"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type BorrowerHistory {
  borrower: Bytes!
  claimInUSD: BigInt
  id: Bytes!
  lostDepositInUSD: BigInt
  pool: Bytes!
  timestamp: BigInt!
  type: BorrowerHistoryType!
  values(first: Int = 100, orderBy: TokenAmount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAmount_filter): [TokenAmount!]!
}

enum BorrowerHistoryType {
  CLAIMED_REWARDS
  DEPOSITED
  WITHDRAWN
}

input BorrowerHistory_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BorrowerHistory_filter]
  borrower: Bytes
  borrower_contains: Bytes
  borrower_gt: Bytes
  borrower_gte: Bytes
  borrower_in: [Bytes!]
  borrower_lt: Bytes
  borrower_lte: Bytes
  borrower_not: Bytes
  borrower_not_contains: Bytes
  borrower_not_in: [Bytes!]
  claimInUSD: BigInt
  claimInUSD_gt: BigInt
  claimInUSD_gte: BigInt
  claimInUSD_in: [BigInt!]
  claimInUSD_lt: BigInt
  claimInUSD_lte: BigInt
  claimInUSD_not: BigInt
  claimInUSD_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lostDepositInUSD: BigInt
  lostDepositInUSD_gt: BigInt
  lostDepositInUSD_gte: BigInt
  lostDepositInUSD_in: [BigInt!]
  lostDepositInUSD_lt: BigInt
  lostDepositInUSD_lte: BigInt
  lostDepositInUSD_not: BigInt
  lostDepositInUSD_not_in: [BigInt!]
  or: [BorrowerHistory_filter]
  pool: Bytes
  pool_contains: Bytes
  pool_gt: Bytes
  pool_gte: Bytes
  pool_in: [Bytes!]
  pool_lt: Bytes
  pool_lte: Bytes
  pool_not: Bytes
  pool_not_contains: Bytes
  pool_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  type: BorrowerHistoryType
  type_in: [BorrowerHistoryType!]
  type_not: BorrowerHistoryType
  type_not_in: [BorrowerHistoryType!]
  values: [String!]
  values_: TokenAmount_filter
  values_contains: [String!]
  values_contains_nocase: [String!]
  values_not: [String!]
  values_not_contains: [String!]
  values_not_contains_nocase: [String!]
}

enum BorrowerHistory_orderBy {
  borrower
  claimInUSD
  id
  lostDepositInUSD
  pool
  timestamp
  type
  values
}

scalar Bytes

type CollateralTokenMeta {
  id: String!
  timestamp: BigInt!
  token: Token!
  totalValueLockedUSD: BigInt!
  totalValueLockedUSD30dAverage: TotalValueLockedAverage!
}

input CollateralTokenMeta_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralTokenMeta_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [CollateralTokenMeta_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalValueLockedUSD: BigInt
  totalValueLockedUSD30dAverage: String
  totalValueLockedUSD30dAverage_: TotalValueLockedAverage_filter
  totalValueLockedUSD30dAverage_contains: String
  totalValueLockedUSD30dAverage_contains_nocase: String
  totalValueLockedUSD30dAverage_ends_with: String
  totalValueLockedUSD30dAverage_ends_with_nocase: String
  totalValueLockedUSD30dAverage_gt: String
  totalValueLockedUSD30dAverage_gte: String
  totalValueLockedUSD30dAverage_in: [String!]
  totalValueLockedUSD30dAverage_lt: String
  totalValueLockedUSD30dAverage_lte: String
  totalValueLockedUSD30dAverage_not: String
  totalValueLockedUSD30dAverage_not_contains: String
  totalValueLockedUSD30dAverage_not_contains_nocase: String
  totalValueLockedUSD30dAverage_not_ends_with: String
  totalValueLockedUSD30dAverage_not_ends_with_nocase: String
  totalValueLockedUSD30dAverage_not_in: [String!]
  totalValueLockedUSD30dAverage_not_starts_with: String
  totalValueLockedUSD30dAverage_not_starts_with_nocase: String
  totalValueLockedUSD30dAverage_starts_with: String
  totalValueLockedUSD30dAverage_starts_with_nocase: String
  totalValueLockedUSD_gt: BigInt
  totalValueLockedUSD_gte: BigInt
  totalValueLockedUSD_in: [BigInt!]
  totalValueLockedUSD_lt: BigInt
  totalValueLockedUSD_lte: BigInt
  totalValueLockedUSD_not: BigInt
  totalValueLockedUSD_not_in: [BigInt!]
}

enum CollateralTokenMeta_orderBy {
  id
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  totalValueLockedUSD
  totalValueLockedUSD30dAverage
  totalValueLockedUSD30dAverage__id
  totalValueLockedUSD30dAverage__index
  totalValueLockedUSD30dAverage__value
}

type DebtTokenMeta {
  id: String!
  stabilityDepositAPY: StabilityDepositAPY!
  timestamp: BigInt!
  token: Token!
  totalDepositedStability: BigInt!
  totalReserve: BigInt!
  totalReserve30dAverage: TotalReserveAverage!
  totalSupplyUSD: BigInt!
  totalSupplyUSD30dAverage: TotalSupplyAverage!
}

input DebtTokenMeta_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DebtTokenMeta_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [DebtTokenMeta_filter]
  stabilityDepositAPY: String
  stabilityDepositAPY_: StabilityDepositAPY_filter
  stabilityDepositAPY_contains: String
  stabilityDepositAPY_contains_nocase: String
  stabilityDepositAPY_ends_with: String
  stabilityDepositAPY_ends_with_nocase: String
  stabilityDepositAPY_gt: String
  stabilityDepositAPY_gte: String
  stabilityDepositAPY_in: [String!]
  stabilityDepositAPY_lt: String
  stabilityDepositAPY_lte: String
  stabilityDepositAPY_not: String
  stabilityDepositAPY_not_contains: String
  stabilityDepositAPY_not_contains_nocase: String
  stabilityDepositAPY_not_ends_with: String
  stabilityDepositAPY_not_ends_with_nocase: String
  stabilityDepositAPY_not_in: [String!]
  stabilityDepositAPY_not_starts_with: String
  stabilityDepositAPY_not_starts_with_nocase: String
  stabilityDepositAPY_starts_with: String
  stabilityDepositAPY_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalDepositedStability: BigInt
  totalDepositedStability_gt: BigInt
  totalDepositedStability_gte: BigInt
  totalDepositedStability_in: [BigInt!]
  totalDepositedStability_lt: BigInt
  totalDepositedStability_lte: BigInt
  totalDepositedStability_not: BigInt
  totalDepositedStability_not_in: [BigInt!]
  totalReserve: BigInt
  totalReserve30dAverage: String
  totalReserve30dAverage_: TotalReserveAverage_filter
  totalReserve30dAverage_contains: String
  totalReserve30dAverage_contains_nocase: String
  totalReserve30dAverage_ends_with: String
  totalReserve30dAverage_ends_with_nocase: String
  totalReserve30dAverage_gt: String
  totalReserve30dAverage_gte: String
  totalReserve30dAverage_in: [String!]
  totalReserve30dAverage_lt: String
  totalReserve30dAverage_lte: String
  totalReserve30dAverage_not: String
  totalReserve30dAverage_not_contains: String
  totalReserve30dAverage_not_contains_nocase: String
  totalReserve30dAverage_not_ends_with: String
  totalReserve30dAverage_not_ends_with_nocase: String
  totalReserve30dAverage_not_in: [String!]
  totalReserve30dAverage_not_starts_with: String
  totalReserve30dAverage_not_starts_with_nocase: String
  totalReserve30dAverage_starts_with: String
  totalReserve30dAverage_starts_with_nocase: String
  totalReserve_gt: BigInt
  totalReserve_gte: BigInt
  totalReserve_in: [BigInt!]
  totalReserve_lt: BigInt
  totalReserve_lte: BigInt
  totalReserve_not: BigInt
  totalReserve_not_in: [BigInt!]
  totalSupplyUSD: BigInt
  totalSupplyUSD30dAverage: String
  totalSupplyUSD30dAverage_: TotalSupplyAverage_filter
  totalSupplyUSD30dAverage_contains: String
  totalSupplyUSD30dAverage_contains_nocase: String
  totalSupplyUSD30dAverage_ends_with: String
  totalSupplyUSD30dAverage_ends_with_nocase: String
  totalSupplyUSD30dAverage_gt: String
  totalSupplyUSD30dAverage_gte: String
  totalSupplyUSD30dAverage_in: [String!]
  totalSupplyUSD30dAverage_lt: String
  totalSupplyUSD30dAverage_lte: String
  totalSupplyUSD30dAverage_not: String
  totalSupplyUSD30dAverage_not_contains: String
  totalSupplyUSD30dAverage_not_contains_nocase: String
  totalSupplyUSD30dAverage_not_ends_with: String
  totalSupplyUSD30dAverage_not_ends_with_nocase: String
  totalSupplyUSD30dAverage_not_in: [String!]
  totalSupplyUSD30dAverage_not_starts_with: String
  totalSupplyUSD30dAverage_not_starts_with_nocase: String
  totalSupplyUSD30dAverage_starts_with: String
  totalSupplyUSD30dAverage_starts_with_nocase: String
  totalSupplyUSD_gt: BigInt
  totalSupplyUSD_gte: BigInt
  totalSupplyUSD_in: [BigInt!]
  totalSupplyUSD_lt: BigInt
  totalSupplyUSD_lte: BigInt
  totalSupplyUSD_not: BigInt
  totalSupplyUSD_not_in: [BigInt!]
}

enum DebtTokenMeta_orderBy {
  id
  stabilityDepositAPY
  stabilityDepositAPY__id
  stabilityDepositAPY__index
  stabilityDepositAPY__profit
  stabilityDepositAPY__volume
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  totalDepositedStability
  totalReserve
  totalReserve30dAverage
  totalReserve30dAverage__id
  totalReserve30dAverage__index
  totalReserve30dAverage__value
  totalSupplyUSD
  totalSupplyUSD30dAverage
  totalSupplyUSD30dAverage__id
  totalSupplyUSD30dAverage__index
  totalSupplyUSD30dAverage__value
}

"8 bytes signed integer\n"
scalar Int8

enum LongShortDirection {
  LONG
  SHORT
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  id: String!
  liquidity(first: Int = 100, orderBy: PoolLiquidity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolLiquidity_filter): [PoolLiquidity!]!
  liquidityDepositAPY: BigInt!
  totalSupply: BigInt!
  volume30dUSD: PoolVolume30d!
  volume30dUSD30dAgo: PoolVolume30d!
}

type PoolLiquidity {
  id: Bytes!
  token: Token!
  totalAmount: BigInt!
}

input PoolLiquidity_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolLiquidity_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [PoolLiquidity_filter]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalAmount: BigInt
  totalAmount_gt: BigInt
  totalAmount_gte: BigInt
  totalAmount_in: [BigInt!]
  totalAmount_lt: BigInt
  totalAmount_lte: BigInt
  totalAmount_not: BigInt
  totalAmount_not_in: [BigInt!]
}

enum PoolLiquidity_orderBy {
  id
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  totalAmount
}

type PoolVolume30d {
  feeUSD: BigInt!
  id: Bytes!
  lastIndex: Int!
  leadingIndex: Int!
  value: BigInt!
}

input PoolVolume30d_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolVolume30d_filter]
  feeUSD: BigInt
  feeUSD_gt: BigInt
  feeUSD_gte: BigInt
  feeUSD_in: [BigInt!]
  feeUSD_lt: BigInt
  feeUSD_lte: BigInt
  feeUSD_not: BigInt
  feeUSD_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lastIndex: Int
  lastIndex_gt: Int
  lastIndex_gte: Int
  lastIndex_in: [Int!]
  lastIndex_lt: Int
  lastIndex_lte: Int
  lastIndex_not: Int
  lastIndex_not_in: [Int!]
  leadingIndex: Int
  leadingIndex_gt: Int
  leadingIndex_gte: Int
  leadingIndex_in: [Int!]
  leadingIndex_lt: Int
  leadingIndex_lte: Int
  leadingIndex_not: Int
  leadingIndex_not_in: [Int!]
  or: [PoolVolume30d_filter]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum PoolVolume30d_orderBy {
  feeUSD
  id
  lastIndex
  leadingIndex
  value
}

type PoolVolumeChunk {
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

input PoolVolumeChunk_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PoolVolumeChunk_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [PoolVolumeChunk_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum PoolVolumeChunk_orderBy {
  id
  timestamp
  value
}

input Pool_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Pool_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  liquidity: [String!]
  liquidityDepositAPY: BigInt
  liquidityDepositAPY_gt: BigInt
  liquidityDepositAPY_gte: BigInt
  liquidityDepositAPY_in: [BigInt!]
  liquidityDepositAPY_lt: BigInt
  liquidityDepositAPY_lte: BigInt
  liquidityDepositAPY_not: BigInt
  liquidityDepositAPY_not_in: [BigInt!]
  liquidity_: PoolLiquidity_filter
  liquidity_contains: [String!]
  liquidity_contains_nocase: [String!]
  liquidity_not: [String!]
  liquidity_not_contains: [String!]
  liquidity_not_contains_nocase: [String!]
  or: [Pool_filter]
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  volume30dUSD: String
  volume30dUSD30dAgo: String
  volume30dUSD30dAgo_: PoolVolume30d_filter
  volume30dUSD30dAgo_contains: String
  volume30dUSD30dAgo_contains_nocase: String
  volume30dUSD30dAgo_ends_with: String
  volume30dUSD30dAgo_ends_with_nocase: String
  volume30dUSD30dAgo_gt: String
  volume30dUSD30dAgo_gte: String
  volume30dUSD30dAgo_in: [String!]
  volume30dUSD30dAgo_lt: String
  volume30dUSD30dAgo_lte: String
  volume30dUSD30dAgo_not: String
  volume30dUSD30dAgo_not_contains: String
  volume30dUSD30dAgo_not_contains_nocase: String
  volume30dUSD30dAgo_not_ends_with: String
  volume30dUSD30dAgo_not_ends_with_nocase: String
  volume30dUSD30dAgo_not_in: [String!]
  volume30dUSD30dAgo_not_starts_with: String
  volume30dUSD30dAgo_not_starts_with_nocase: String
  volume30dUSD30dAgo_starts_with: String
  volume30dUSD30dAgo_starts_with_nocase: String
  volume30dUSD_: PoolVolume30d_filter
  volume30dUSD_contains: String
  volume30dUSD_contains_nocase: String
  volume30dUSD_ends_with: String
  volume30dUSD_ends_with_nocase: String
  volume30dUSD_gt: String
  volume30dUSD_gte: String
  volume30dUSD_in: [String!]
  volume30dUSD_lt: String
  volume30dUSD_lte: String
  volume30dUSD_not: String
  volume30dUSD_not_contains: String
  volume30dUSD_not_contains_nocase: String
  volume30dUSD_not_ends_with: String
  volume30dUSD_not_ends_with_nocase: String
  volume30dUSD_not_in: [String!]
  volume30dUSD_not_starts_with: String
  volume30dUSD_not_starts_with_nocase: String
  volume30dUSD_starts_with: String
  volume30dUSD_starts_with_nocase: String
}

enum Pool_orderBy {
  id
  liquidity
  liquidityDepositAPY
  totalSupply
  volume30dUSD
  volume30dUSD30dAgo
  volume30dUSD30dAgo__feeUSD
  volume30dUSD30dAgo__id
  volume30dUSD30dAgo__lastIndex
  volume30dUSD30dAgo__leadingIndex
  volume30dUSD30dAgo__value
  volume30dUSD__feeUSD
  volume30dUSD__id
  volume30dUSD__lastIndex
  volume30dUSD__leadingIndex
  volume30dUSD__value
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  borrowerHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BorrowerHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BorrowerHistory_filter
  ): [BorrowerHistory!]!
  borrowerHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowerHistory
  collateralTokenMeta(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralTokenMeta
  collateralTokenMetas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralTokenMeta_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralTokenMeta_filter
  ): [CollateralTokenMeta!]!
  debtTokenMeta(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtTokenMeta
  debtTokenMetas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtTokenMeta_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtTokenMeta_filter
  ): [DebtTokenMeta!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolLiquidity_filter
  ): [PoolLiquidity!]!
  poolLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolLiquidity
  poolVolume30D(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolVolume30d
  poolVolume30Ds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolVolume30d_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolVolume30d_filter
  ): [PoolVolume30d!]!
  poolVolumeChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolVolumeChunk
  poolVolumeChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolVolumeChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolVolumeChunk_filter
  ): [PoolVolumeChunk!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  stabilityDepositAPY(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityDepositAPY
  stabilityDepositAPYs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StabilityDepositAPY_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StabilityDepositAPY_filter
  ): [StabilityDepositAPY!]!
  stabilityDepositChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityDepositChunk
  stabilityDepositChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StabilityDepositChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StabilityDepositChunk_filter
  ): [StabilityDepositChunk!]!
  swapEvent(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapEvent
  swapEvents(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SwapEvent_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SwapEvent_filter
  ): [SwapEvent!]!
  systemInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemInfo
  systemInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SystemInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SystemInfo_filter
  ): [SystemInfo!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenAmount
  tokenAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenAmount_filter
  ): [TokenAmount!]!
  tokenCandle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenCandle
  tokenCandleSingleton(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenCandleSingleton
  tokenCandleSingletons(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenCandleSingleton_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenCandleSingleton_filter
  ): [TokenCandleSingleton!]!
  tokenCandles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenCandle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenCandle_filter
  ): [TokenCandle!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  totalReserveAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalReserveAverage
  totalReserveAverageChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalReserveAverageChunk
  totalReserveAverageChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalReserveAverageChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalReserveAverageChunk_filter
  ): [TotalReserveAverageChunk!]!
  totalReserveAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalReserveAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalReserveAverage_filter
  ): [TotalReserveAverage!]!
  totalSupplyAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalSupplyAverage
  totalSupplyAverageChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalSupplyAverageChunk
  totalSupplyAverageChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalSupplyAverageChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalSupplyAverageChunk_filter
  ): [TotalSupplyAverageChunk!]!
  totalSupplyAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalSupplyAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalSupplyAverage_filter
  ): [TotalSupplyAverage!]!
  totalValueLockedAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalValueLockedAverage
  totalValueLockedAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalValueLockedAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalValueLockedAverage_filter
  ): [TotalValueLockedAverage!]!
  totalValueLockedChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalValueLockedChunk
  totalValueLockedChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalValueLockedChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalValueLockedChunk_filter
  ): [TotalValueLockedChunk!]!
}

type StabilityDepositAPY {
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

input StabilityDepositAPY_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StabilityDepositAPY_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  or: [StabilityDepositAPY_filter]
  profit: BigInt
  profit_gt: BigInt
  profit_gte: BigInt
  profit_in: [BigInt!]
  profit_lt: BigInt
  profit_lte: BigInt
  profit_not: BigInt
  profit_not_in: [BigInt!]
  volume: BigInt
  volume_gt: BigInt
  volume_gte: BigInt
  volume_in: [BigInt!]
  volume_lt: BigInt
  volume_lte: BigInt
  volume_not: BigInt
  volume_not_in: [BigInt!]
}

enum StabilityDepositAPY_orderBy {
  id
  index
  profit
  volume
}

type StabilityDepositChunk {
  id: String!
  profit: BigInt!
  timestamp: BigInt!
  volume: BigInt!
}

input StabilityDepositChunk_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StabilityDepositChunk_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [StabilityDepositChunk_filter]
  profit: BigInt
  profit_gt: BigInt
  profit_gte: BigInt
  profit_in: [BigInt!]
  profit_lt: BigInt
  profit_lte: BigInt
  profit_not: BigInt
  profit_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  volume: BigInt
  volume_gt: BigInt
  volume_gte: BigInt
  volume_in: [BigInt!]
  volume_lt: BigInt
  volume_lte: BigInt
  volume_not: BigInt
  volume_not_in: [BigInt!]
}

enum StabilityDepositChunk_orderBy {
  id
  profit
  timestamp
  volume
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  borrowerHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BorrowerHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BorrowerHistory_filter
  ): [BorrowerHistory!]!
  borrowerHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowerHistory
  collateralTokenMeta(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralTokenMeta
  collateralTokenMetas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CollateralTokenMeta_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CollateralTokenMeta_filter
  ): [CollateralTokenMeta!]!
  debtTokenMeta(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtTokenMeta
  debtTokenMetas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DebtTokenMeta_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DebtTokenMeta_filter
  ): [DebtTokenMeta!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolLiquidity_filter
  ): [PoolLiquidity!]!
  poolLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolLiquidity
  poolVolume30D(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolVolume30d
  poolVolume30Ds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolVolume30d_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolVolume30d_filter
  ): [PoolVolume30d!]!
  poolVolumeChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolVolumeChunk
  poolVolumeChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolVolumeChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolVolumeChunk_filter
  ): [PoolVolumeChunk!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  stabilityDepositAPY(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityDepositAPY
  stabilityDepositAPYs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StabilityDepositAPY_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StabilityDepositAPY_filter
  ): [StabilityDepositAPY!]!
  stabilityDepositChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityDepositChunk
  stabilityDepositChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StabilityDepositChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StabilityDepositChunk_filter
  ): [StabilityDepositChunk!]!
  swapEvent(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapEvent
  swapEvents(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SwapEvent_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SwapEvent_filter
  ): [SwapEvent!]!
  systemInfo(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SystemInfo
  systemInfos(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SystemInfo_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SystemInfo_filter
  ): [SystemInfo!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenAmount(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenAmount
  tokenAmounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenAmount_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenAmount_filter
  ): [TokenAmount!]!
  tokenCandle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenCandle
  tokenCandleSingleton(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenCandleSingleton
  tokenCandleSingletons(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenCandleSingleton_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenCandleSingleton_filter
  ): [TokenCandleSingleton!]!
  tokenCandles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenCandle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenCandle_filter
  ): [TokenCandle!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  totalReserveAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalReserveAverage
  totalReserveAverageChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalReserveAverageChunk
  totalReserveAverageChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalReserveAverageChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalReserveAverageChunk_filter
  ): [TotalReserveAverageChunk!]!
  totalReserveAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalReserveAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalReserveAverage_filter
  ): [TotalReserveAverage!]!
  totalSupplyAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalSupplyAverage
  totalSupplyAverageChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalSupplyAverageChunk
  totalSupplyAverageChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalSupplyAverageChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalSupplyAverageChunk_filter
  ): [TotalSupplyAverageChunk!]!
  totalSupplyAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalSupplyAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalSupplyAverage_filter
  ): [TotalSupplyAverage!]!
  totalValueLockedAverage(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalValueLockedAverage
  totalValueLockedAverages(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalValueLockedAverage_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalValueLockedAverage_filter
  ): [TotalValueLockedAverage!]!
  totalValueLockedChunk(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TotalValueLockedChunk
  totalValueLockedChunks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TotalValueLockedChunk_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TotalValueLockedChunk_filter
  ): [TotalValueLockedChunk!]!
}

type SwapEvent {
  borrower: Bytes!
  direction: LongShortDirection!
  id: Bytes!
  size: BigInt!
  swapFee: BigInt!
  timestamp: BigInt!
  token: Token!
  totalPriceInStable: BigInt!
}

input SwapEvent_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapEvent_filter]
  borrower: Bytes
  borrower_contains: Bytes
  borrower_gt: Bytes
  borrower_gte: Bytes
  borrower_in: [Bytes!]
  borrower_lt: Bytes
  borrower_lte: Bytes
  borrower_not: Bytes
  borrower_not_contains: Bytes
  borrower_not_in: [Bytes!]
  direction: LongShortDirection
  direction_in: [LongShortDirection!]
  direction_not: LongShortDirection
  direction_not_in: [LongShortDirection!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [SwapEvent_filter]
  size: BigInt
  size_gt: BigInt
  size_gte: BigInt
  size_in: [BigInt!]
  size_lt: BigInt
  size_lte: BigInt
  size_not: BigInt
  size_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_gt: BigInt
  swapFee_gte: BigInt
  swapFee_in: [BigInt!]
  swapFee_lt: BigInt
  swapFee_lte: BigInt
  swapFee_not: BigInt
  swapFee_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalPriceInStable: BigInt
  totalPriceInStable_gt: BigInt
  totalPriceInStable_gte: BigInt
  totalPriceInStable_in: [BigInt!]
  totalPriceInStable_lt: BigInt
  totalPriceInStable_lte: BigInt
  totalPriceInStable_not: BigInt
  totalPriceInStable_not_in: [BigInt!]
}

enum SwapEvent_orderBy {
  borrower
  direction
  id
  size
  swapFee
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  totalPriceInStable
}

type SystemInfo {
  id: String!
  priceFeed: Bytes!
  stableCoin: Bytes!
  storagePool: Bytes!
  timestamp: BigInt!
}

input SystemInfo_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SystemInfo_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [SystemInfo_filter]
  priceFeed: Bytes
  priceFeed_contains: Bytes
  priceFeed_gt: Bytes
  priceFeed_gte: Bytes
  priceFeed_in: [Bytes!]
  priceFeed_lt: Bytes
  priceFeed_lte: Bytes
  priceFeed_not: Bytes
  priceFeed_not_contains: Bytes
  priceFeed_not_in: [Bytes!]
  stableCoin: Bytes
  stableCoin_contains: Bytes
  stableCoin_gt: Bytes
  stableCoin_gte: Bytes
  stableCoin_in: [Bytes!]
  stableCoin_lt: Bytes
  stableCoin_lte: Bytes
  stableCoin_not: Bytes
  stableCoin_not_contains: Bytes
  stableCoin_not_in: [Bytes!]
  storagePool: Bytes
  storagePool_contains: Bytes
  storagePool_gt: Bytes
  storagePool_gte: Bytes
  storagePool_in: [Bytes!]
  storagePool_lt: Bytes
  storagePool_lte: Bytes
  storagePool_not: Bytes
  storagePool_not_contains: Bytes
  storagePool_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum SystemInfo_orderBy {
  id
  priceFeed
  stableCoin
  storagePool
  timestamp
}

type Token {
  address: Bytes!
  createdAt: BigInt!
  id: Bytes!
  isPoolToken: Boolean!
  priceUSD: BigInt!
  symbol: String!
}

type TokenAmount {
  amount: BigInt!
  id: Bytes!
  token: Token!
}

input TokenAmount_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [TokenAmount_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [TokenAmount_filter]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum TokenAmount_orderBy {
  amount
  id
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
}

type TokenCandle {
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  id: Bytes!
  low: BigInt!
  open: BigInt!
  timestamp: BigInt!
  token: Token!
  volume: BigInt!
}

type TokenCandleSingleton {
  candleSize: Int!
  close: BigInt!
  high: BigInt!
  id: String!
  low: BigInt!
  open: BigInt!
  timestamp: BigInt!
  token: Token!
  volume: BigInt!
}

input TokenCandleSingleton_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenCandleSingleton_filter]
  candleSize: Int
  candleSize_gt: Int
  candleSize_gte: Int
  candleSize_in: [Int!]
  candleSize_lt: Int
  candleSize_lte: Int
  candleSize_not: Int
  candleSize_not_in: [Int!]
  close: BigInt
  close_gt: BigInt
  close_gte: BigInt
  close_in: [BigInt!]
  close_lt: BigInt
  close_lte: BigInt
  close_not: BigInt
  close_not_in: [BigInt!]
  high: BigInt
  high_gt: BigInt
  high_gte: BigInt
  high_in: [BigInt!]
  high_lt: BigInt
  high_lte: BigInt
  high_not: BigInt
  high_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  low: BigInt
  low_gt: BigInt
  low_gte: BigInt
  low_in: [BigInt!]
  low_lt: BigInt
  low_lte: BigInt
  low_not: BigInt
  low_not_in: [BigInt!]
  open: BigInt
  open_gt: BigInt
  open_gte: BigInt
  open_in: [BigInt!]
  open_lt: BigInt
  open_lte: BigInt
  open_not: BigInt
  open_not_in: [BigInt!]
  or: [TokenCandleSingleton_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  volume: BigInt
  volume_gt: BigInt
  volume_gte: BigInt
  volume_in: [BigInt!]
  volume_lt: BigInt
  volume_lte: BigInt
  volume_not: BigInt
  volume_not_in: [BigInt!]
}

enum TokenCandleSingleton_orderBy {
  candleSize
  close
  high
  id
  low
  open
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  volume
}

input TokenCandle_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenCandle_filter]
  candleSize: Int
  candleSize_gt: Int
  candleSize_gte: Int
  candleSize_in: [Int!]
  candleSize_lt: Int
  candleSize_lte: Int
  candleSize_not: Int
  candleSize_not_in: [Int!]
  close: BigInt
  close_gt: BigInt
  close_gte: BigInt
  close_in: [BigInt!]
  close_lt: BigInt
  close_lte: BigInt
  close_not: BigInt
  close_not_in: [BigInt!]
  high: BigInt
  high_gt: BigInt
  high_gte: BigInt
  high_in: [BigInt!]
  high_lt: BigInt
  high_lte: BigInt
  high_not: BigInt
  high_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  low: BigInt
  low_gt: BigInt
  low_gte: BigInt
  low_in: [BigInt!]
  low_lt: BigInt
  low_lte: BigInt
  low_not: BigInt
  low_not_in: [BigInt!]
  open: BigInt
  open_gt: BigInt
  open_gte: BigInt
  open_in: [BigInt!]
  open_lt: BigInt
  open_lte: BigInt
  open_not: BigInt
  open_not_in: [BigInt!]
  or: [TokenCandle_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  volume: BigInt
  volume_gt: BigInt
  volume_gte: BigInt
  volume_in: [BigInt!]
  volume_lt: BigInt
  volume_lte: BigInt
  volume_not: BigInt
  volume_not_in: [BigInt!]
}

enum TokenCandle_orderBy {
  candleSize
  close
  high
  id
  low
  open
  timestamp
  token
  token__address
  token__createdAt
  token__id
  token__isPoolToken
  token__priceUSD
  token__symbol
  volume
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [Token_filter]
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  isPoolToken: Boolean
  isPoolToken_in: [Boolean!]
  isPoolToken_not: Boolean
  isPoolToken_not_in: [Boolean!]
  or: [Token_filter]
  priceUSD: BigInt
  priceUSD_gt: BigInt
  priceUSD_gte: BigInt
  priceUSD_in: [BigInt!]
  priceUSD_lt: BigInt
  priceUSD_lte: BigInt
  priceUSD_not: BigInt
  priceUSD_not_in: [BigInt!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
}

enum Token_orderBy {
  address
  createdAt
  id
  isPoolToken
  priceUSD
  symbol
}

type TotalReserveAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type TotalReserveAverageChunk {
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

input TotalReserveAverageChunk_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalReserveAverageChunk_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [TotalReserveAverageChunk_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalReserveAverageChunk_orderBy {
  id
  timestamp
  value
}

input TotalReserveAverage_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalReserveAverage_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  or: [TotalReserveAverage_filter]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalReserveAverage_orderBy {
  id
  index
  value
}

type TotalSupplyAverage {
  id: String!
  index: Int!
  value: BigInt!
}

type TotalSupplyAverageChunk {
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

input TotalSupplyAverageChunk_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalSupplyAverageChunk_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [TotalSupplyAverageChunk_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalSupplyAverageChunk_orderBy {
  id
  timestamp
  value
}

input TotalSupplyAverage_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalSupplyAverage_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  or: [TotalSupplyAverage_filter]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalSupplyAverage_orderBy {
  id
  index
  value
}

type TotalValueLockedAverage {
  id: String!
  index: Int!
  value: BigInt!
}

input TotalValueLockedAverage_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalValueLockedAverage_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  or: [TotalValueLockedAverage_filter]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalValueLockedAverage_orderBy {
  id
  index
  value
}

type TotalValueLockedChunk {
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

input TotalValueLockedChunk_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TotalValueLockedChunk_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [TotalValueLockedChunk_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum TotalValueLockedChunk_orderBy {
  id
  timestamp
  value
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}