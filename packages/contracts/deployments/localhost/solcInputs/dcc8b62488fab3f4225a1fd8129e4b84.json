{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\ncontract CheckContract {\n  using Address for address;\n\n  error ZeroAddress();\n  error NotContract();\n\n  /**\n   * Check that the account is an already deployed non-destroyed contract.\n   * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\n   */\n  function checkContract(address _account) internal view {\n    if (_account == address(0)) revert ZeroAddress();\n\n    uint256 size;\n    assembly {\n      size := extcodesize(_account)\n    }\n    if (size == 0) revert NotContract();\n  }\n}\n"
    },
    "contracts/Dependencies/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n *\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n   * given `owner`'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases `owner`'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   *\n   * `owner` can limit the time a Permit is valid for by setting `deadline` to\n   * a value in the near future. The deadline argument can be set to uint(-1) to\n   * create Permits that effectively never expire.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function permitTypeHash() external view returns (bytes32);\n\n  function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/Dependencies/LiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './LiquityMath.sol';\nimport '../Interfaces/IBase.sol';\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract LiquityBase is IBase {\n  uint internal constant DECIMAL_PRECISION = 1e18;\n  uint32 public constant SWAP_FEE_PRECISION = 1e6;\n  uint32 public constant SWAP_BASE_FEE = 0.003e6; // 0.3%\n  uint public constant _100pct = 1e18; // 1e18 == 100%\n  uint public constant MCR = 1.1e18; // 110%, Minimum collateral ratio for individual troves\n  uint public constant CCR = 1.5e18; // 150%, Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n  uint public constant STABLE_COIN_GAS_COMPENSATION = 200e18; // Amount of stable to be locked in gas pool on opening troves\n  uint public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n  uint public constant MAX_BORROWING_FEE = 0.05e18; // 5%\n  uint public constant BORROWING_FEE_FLOOR = 0.005e18; // 0.5%\n  uint public constant REDEMPTION_FEE_FLOOR = 0.005e18; // 0.5%\n\n  // todo update\n  address public constant GOV_STAKING_ADDRESS = address(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n  uint32 public constant GOV_SWAP_FEE = 0.5e6; // 50% of the dynamic swap fee\n\n  // Return the coll amount of to be drawn from a trove's collateral and sent as gas compensation.\n  function _getCollGasCompensation(uint _collAmount) internal pure returns (uint) {\n    return _collAmount / PERCENT_DIVISOR;\n  }\n\n  function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\n    if (_fee == 0) return;\n\n    uint feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n    // Fee exceeded provided maximum\n    if (feePercentage > _maxFeePercentage) revert FeeExceedMaxPercentage();\n  }\n}\n"
    },
    "contracts/Dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LiquityMath {\n  uint internal constant DECIMAL_PRECISION = 1e18;\n\n  function _min(uint _a, uint _b) internal pure returns (uint) {\n    return (_a < _b) ? _a : _b;\n  }\n\n  function _max(uint _a, uint _b) internal pure returns (uint) {\n    return (_a >= _b) ? _a : _b;\n  }\n\n  /*\n   * Multiply two decimal numbers and use normal rounding rules:\n   * -round product up if 19'th mantissa digit >= 5\n   * -round product down if 19'th mantissa digit < 5\n   *\n   * Used only inside the exponentiation, _decPow().\n   */\n  function decMul(uint x, uint y) internal pure returns (uint decProd) {\n    uint prod_xy = x * y;\n\n    decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\n  }\n\n  /*\n   * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n   *\n   * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n   *\n   * Called by two functions that represent time in units of minutes:\n   * 1) TroveManager._calcDecayedBaseRate\n   * 2) CommunityIssuance._getCumulativeIssuanceFraction\n   *\n   * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n   * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n   *\n   * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n   * negligibly different from just passing the cap, since:\n   *\n   * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n   * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n   */\n  function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n    if (_minutes > 525600000) {\n      _minutes = 525600000;\n    } // cap to avoid overflow\n\n    if (_minutes == 0) {\n      return DECIMAL_PRECISION;\n    }\n\n    uint y = DECIMAL_PRECISION;\n    uint x = _base;\n    uint n = _minutes;\n\n    // Exponentiation-by-squaring\n    while (n > 1) {\n      if (n % 2 == 0) {\n        x = decMul(x, x);\n        n = n / 2;\n      } else {\n        // if (n % 2 != 0)\n        y = decMul(x, y);\n        x = decMul(x, x);\n        n = (n - 1) / 2;\n      }\n    }\n\n    return decMul(x, y);\n  }\n\n  function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n    return (_a >= _b) ? _a - _b : _b - _a;\n  }\n\n  function _computeCR(uint _coll, uint _debt) internal pure returns (uint) {\n    if (_debt > 0) return (_coll * DECIMAL_PRECISION) / _debt;\n\n    // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n    // if (_debt == 0)\n    return 2 ** 256 - 1;\n  }\n\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n  function _sqrt(uint y) internal pure returns (uint z) {\n    if (y > 3) {\n      z = y;\n      uint x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n  }\n}\n"
    },
    "contracts/Dependencies/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n  uint224 constant Q112 = 2 ** 112;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 y) internal pure returns (uint224 z) {\n    z = uint224(y) * Q112; // never overflows\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n    z = x / uint224(y);\n  }\n}\n"
    },
    "contracts/Interfaces/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBase {\n  enum PoolType {\n    Active, // assets in active troves\n    Default, // assets from redistributions, which are not yet claimed by the trove owners\n    GasCompensation // stableCoin from gas compensation\n  }\n\n  error FeeExceedMaxPercentage();\n\n  struct MintMeta {\n    address upperHint;\n    address lowerHint;\n    uint maxFeePercentage;\n  }\n\n  struct RAmount {\n    address tokenAddress;\n    bool isColl; // coll or debt token\n    uint amount; // initial value in trove\n    uint pendingReward; // gained rewards since deposit\n    uint gasCompensation; // gas compensation for liquidation\n    uint toLiquidate; // amount + pendingReward - gasCompensation\n    uint toRedistribute; // across other open troves\n    uint toOffset; // by stability pools\n    uint collSurplus; // coll only, in case of an ICR > MCR liquidation\n  }\n\n  struct CAmount {\n    address tokenAddress;\n    bool isColl; // coll or debt token\n    uint amount;\n  }\n\n  struct TokenAmount {\n    address tokenAddress;\n    uint amount;\n  }\n}\n"
    },
    "contracts/Interfaces/IBBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\nimport './IDebtToken.sol';\nimport './IStabilityPool.sol';\n\ninterface IBBase is IBase {\n  enum Status {\n    nonExistent,\n    active,\n    closedByOwner,\n    closedByLiquidationInNormalMode,\n    closedByLiquidationInRecoveryMode\n  }\n\n  struct DebtTokenAmount {\n    IDebtToken debtToken;\n    uint netDebt;\n    uint borrowingFee; // only in case of stable coin\n  }\n\n  struct RemainingStability {\n    IStabilityPool stabilityPool;\n    address tokenAddress;\n    uint remaining;\n    uint debtToOffset; // debt amount which will be removed from the stability pool to liquidate the trove\n    TokenAmount[] collGained; // coll which will be sent to the SP as rewards (multiple entries with same token address are possible)\n  }\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations is IBBase {\n  // --- Events ---\n\n  event BorrowerOperationsInitialized(\n    address _troveManagerAddress,\n    address _storagePoolAddress,\n    address _stabilityPoolAddress,\n    address _reservePoolAddress,\n    address _priceFeedAddress,\n    address _debtTokenManagerAddress,\n    address _collTokenManagerAddress,\n    address _swapOperationsAddress,\n    address _sortedTrovesAddress,\n    address _collSurplusPoolAddress\n  );\n  event TroveCreated(address _borrower, TokenAmount[] _colls);\n  event PaidBorrowingFee(address indexed _borrower, uint amount);\n\n  // --- Custom Errors ---\n\n  error NotFromStabilityPool();\n  error NotFromSwapOps();\n  error CollWithdrawPermittedInRM();\n  error ICR_lt_MCR();\n  error ICR_lt_CCR();\n  error TCR_lt_CCR();\n  error ICRDecreasedInRM();\n  error MaxFee_gt_100_InRM();\n  error MaxFee_out_Range();\n  error Repaid_gt_CurrentDebt();\n  error TroveClosedOrNotExist();\n  error ActiveTrove();\n  error NotAllowedInRecoveryMode();\n  error NotBorrower();\n  error WithdrawAmount_gt_Coll();\n  error ZeroDebtChange();\n  error InsufficientDebtToRepay();\n  error ZeroDebtRepay();\n\n  // --- Functions ---\n\n  function openTrove(TokenAmount[] memory _colls) external;\n\n  function openTroveWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external;\n\n  function addColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) external;\n\n  function addCollWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s,\n    address _upperHint,\n    address _lowerHint\n  ) external;\n\n  function withdrawColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) external;\n\n  function increaseDebt(address _borrower, address _to, TokenAmount[] memory _debts, MintMeta memory _meta) external;\n\n  function repayDebt(TokenAmount[] memory _debts, address _upperHint, address _lowerHint) external;\n\n  function repayDebtFromPoolBurn(\n    address borrower,\n    TokenAmount[] memory _debts,\n    address _upperHint,\n    address _lowerHint\n  ) external;\n\n  function closeTrove() external;\n\n  function claimCollateral() external;\n\n  function getCompositeDebt(DebtTokenAmount[] memory _debts) external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '../Dependencies/IERC2612.sol';\nimport './IBase.sol';\n\ninterface IDebtToken is IERC20, IERC20Metadata, IERC2612, IBase {\n  // --- Custom Errors ---\n  error NotFromBorrowerOps();\n  error NotFromBOorTroveMorSPorDebtToken();\n  error NotFromSPManager();\n  error NotFromTroveMorSP();\n  error NotAllowedDirectTransfer();\n  error InvalidSignature();\n  error ExpiredDeadline();\n  error InsufficientBalance();\n\n  // --- Functions ---\n\n  function isStableCoin() external view returns (bool);\n\n  function getPrice() external view returns (uint);\n\n  function mint(address _account, uint256 _amount) external;\n\n  function burn(address _account, uint256 _amount) external;\n\n  function sendToPool(address _sender, address _poolAddress, uint256 _amount) external;\n\n  function totalSupply() external view override returns (uint256);\n\n  function balanceOf(address account) external view override returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external override returns (bool);\n\n  function allowance(address owner, address spender) external view override returns (uint256);\n\n  function approve(address spender, uint256 amount) external override returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n  function domainSeparator() external view override returns (bytes32);\n\n  function permit(\n    address owner,\n    address spender,\n    uint amount,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override;\n\n  function nonces(address owner) external view override returns (uint256);\n\n  function name() external view override returns (string memory);\n\n  function symbol() external view override returns (string memory);\n\n  function decimals() external view override returns (uint8);\n\n  function version() external view override returns (string memory);\n\n  function permitTypeHash() external view override returns (bytes32);\n}\n"
    },
    "contracts/Interfaces/IDebtTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\n\n// Common interface for the dToken Manager.\ninterface IDebtTokenManager {\n  // --- Events ---\n\n  event DebtTokenManagerInitialized(address _stabilityPoolManagerAddress);\n  event DebtTokenAdded(address _debtTokenAddress);\n\n  // --- Custom Errors ---\n\n  error InvalidDebtToken();\n  error SymbolAlreadyExists();\n  error StableCoinAlreadyExists();\n\n  // --- Functions ---\n\n  function getStableCoin() external view returns (IDebtToken);\n\n  function isDebtToken(address _address) external view returns (bool);\n\n  function getDebtToken(address _address) external view returns (IDebtToken);\n\n  function getDebtTokenAddresses() external view returns (address[] memory);\n\n  function addDebtToken(address _debtTokenAddress) external;\n}\n"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\n\ninterface IPriceFeed is IBase {\n  enum Status {\n    working,\n    oraclesUntrusted\n  }\n\n  // --- Events ---\n  event LastGoodPriceUpdated(address _token, uint _lastGoodPrice);\n  event PriceFeedStatusChanged(address _token, Status newStatus);\n  event TokenPriceChanged(address _token);\n\n  // --- Function ---\n  function getPrice(address _tokenAddress) external view returns (uint price);\n\n  function getUSDValue(address _token, uint _amount) external view returns (uint usdValue);\n\n  function getAmountFromUSDValue(address _token, uint256 _usdValue) external view returns (uint amount);\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\nimport './IBase.sol';\n\ninterface IStabilityPool is IBase {\n  // --- Events ---\n\n  event StabilityPoolInitialized(address stabilityPoolManagerAddress, address depositTokenAddress);\n\n  event StabilityProvided(address user, uint amount);\n  event StabilityWithdrawn(address user, uint amount);\n  event StabilityGainsWithdrawn(address user, uint depositLost, TokenAmount[] gainsWithdrawn);\n\n  // used as trigger to update the users compounded deposit and current coll gains (there is not user specific event for that)\n  event StabilityOffset(uint removedDeposit, TokenAmount[] addedGains);\n\n  event P_Updated(uint _P);\n  event S_Updated(address _tokenAddress, uint _S, uint128 _epoch, uint128 _scale);\n  event EpochUpdated(uint128 _currentEpoch);\n  event ScaleUpdated(uint128 _currentScale);\n  event DepositSnapshotUpdated(address indexed _depositor);\n  // event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n\n  // --- Errors  ---\n\n  error NotFromStabilityPoolManager();\n  error ZeroAmount();\n  error NotOneTrove();\n\n  // --- Functions ---\n\n  function getDepositToken() external view returns (IDebtToken);\n\n  function getTotalDeposit() external view returns (uint);\n\n  function getDepositorDeposit(address _depositor) external view returns (uint);\n\n  function getCompoundedDebtDeposit(address _depositor) external view returns (uint);\n\n  function getTotalGainedColl() external view returns (TokenAmount[] memory coll);\n\n  function getDepositorCollGain(address _depositor, address _collToken) external view returns (uint);\n\n  function getDepositorCollSnapshot(address _depositor, address _collToken) external view returns (uint);\n\n  function provideToSP(address user, uint _amount) external;\n\n  function withdrawFromSP(address user, uint _amount) external;\n\n  function withdrawGains(address user) external;\n\n  function offset(uint _debtToOffset, TokenAmount[] memory _collToAdd) external;\n}\n"
    },
    "contracts/Interfaces/ISwapCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISwapCallee {\n  function swapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/Interfaces/ISwapERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISwapERC20 {\n  error PermitExpired();\n  error InvalidSignature();\n\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address owner) external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/ISwapOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\n\ninterface ISwapOperations is IBBase {\n  error Forbidden();\n  error IdenticalAddresses();\n  error PairExists();\n  error Expired();\n  error PairDoesNotExist();\n  error InsufficientAAmount();\n  error InsufficientBAmount();\n  error InsufficientInputAmount();\n  error InsufficientOutputAmount();\n  error ExcessiveInputAmount();\n  error InsufficientLiquidity();\n  error InsufficientAmount();\n  error InvalidPath();\n  error TransferFromFailed();\n  error PairRequiresStable();  \n\n  event SwapOperationsInitialized(\n    address borrowerOperations,\n    address troveManager,\n    address priceFeed,\n    address debtTokenManager\n  );\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  struct RemoveLiquidtyPermitParams {\n    address tokenA;\n    address tokenB;\n    uint liquidity;\n    uint amountAMin;\n    uint amountBMin;\n    uint deadline;\n    bool approveMax;\n    address _upperHint;\n    address _lowerHint;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  // **** GETTER ****\n\n  function allPairs(uint) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) external pure returns (uint amountOut);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) external pure returns (uint amountIn);\n\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n  // **** OPERATIONS ****\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  function addLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  // automatically repays any related open loans from the borrower (msg.sender)\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address _upperHint,\n    address _lowerHint,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactTokensForTokensWithPermit(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint[] memory amounts);\n\n  function openLongPosition(\n    uint stableToMintIn,\n    uint debtOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function openShortPosition(\n    uint debtToMintIn,\n    uint stableOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n}\n"
    },
    "contracts/Interfaces/ISwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './ISwapERC20.sol';\n\ninterface ISwapPair is ISwapERC20 {\n  error Locked();\n  error TransferFailed();\n  error Forbidden();\n  error Overflow();\n  error InsufficientLiquidityMinted();\n  error InsufficientLiquidityBurned();\n  error InsufficientInputAmount();\n  error InsufficientOutputAmount();\n  error InsufficientLiquidity();\n  error InvalidTo();\n  error K();\n  error NotFromSwapOperations();\n\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    uint32 currentSwapFee,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  // **** GETTER ****\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint);\n\n  function price1CumulativeLast() external view returns (uint);\n\n  function getSwapFee() external view returns (uint32 swapFee);\n\n  // **** OPERATIONS ****\n\n  function mint(address to) external returns (uint liquidity);\n\n  function burn(\n    address to,\n    uint liquidity,\n    uint debt0,\n    uint debt1\n  ) external returns (uint amount0, uint amount1, uint burned0, uint burned1);\n\n  function swap(uint amount0Out, uint amount1Out, address to) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address, address, address) external;\n}\n"
    },
    "contracts/Interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IStabilityPool.sol';\nimport './IDebtToken.sol';\nimport './IBBase.sol';\nimport './IPriceFeed.sol';\nimport './IDebtTokenManager.sol';\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IBBase {\n  // --- Events ---\n\n  event TroveManagerInitialized(\n    address _borrowerOperationsAddress,\n    address _redemptionOperationsAddress,\n    address _liquidationOperationsAddress,\n    address _storagePoolAddress,\n    address _priceFeedAddress,\n    address _sortedTrovesAddress\n  );\n\n  event TroveAppliedRewards(address _borrower, CAmount[] _appliedRewards);\n  event TroveClosed(address _borrower, Status _closingState);\n  event TroveIndexUpdated(address _borrower, uint _newIndex);\n  event TroveCollChanged(address _borrower, address[] _collTokenAddresses);\n\n  event StableCoinBaseRateUpdated(uint _baseRate);\n  event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n  event TotalStakesUpdated(TokenAmount[] _totalStakes);\n  event SystemSnapshotsUpdated(TokenAmount[] _totalStakesSnapshot, TokenAmount[] _totalCollateralSnapshot);\n  event LTermsUpdated(CAmount[] _liquidatedTokens);\n  event TroveSnapshotsUpdated(CAmount[] _liquidatedTokens);\n\n  // --- Errors ---\n\n  error NotFromBorrowerOrRedemptionOps();\n  error InvalidTrove();\n  error OnlyOneTrove();\n\n  // --- Functions ---\n\n  function getTroveOwnersCount() external view returns (uint);\n\n  function getTroveStatus(address _borrower) external view returns (uint);\n\n  function isTroveActive(address _borrower) external view returns (bool);\n\n  function setTroveStatus(address _borrower, uint num) external;\n\n  //\n\n  function getCurrentICR(address _borrower) external view returns (uint ICR, uint currentDebtInUSD);\n\n  function getICRIncludingPatch(\n    address _borrower,\n    TokenAmount[] memory addedColl,\n    TokenAmount[] memory removedColl,\n    TokenAmount[] memory addedDebt,\n    TokenAmount[] memory removedDebt\n  ) external view returns (uint ICR);\n\n  //\n\n  function updateStakeAndTotalStakes(address[] memory collTokenAddresses, address _borrower) external;\n\n  function removeStake(address[] memory collTokenAddresses, address _borrower) external;\n\n  function updateSystemSnapshots_excludeCollRemainder(TokenAmount[] memory totalCollGasCompensation) external;\n\n  function getTroveStakes(address _borrower, address _token) external view returns (uint);\n\n  function getTroveStakeValue(address _borrower) external view returns (uint);\n\n  //\n\n  function redistributeDebtAndColl(address[] memory collTokenAddresses, CAmount[] memory toRedistribute) external;\n\n  function getPendingReward(\n    address _borrower,\n    address _tokenAddress,\n    bool _isColl\n  ) external view returns (uint pendingReward);\n\n  function applyPendingRewards(address _borrower) external;\n\n  function updateTroveRewardSnapshots(address _borrower) external;\n\n  //\n\n  function increaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external;\n\n  function decreaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external;\n\n  function increaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external;\n\n  function decreaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external;\n\n  //\n\n  function getEntireDebtAndColl(\n    address _borrower\n  )\n    external\n    view\n    returns (\n      RAmount[] memory amounts,\n      uint troveCollInUSD,\n      uint troveDebtInUSD,\n      uint troveDebtInUSDWithoutGasCompensation\n    );\n\n  function getTroveDebt(address _borrower) external view returns (TokenAmount[] memory);\n\n  function getTroveRepayableDebt(address _borrower, address _debtTokenAddress, bool _includingStableCoinGasCompensation) external view returns (uint amount);\n\n  function getTroveRepayableDebts(address _borrower, bool _includingStableCoinGasCompensation) external view returns (TokenAmount[] memory);\n\n  function getTroveColl(address _borrower) external view returns (TokenAmount[] memory);\n\n  function getTroveWithdrawableColl(address _borrower, address _collTokenAddress) external view returns (uint amount);\n\n  function getTroveWithdrawableColls(address _borrower) external view returns (TokenAmount[] memory colls);\n\n  //\n\n  function addTroveOwnerToArray(address _borrower) external returns (uint128 index);\n\n  function closeTroveByProtocol(address[] memory collTokenAddresses, address _borrower, Status closedStatus) external;\n\n  //\n\n  function getStableCoinBaseRate() external view returns (uint);\n\n  function getBorrowingRate(bool isStableCoin) external view returns (uint);\n\n  function getBorrowingRateWithDecay(bool isStableCoin) external view returns (uint);\n\n  function getBorrowingFee(uint debt, bool isStableCoin) external view returns (uint);\n\n  function getBorrowingFeeWithDecay(uint debt, bool isStableCoin) external view returns (uint);\n\n  function decayStableCoinBaseRateFromBorrowing(uint borrowedStable) external;\n\n  function updateStableCoinBaseRateFromRedemption(uint _totalRedeemedStable, uint _totalStableCoinSupply) external;\n\n  function calcDecayedStableCoinBaseRate() external view returns (uint);\n}\n"
    },
    "contracts/SwapERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './Interfaces/ISwapERC20.sol';\n\ncontract SwapERC20 is ISwapERC20 {\n  string public constant name = 'Swap';\n  string public constant symbol = 'SWAP';\n  uint8 public constant decimals = 18;\n  uint public totalSupply;\n  mapping(address => uint) public balanceOf;\n  mapping(address => mapping(address => uint)) public allowance;\n\n  bytes32 public DOMAIN_SEPARATOR;\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n  mapping(address => uint) public nonces;\n\n  constructor() {\n    uint chainId;\n    assembly {\n      chainId := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256(bytes(name)),\n        keccak256(bytes('1')),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  function _mint(address to, uint value) internal {\n    totalSupply += value;\n    balanceOf[to] += value;\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(address from, uint value) internal {\n    balanceOf[from] -= value;\n    totalSupply -= value;\n    emit Transfer(from, address(0), value);\n  }\n}\n"
    },
    "contracts/SwapOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './SwapPair.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Interfaces/ISwapOperations.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ITroveManager.sol';\nimport \"hardhat/console.sol\";\n\ncontract SwapOperations is ISwapOperations, Ownable(msg.sender), CheckContract, LiquityBase {\n\n  // --- Connected contract declarations ---\n\n  ITroveManager public troveManager;\n  IBorrowerOperations public borrowerOperations;\n  address public priceFeedAddress;\n  IDebtTokenManager public debtTokenManager;\n\n  // --- Data structures ---\n\n  mapping(address => mapping(address => address)) public getPair;\n  address[] public allPairs;\n\n  // --- Dependency setters ---\n\n  function setAddresses(\n    address _borrowerOperationsAddress,\n    address _troveManagerAddress,\n    address _priceFeedAddress,\n    address _debtTokenManager\n  ) external onlyOwner {\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_troveManagerAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManager);\n\n    borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n    troveManager = ITroveManager(_troveManagerAddress);\n    priceFeedAddress = _priceFeedAddress;\n    debtTokenManager = IDebtTokenManager(_debtTokenManager);\n\n    emit SwapOperationsInitialized(\n      _borrowerOperationsAddress,\n      _troveManagerAddress,\n      _priceFeedAddress,\n      _debtTokenManager\n    );\n\n    // Disabled to create pairs later\n    // renounceOwnership();\n  }\n\n  modifier ensure(uint deadline) {\n    if (deadline < block.timestamp) revert Expired();\n    _;\n  }\n\n  // --- Pair Management ---\n\n  function allPairsLength() external view returns (uint) {\n    return allPairs.length;\n  }\n\n  function createPair(address tokenA, address tokenB) external onlyOwner returns (address pair) {\n    if (tokenA == tokenB) revert IdenticalAddresses();\n    if (tokenA != address(debtTokenManager.getStableCoin()) && tokenB != address(debtTokenManager.getStableCoin()))\n      revert PairRequiresStable();\n\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    if (token0 == address(0)) revert ZeroAddress();\n    if (getPair[token0][token1] != address(0)) revert PairExists(); // single check is sufficient\n\n    bytes memory bytecode = type(SwapPair).creationCode;\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n    assembly {\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n    }\n\n    ISwapPair(pair).initialize(token0, token1, address(debtTokenManager), priceFeedAddress);\n    getPair[token0][token1] = pair;\n    getPair[token1][token0] = pair; // populate mapping in the reverse direction\n    allPairs.push(pair);\n\n    emit PairCreated(token0, token1, pair, allPairs.length);\n  }\n\n  // --- Getter functions ---\n\n  function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n    if (amountA == 0) revert InsufficientAmount();\n    if (reserveA == 0 || reserveB == 0) revert InsufficientLiquidity();\n\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) public pure virtual override returns (uint amountOut) {\n    if (amountIn == 0) revert InsufficientInputAmount();\n    if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n\n    uint amountInWithFee = amountIn * (SWAP_FEE_PRECISION - swapFee);\n    uint numerator = amountInWithFee * reserveOut;\n    uint denominator = reserveIn * SWAP_FEE_PRECISION + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) public pure virtual override returns (uint amountIn) {\n    if (amountOut == 0) revert InsufficientOutputAmount();\n    if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n\n    uint numerator = reserveIn * amountOut * SWAP_FEE_PRECISION;\n    uint denominator = (reserveOut - amountOut) * (SWAP_FEE_PRECISION - swapFee);\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    if (path.length < 2) revert InvalidPath();\n\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i < path.length - 1; i++) {\n      (uint reserveIn, uint reserveOut, uint32 swapFee) = getReserves(path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, swapFee);\n    }\n  }\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    if (path.length < 2) revert InvalidPath();\n\n    amounts = new uint[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint i = path.length - 1; i > 0; i--) {\n      (uint reserveIn, uint reserveOut, uint32 swapFee) = getReserves(path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, swapFee);\n    }\n  }\n\n  // --- Liquidity functions ---\n\n  struct ProvidingVars {\n    address pair;\n    uint senderBalanceA;\n    uint senderBalanceB;\n    uint fromBalanceA;\n    uint fromBalanceB;\n    uint fromMintA;\n    uint fromMintB;\n  }\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n    ProvidingVars memory vars;\n    vars.pair = getPair[tokenA][tokenB];\n    console.log(\"pair: %s\", vars.pair);\n    if (vars.pair == address(0)) revert PairDoesNotExist();\n\n    {\n      (uint reserveA, uint reserveB, ) = getReserves(tokenA, tokenB);\n      if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n      } else {\n        uint amountBOptimal = quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n          if (amountBOptimal < amountBMin) revert InsufficientBAmount();\n          (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n          uint amountAOptimal = quote(amountBDesired, reserveB, reserveA);\n          assert(amountAOptimal <= amountADesired);\n          if (amountAOptimal < amountAMin) revert InsufficientAAmount();\n          (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n      }\n    }\n\n    vars.senderBalanceA = IERC20(tokenA).balanceOf(msg.sender);\n    vars.senderBalanceB = IERC20(tokenB).balanceOf(msg.sender);\n\n    vars.fromBalanceA = LiquityMath._min(vars.senderBalanceA, amountA);\n    vars.fromBalanceB = LiquityMath._min(vars.senderBalanceB, amountB);\n\n    vars.fromMintA = amountA - vars.fromBalanceA;\n    vars.fromMintB = amountB - vars.fromBalanceB;\n\n    // mint new tokens if the sender did not have enough\n    if (vars.fromMintA != 0 || vars.fromMintB != 0) {\n      TokenAmount[] memory debtsToMint;\n      if (vars.fromMintA != 0 && vars.fromMintB != 0) {\n        // mint both\n        debtsToMint = new TokenAmount[](2);\n        debtsToMint[0] = TokenAmount(tokenA, vars.fromMintA);\n        debtsToMint[1] = TokenAmount(tokenB, vars.fromMintB);\n      } else {   \n        // mint only 1 token    \n        debtsToMint = new TokenAmount[](1);\n        debtsToMint[0] = (vars.fromMintA != 0\n          ? TokenAmount(tokenA, vars.fromMintA) // mint A\n          : TokenAmount(tokenB, vars.fromMintB) // mint B\n        );\n      }\n      borrowerOperations.increaseDebt(msg.sender, vars.pair, debtsToMint, _mintMeta);\n    }\n\n    console.log(\"fromBalanceA: %s\", vars.fromBalanceA);\n    console.log(\"fromBalanceB: %s\", vars.fromBalanceB);\n    console.log(\"pair: %s\", vars.pair);\n    console.log(\"msg.sender: %s\", msg.sender);\n    console.log(\"tokenA: %s\", tokenA);\n\n    // transfer tokens sourced from senders balance\n    if (vars.fromBalanceA != 0) safeTransferFrom(tokenA, msg.sender, vars.pair, vars.fromBalanceA);\n    if (vars.fromBalanceB != 0) safeTransferFrom(tokenB, msg.sender, vars.pair, vars.fromBalanceB);\n\n    liquidity = ISwapPair(vars.pair).mint(msg.sender);\n  }\n\n  function addLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external returns (uint amountA, uint amountB, uint liquidity) {\n    IERC20Permit(tokenA).permit(msg.sender, address(this), amountADesired, deadline, v[0], r[0], s[0]);\n    IERC20Permit(tokenB).permit(msg.sender, address(this), amountBDesired, deadline, v[1], r[1], s[1]);\n    return addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, _mintMeta, deadline);\n  }\n\n  struct RemovalVars {\n    address token0;\n    address token1;\n    uint amount0;\n    uint amount1;\n    uint burned0;\n    uint burned1;\n  }\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address _upperHint,\n    address _lowerHint,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n    RemovalVars memory vars;\n    (vars.token0, vars.token1) = sortTokens(tokenA, tokenB);\n\n    // receive tokens from pair\n    address pair = getPair[tokenA][tokenB];\n    (vars.amount0, vars.amount1, vars.burned0, vars.burned1) = ISwapPair(pair).burn(\n      msg.sender,\n      liquidity,\n      // check if there are some debts which has to be repaid first\n      troveManager.getTroveRepayableDebt(msg.sender, vars.token0, false),\n      troveManager.getTroveRepayableDebt(msg.sender, vars.token1, false)\n    );\n\n    // handle trove debt repayment\n    if (vars.burned0 != 0 || vars.burned1 != 0) {\n      TokenAmount[] memory debtsToRepay;\n      if (vars.burned0 != 0 && vars.burned1 != 0) {\n        // repay both\n        debtsToRepay = new TokenAmount[](2);\n        debtsToRepay[0] = TokenAmount(vars.token0, vars.burned0);\n        debtsToRepay[1] = TokenAmount(vars.token1, vars.burned1);\n      } else {\n        // repay only 1 token\n        debtsToRepay = new TokenAmount[](1);\n        debtsToRepay[0] = (vars.burned0 != 0\n          ? TokenAmount(vars.token0, vars.burned0)\n          : TokenAmount(vars.token1, vars.burned1)\n        );\n      }\n      borrowerOperations.repayDebtFromPoolBurn(msg.sender, debtsToRepay, _upperHint, _lowerHint);\n    }\n\n    (amountA, amountB) = tokenA == vars.token0 ? (vars.amount0, vars.amount1) : (vars.amount1, vars.amount0);\n    if (amountA < amountAMin) revert InsufficientAAmount();\n    if (amountB < amountBMin) revert InsufficientBAmount();\n  }\n\n  // **** SWAP ****\n  // requires the initial amount to have already been sent to the first pair\n  // --- Swap functions ---\n\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = sortTokens(input, output);\n\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n\n      address to = i < path.length - 2 ? getPair[output][path[i + 2]] : _to;\n      ISwapPair(getPair[input][output]).swap(amount0Out, amount1Out, to);\n    }\n  }\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = getAmountsOut(amountIn, path);\n    if (amounts[amounts.length - 1] < amountOutMin) revert InsufficientOutputAmount();\n    safeTransferFrom(path[0], msg.sender, getPair[path[0]][path[1]], amounts[0]);\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = getAmountsIn(amountOut, path);\n    if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\n    safeTransferFrom(path[0], msg.sender, getPair[path[0]][path[1]], amounts[0]);\n    _swap(amounts, path, to);\n  }\n\n  function swapExactTokensForTokensWithPermit(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint[] memory amounts) {\n    IERC20Permit(path[0]).permit(msg.sender, address(this), amountIn, deadline, v, r, s);\n    return swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);\n  }\n  // --- Position functions ---\n\n  function openLongPosition(\n    uint stableToMintIn,\n    uint debtOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external override ensure(deadline) returns (uint[] memory amounts) {\n    address[] memory path = new address[](2);\n    path[0] = address(debtTokenManager.getStableCoin());\n    path[1] = debtTokenAddress;\n\n    return _openPosition(stableToMintIn, debtOutMin, path, to, _mintMeta);\n  }\n\n  function openShortPosition(\n    uint debtToMintIn,\n    uint stableOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external override ensure(deadline) returns (uint[] memory amounts) {\n    address[] memory path = new address[](2);\n    path[0] = debtTokenAddress;\n    path[1] = address(debtTokenManager.getStableCoin());\n\n    return _openPosition(debtToMintIn, stableOutMin, path, to, _mintMeta);\n  }\n\n  function _openPosition(\n    uint amountIn,\n    uint amountOutMin,\n    address[] memory path,\n    address to,\n    MintMeta memory _mintMeta\n  ) internal returns (uint[] memory amounts) {\n    address pair = getPair[path[0]][path[1]];\n    if (pair == address(0)) revert PairDoesNotExist();        \n\n    amounts = getAmountsOut(amountIn, path);\n    if (amounts[amounts.length - 1] < amountOutMin) revert InsufficientOutputAmount();\n\n    debtTokenManager.getDebtToken(path[0]); //check if debt token\n\n    // mint the debt token and transfer it to the pair\n    TokenAmount[] memory debtsToMint = new TokenAmount[](1);\n    debtsToMint[0] = TokenAmount(path[0], amounts[0]);\n    borrowerOperations.increaseDebt(msg.sender, pair, debtsToMint, _mintMeta);\n\n    // execute the swap\n    _swap(amounts, path, to);\n\n    return amounts;\n  }\n\n  // --- Helper functions ---\n\n  function getReserves(\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint reserveA, uint reserveB, uint32 swapFee) {\n    ISwapPair pair = ISwapPair(getPair[tokenA][tokenB]);\n    swapFee = pair.getSwapFee();\n\n    (uint reserve0, uint reserve1, ) = pair.getReserves();\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  function sortTokens(address tokenA, address tokenB) internal view returns (address token0, address token1) {\n    if (tokenA == tokenB) revert IdenticalAddresses();\n    if (tokenA == address(0) || tokenB == address(0)) revert ZeroAddress();\n\n    address stableCoin = address(debtTokenManager.getStableCoin());\n    if (tokenA == stableCoin) return (tokenA, tokenB);\n    if (tokenB == stableCoin) return (tokenB, tokenA);\n    return tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n  }\n\n  function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    console.log(\"success: %s\", success);\n    console.log(\"data: %s\", data.length);\n    console.log(\"data2: %s\", abi.decode(data, (bool)));\n    if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFromFailed();\n  }\n}\n"
    },
    "contracts/SwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './Dependencies/LiquityMath.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/UQ112x112.sol';\nimport './Interfaces/ISwapPair.sol';\nimport './Interfaces/ISwapOperations.sol';\nimport './Interfaces/ISwapCallee.sol';\nimport './SwapERC20.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IDebtTokenManager.sol';\n\ncontract SwapPair is ISwapPair, SwapERC20, LiquityBase {\n  using UQ112x112 for uint224;\n\n  uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n  address public operations;\n  IPriceFeed public priceFeed;\n  IDebtTokenManager public debtTokenManager;\n\n  address public token0;\n  address public token1;\n\n  uint112 private reserve0; // uses single storage slot, accessible via getReserves\n  uint112 private reserve1; // uses single storage slot, accessible via getReserves\n  uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n  uint public price0CumulativeLast;\n  uint public price1CumulativeLast;\n\n  constructor() {\n    operations = msg.sender;\n  }\n\n  // called once by the operations at time of deployment\n  function initialize(address _token0, address _token1, address _debtTokenManager, address _priceFeedAddress) external {\n    if (msg.sender != operations) revert Forbidden();\n\n    token0 = _token0;\n    token1 = _token1;\n    debtTokenManager = IDebtTokenManager(_debtTokenManager);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n  }\n\n  uint private unlocked = 1;\n  modifier lock() {\n    if (unlocked == 0) revert Locked();\n\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }\n\n  function _safeTransfer(address token, address to, uint value) private {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n\n    if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFailed();\n  }\n\n  // update reserves and, on the first call per block, price accumulators\n  function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n    if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\n\n    uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      // * never overflows, and + overflow is desired\n      price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n      price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n    }\n\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function mint(address to) external lock returns (uint liquidity) {\n    _requireCallerIsOperations();\n\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n    uint amount0 = balance0 - _reserve0;\n    uint amount1 = balance1 - _reserve1;\n\n    uint _totalSupply = totalSupply; // gas savings\n    if (_totalSupply == 0) {\n      liquidity = LiquityMath._sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n      _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = LiquityMath._min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n    }\n\n    if (liquidity == 0) revert InsufficientLiquidityMinted();\n    _mint(to, liquidity);\n    _update(balance0, balance1, _reserve0, _reserve1);\n\n    emit Mint(msg.sender, amount0, amount1);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  // directly burns debt tokens if the user has any left to repay\n  function burn(\n    address to,\n    uint liquidity,\n    uint debt0,\n    uint debt1\n  ) external lock returns (uint amount0, uint amount1, uint burned0, uint burned1) {\n    _requireCallerIsOperations();\n\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n\n    {\n      uint _totalSupply = totalSupply; // gas savings\n      amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n      amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n\n      if (amount0 == 0 || amount1 == 0) revert InsufficientLiquidityBurned();\n      _burn(to, liquidity);\n    }\n\n    // check if the user has any debts left to repay\n    burned0 = LiquityMath._min(debt0, amount0);\n    burned1 = LiquityMath._min(debt1, amount1);\n    if (burned0 != 0) IDebtToken(token0).burn(address(this), burned0);\n    if (burned1 != 0) IDebtToken(token1).burn(address(this), burned1);\n\n    // payout whats left\n    _safeTransfer(token0, to, amount0 - burned0);\n    _safeTransfer(token1, to, amount1 - burned1);\n\n    balance0 = IERC20(token0).balanceOf(address(this));\n    balance1 = IERC20(token1).balanceOf(address(this));\n    _update(balance0, balance1, _reserve0, _reserve1);\n\n    emit Burn(msg.sender, amount0, amount1, to);\n  }\n\n  // fee is returned in 1e6 (SWAP_FEE_PRECISION)\n  function getSwapFee() public view override returns (uint32 swapFee) {\n    // find stable coin\n    address nonStableCoin = token1;\n    if (!debtTokenManager.isDebtToken(nonStableCoin)) return SWAP_BASE_FEE; // no dynamic fee if the pool is not an stable/stock pool\n    if (totalSupply == 0) return SWAP_BASE_FEE; //inital mint\n\n    // query prices\n    uint oraclePrice = priceFeed.getPrice(nonStableCoin);\n    uint dexPrice = (reserve0 * DECIMAL_PRECISION) / reserve1; // todo does the token digits matter here?\n\n    if (oraclePrice < dexPrice) return SWAP_BASE_FEE;\n    uint priceRatio = (oraclePrice * DECIMAL_PRECISION) / dexPrice;\n    return uint32((priceRatio * SWAP_BASE_FEE) / DECIMAL_PRECISION); // todo missing real fee calculation\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function swap(uint amount0Out, uint amount1Out, address to) external lock {\n    _requireCallerIsOperations();\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputAmount();\n    if (amount0Out > reserve0 || amount1Out > reserve1) revert InsufficientLiquidity();\n\n    uint balance0;\n    uint balance1;\n    address _token0 = token0;\n    address _token1 = token1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      if (to == _token0 || to == _token1) revert InvalidTo();\n\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n\n    uint amount0In = balance0 > reserve0 - amount0Out ? balance0 - (reserve0 - amount0Out) : 0;\n    uint amount1In = balance1 > reserve1 - amount1Out ? balance1 - (reserve1 - amount1Out) : 0;\n    if (amount0In == 0 && amount1In == 0) revert InsufficientInputAmount();\n\n    uint32 currentSwapFee = getSwapFee();\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint balance0Adjusted = balance0 * SWAP_FEE_PRECISION - (amount0In * currentSwapFee);\n      uint balance1Adjusted = balance1 * SWAP_FEE_PRECISION - (amount1In * currentSwapFee);\n      if (balance0Adjusted * balance1Adjusted < uint(reserve0) * uint(reserve1) * (uint(SWAP_FEE_PRECISION) ** 2))\n        revert K();\n    }\n\n    // gov swap fee payment\n    if (amount0In > 0) {\n      uint amount0GovFee = (amount0In * currentSwapFee * GOV_SWAP_FEE) / (uint(SWAP_FEE_PRECISION) ** 2);\n      _safeTransfer(_token0, GOV_STAKING_ADDRESS, amount0GovFee);\n      balance0 -= amount0GovFee;\n    }\n    if (amount1In > 0) {\n      uint amount1GovFee = (amount1In * currentSwapFee * GOV_SWAP_FEE) / (uint(SWAP_FEE_PRECISION) ** 2);\n      _safeTransfer(_token1, GOV_STAKING_ADDRESS, amount1GovFee);\n      balance1 -= amount1GovFee;\n    }\n\n    _update(balance0, balance1, reserve0, reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, currentSwapFee, to);\n  }\n\n  // force balances to match reserves\n  function skim(address to) external lock {\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);\n    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);\n  }\n\n  // force reserves to match balances\n  function sync() external lock {\n    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n  }\n\n  function _requireCallerIsOperations() internal view {\n    if (msg.sender != address(operations)) revert NotFromSwapOperations();\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}