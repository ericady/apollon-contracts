{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IReservePool.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IBBase.sol';\nimport './Interfaces/ICollTokenManager.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport './Interfaces/ICollSurplusPool.sol';\n\ncontract BorrowerOperations is LiquityBase, Ownable(msg.sender), CheckContract, IBorrowerOperations {\n  string public constant NAME = 'BorrowerOperations';\n\n  // --- Connected contract declarations ---\n\n  ITroveManager public troveManager;\n  IDebtTokenManager public debtTokenManager;\n  ICollTokenManager public collTokenManager;\n  IStoragePool public storagePool;\n  IReservePool public reservePool;\n  IPriceFeed public priceFeed;\n  ISortedTroves public sortedTroves;\n  ICollSurplusPool public collSurplusPool;\n  address stabilityPoolAddress;\n  address swapOperations;\n\n  /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n  struct LocalVariables_openTrove {\n    address[] collTokenAddresses;\n    //\n    TokenAmount[] colls;\n    DebtTokenAmount[] debts;\n    uint compositeDebtInUSD;\n    uint compositeCollInUSD;\n    uint ICR;\n    uint arrayIndex;\n    //\n    bool isInRecoveryMode;\n    uint TCR;\n    uint entireSystemColl;\n    uint entireSystemDebt;\n  }\n\n  struct LocalVariables_adjustTrove {\n    address[] collTokenAddresses;\n    //\n    TokenAmount[] colls;\n    DebtTokenAmount[] debts;\n    DebtTokenAmount stableCoinEntry;\n    //\n    uint oldCompositeDebtInUSD;\n    uint oldCompositeCollInUSD;\n    uint oldICR;\n    //\n    uint newCompositeDebtInUSD;\n    uint newCompositeCollInUSD;\n    uint newICR;\n    uint remainingStableDebt;\n    //\n    bool isInRecoveryMode;\n    uint entireSystemColl;\n    uint entireSystemDebt;\n  }\n\n  struct LocalVariables_closeTrove {\n    bool isInRecoveryMode;\n    uint newTCR;\n    uint entireSystemColl;\n    uint entireSystemDebt;\n  }\n\n  struct ContractsCache {\n    ITroveManager troveManager;\n    IStoragePool storagePool;\n    IDebtTokenManager debtTokenManager;\n    ICollTokenManager collTokenManager;\n  }\n\n  // --- Dependency setters ---\n\n  function setAddresses(\n    address _troveManagerAddress,\n    address _storagePoolAddress,\n    address _stabilityPoolAddress,\n    address _reservePoolAddress,\n    address _priceFeedAddress,\n    address _debtTokenManagerAddress,\n    address _collTokenManagerAddress,\n    address _swapOperationsAddress,\n    address _sortedTrovesAddress,\n    address _collSurplusPoolAddress\n  ) external onlyOwner {\n    checkContract(_troveManagerAddress);\n    checkContract(_storagePoolAddress);\n    checkContract(_stabilityPoolAddress);\n    checkContract(_reservePoolAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManagerAddress);\n    checkContract(_collTokenManagerAddress);\n    checkContract(_swapOperationsAddress);\n    checkContract(_sortedTrovesAddress);\n    checkContract(_collSurplusPoolAddress);\n\n    troveManager = ITroveManager(_troveManagerAddress);\n    storagePool = IStoragePool(_storagePoolAddress);\n    stabilityPoolAddress = _stabilityPoolAddress;\n    reservePool = IReservePool(_reservePoolAddress);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n    debtTokenManager = IDebtTokenManager(_debtTokenManagerAddress);\n    collTokenManager = ICollTokenManager(_collTokenManagerAddress);\n    swapOperations = _swapOperationsAddress;\n    sortedTroves = ISortedTroves(_sortedTrovesAddress);\n    collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n\n    emit BorrowerOperationsInitialized(\n      _troveManagerAddress,\n      _storagePoolAddress,\n      _stabilityPoolAddress,\n      _reservePoolAddress,\n      _priceFeedAddress,\n      _debtTokenManagerAddress,\n      _collTokenManagerAddress,\n      _swapOperationsAddress,\n      _sortedTrovesAddress,\n      _collSurplusPoolAddress\n    );\n\n    renounceOwnership();\n  }\n\n  // --- Borrower Trove Operations ---\n\n  function openTrove(TokenAmount[] memory _colls) public override {\n    ContractsCache memory contractsCache = ContractsCache(\n      troveManager,\n      storagePool,\n      debtTokenManager,\n      collTokenManager\n    );\n    LocalVariables_openTrove memory vars;\n    vars.collTokenAddresses = contractsCache.collTokenManager.getCollTokenAddresses();\n    address borrower = msg.sender;\n\n    _requireTroveIsNotActive(contractsCache.troveManager, borrower);\n\n    // adding gas compensation to the net debt\n    DebtTokenAmount memory stableCoinAmount = DebtTokenAmount(\n      contractsCache.debtTokenManager.getStableCoin(),\n      STABLE_COIN_GAS_COMPENSATION,\n      0\n    );\n    vars.debts = new DebtTokenAmount[](1);\n    vars.debts[0] = stableCoinAmount;\n    // ICR is based on the composite debt, i.e. the requested debt amount + borrowing fee + debt gas comp.\n    vars.compositeDebtInUSD = _getCompositeDebt(vars.debts);\n\n    vars.colls = _colls;\n    vars.compositeCollInUSD = _getCompositeColl(vars.colls);\n\n    vars.ICR = LiquityMath._computeCR(vars.compositeCollInUSD, vars.compositeDebtInUSD);\n\n    (\n      // checking collateral ratios\n      vars.isInRecoveryMode,\n      ,\n      vars.entireSystemColl,\n      vars.entireSystemDebt\n    ) = contractsCache.storagePool.checkRecoveryMode();\n    if (vars.isInRecoveryMode) {\n      _requireICRisAboveCCR(vars.ICR); // > 150 %\n    } else {\n      _requireICRisAboveMCR(vars.ICR); // > 110 %\n\n      uint newTCR = _getNewTCRFromTroveChange(\n        vars.compositeCollInUSD,\n        true,\n        vars.compositeDebtInUSD,\n        true,\n        vars.entireSystemColl,\n        vars.entireSystemDebt\n      ); // bools: coll increase, debt increase\n      _requireNewTCRisAboveCCR(newTCR); // > 150 %\n    }\n\n    // Set the trove struct's properties\n    contractsCache.troveManager.setTroveStatus(borrower, 1); // active\n    contractsCache.troveManager.increaseTroveColl(borrower, vars.colls);\n    contractsCache.troveManager.increaseTroveDebt(borrower, vars.debts);\n    contractsCache.troveManager.updateTroveRewardSnapshots(borrower);\n    contractsCache.troveManager.updateStakeAndTotalStakes(vars.collTokenAddresses, borrower);\n\n    // just adding the trove to the general list, but not the sorted one, cause no redeemable stable debt yet\n    vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(borrower);\n\n    // Move the coll to the active pool\n    for (uint i = 0; i < vars.colls.length; i++) {\n      TokenAmount memory collTokenAmount = vars.colls[i];\n      _poolAddColl(\n        borrower,\n        contractsCache.storagePool,\n        collTokenAmount.tokenAddress,\n        collTokenAmount.amount,\n        PoolType.Active\n      );\n    }\n\n    // Move the stable coin gas compensation to the Gas Pool\n    contractsCache.storagePool.addValue(\n      address(stableCoinAmount.debtToken),\n      false,\n      PoolType.GasCompensation,\n      stableCoinAmount.netDebt\n    );\n    stableCoinAmount.debtToken.mint(address(contractsCache.storagePool), stableCoinAmount.netDebt);\n\n    emit TroveCreated(borrower, _colls);\n  }\n\n  function openTroveWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external {\n    for (uint i = 0; i < _colls.length; i++) {\n      IERC20Permit(_colls[i].tokenAddress).permit(\n        msg.sender,\n        address(this),\n        _colls[i].amount,\n        deadline,\n        v[i],\n        r[i],\n        s[i]\n      );\n    }\n    openTrove(_colls);\n  }\n\n  // Send collateral to a trove\n  function addColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) public override {\n    address borrower = msg.sender;\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(borrower);\n\n    vars.newCompositeCollInUSD += _getCompositeColl(_colls);\n    contractsCache.troveManager.increaseTroveColl(borrower, _colls);\n\n    for (uint i = 0; i < _colls.length; i++) {\n      TokenAmount memory collTokenAmount = _colls[i];\n      _poolAddColl(\n        borrower,\n        contractsCache.storagePool,\n        collTokenAmount.tokenAddress,\n        collTokenAmount.amount,\n        PoolType.Active\n      );\n    }\n\n    _finaliseTrove(false, false, contractsCache, vars, borrower, _upperHint, _lowerHint);\n  }\n\n  function addCollWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s,\n    address _upperHint,\n    address _lowerHint\n  ) external {\n    for (uint i = 0; i < _colls.length; i++) {\n      IERC20Permit(_colls[i].tokenAddress).permit(\n        msg.sender,\n        address(this),\n        _colls[i].amount,\n        deadline,\n        v[i],\n        r[i],\n        s[i]\n      );\n    }\n    addColl(_colls, _upperHint, _lowerHint);\n  }\n\n  // Withdraw collateral from a trove\n  function withdrawColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) external override {\n    address borrower = msg.sender;\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(borrower);\n\n    uint withdrawCompositeInUSD = _getCompositeColl(_colls);\n    if (withdrawCompositeInUSD > vars.newCompositeCollInUSD) revert WithdrawAmount_gt_Coll();\n    vars.newCompositeCollInUSD -= withdrawCompositeInUSD;\n\n    contractsCache.troveManager.decreaseTroveColl(borrower, _colls);\n\n    for (uint i = 0; i < _colls.length; i++) {\n      TokenAmount memory collTokenAmount = _colls[i];\n\n      // checking is the trove has enough coll for the withdrawal\n      TokenAmount memory existingColl;\n      for (uint ii = 0; ii < vars.colls.length; ii++) {\n        if (vars.colls[ii].tokenAddress != collTokenAmount.tokenAddress) continue;\n        existingColl = vars.colls[ii];\n        break;\n      }\n      assert(existingColl.amount >= collTokenAmount.amount);\n\n      _poolSubtractColl(\n        borrower,\n        contractsCache.storagePool,\n        collTokenAmount.tokenAddress,\n        collTokenAmount.amount,\n        PoolType.Active\n      );\n    }\n\n    _finaliseTrove(true, false, contractsCache, vars, borrower, _upperHint, _lowerHint);\n  }\n\n  function increaseDebt(\n    address _borrower,\n    address _to,\n    TokenAmount[] memory _debts,\n    MintMeta memory _meta\n  ) external override {\n    _requireCallerIsSwapOperations();\n    _increaseDebt(_borrower, _to, _debts, _meta);\n  }\n\n  // increasing debt off a trove\n  function _increaseDebt(address _borrower, address _to, TokenAmount[] memory _debts, MintMeta memory _meta) internal {\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(_borrower);\n\n    _requireValidMaxFeePercentage(_meta.maxFeePercentage, vars.isInRecoveryMode);\n\n    // checking if new debt is above the minimum\n    for (uint i = 0; i < _debts.length; i++) _requireNonZeroDebtChange(_debts[i].amount);\n\n    (\n      DebtTokenAmount[] memory debtsToAdd,\n      DebtTokenAmount memory stableCoinAmount\n    ) = _getDebtTokenAmountsWithFetchedPrices(contractsCache.debtTokenManager, _debts);\n\n    // adding the borrowing fee to the net debt\n    uint borrowingFeesPaid = 0;\n    if (!vars.isInRecoveryMode)\n      borrowingFeesPaid = _addBorrowingFees(\n        contractsCache.troveManager,\n        debtsToAdd,\n        stableCoinAmount,\n        _meta.maxFeePercentage\n      );\n\n    vars.newCompositeDebtInUSD += _getCompositeDebt(debtsToAdd);\n    contractsCache.troveManager.increaseTroveDebt(_borrower, debtsToAdd);\n\n    for (uint i = 0; i < debtsToAdd.length; i++) {\n      DebtTokenAmount memory debtTokenAmount = debtsToAdd[i];\n      _poolAddDebt(\n        _to,\n        contractsCache.storagePool,\n        debtTokenAmount.debtToken,\n        debtTokenAmount.netDebt,\n        debtTokenAmount.borrowingFee\n      );\n    }\n\n    vars.remainingStableDebt += stableCoinAmount.netDebt; // added stable debt (including all fees)\n    _finaliseTrove(false, true, contractsCache, vars, _borrower, _meta.upperHint, _meta.lowerHint);\n  }\n\n  // repay debt of a trove\n  function repayDebt(TokenAmount[] memory _debts, address _upperHint, address _lowerHint) external override {\n    address borrower = msg.sender;\n\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(borrower);\n    (DebtTokenAmount[] memory debtsToRemove, DebtTokenAmount memory stableCoinEntry) = _handleRepayStates(\n      contractsCache,\n      vars,\n      borrower,\n      _debts\n    );\n\n    for (uint i = 0; i < debtsToRemove.length; i++) {\n      DebtTokenAmount memory debtTokenAmount = debtsToRemove[i];\n      _poolRepayDebt(\n        borrower,\n        contractsCache.storagePool,\n        debtTokenAmount.debtToken,\n        debtTokenAmount.netDebt // it is not possible to repay the gasComp, this happens only when the trove is closed\n      );\n    }\n\n    vars.remainingStableDebt -= stableCoinEntry.netDebt;\n    _finaliseTrove(false, false, contractsCache, vars, borrower, _upperHint, _lowerHint);\n  }\n\n  // repay debt of a trove directly from swap ops after pool liquidity removal (burning)\n  // the debt tokens are directly burned from the swap ops\n  function repayDebtFromPoolBurn(\n    address borrower,\n    TokenAmount[] memory _debts,\n    address _upperHint,\n    address _lowerHint\n  ) external override {\n    _requireCallerIsSwapOperations();\n\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(borrower);\n    (DebtTokenAmount[] memory debtsToRemove, DebtTokenAmount memory stableCoinEntry) = _handleRepayStates(\n      contractsCache,\n      vars,\n      borrower,\n      _debts\n    );\n\n    for (uint i = 0; i < debtsToRemove.length; i++) {\n      DebtTokenAmount memory debtTokenAmount = debtsToRemove[i];\n      contractsCache.storagePool.subtractValue(\n        address(debtTokenAmount.debtToken),\n        false,\n        PoolType.Active,\n        debtTokenAmount.netDebt\n      );\n    }\n\n    vars.remainingStableDebt -= stableCoinEntry.netDebt;\n    _finaliseTrove(false, false, contractsCache, vars, borrower, _upperHint, _lowerHint);\n  }\n\n  function _handleRepayStates(\n    ContractsCache memory contractsCache,\n    LocalVariables_adjustTrove memory vars,\n    address borrower,\n    TokenAmount[] memory _debts\n  ) internal returns (DebtTokenAmount[] memory debtsToRemove, DebtTokenAmount memory stableCoinEntry) {\n    (debtsToRemove, stableCoinEntry) = _getDebtTokenAmountsWithFetchedPrices(contractsCache.debtTokenManager, _debts);\n    vars.newCompositeDebtInUSD -= _getCompositeDebt(debtsToRemove);\n    contractsCache.troveManager.decreaseTroveDebt(borrower, debtsToRemove);\n\n    for (uint i = 0; i < debtsToRemove.length; i++) {\n      DebtTokenAmount memory debtTokenAmount = debtsToRemove[i];      \n      address debtTokenAddress = address(debtTokenAmount.debtToken);\n\n      // check zero amount\n      if (debtTokenAmount.netDebt == 0) revert ZeroDebtRepay();\n\n      // checking if the trove has enough debt for the repayment (gas comp needs to remain)\n      DebtTokenAmount memory existingDebt;\n      for (uint ii = 0; ii < vars.debts.length; ii++) {\n        if (address(vars.debts[ii].debtToken) != debtTokenAddress) continue;\n        existingDebt = vars.debts[ii];\n        break;\n      }\n      _requireAtLeastMinNetDebt(existingDebt.netDebt, debtTokenAmount.netDebt);\n\n      if (debtTokenAmount.debtToken.isStableCoin())\n        _requireValidStableCoinRepayment(existingDebt.netDebt, debtTokenAmount.netDebt);\n    }\n\n    return (debtsToRemove, stableCoinEntry);\n  }\n\n  function closeTrove() external override {\n    address borrower = msg.sender;\n    (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) = _prepareTroveAdjustment(borrower);\n\n    _requireNotInRecoveryMode(vars.isInRecoveryMode);\n\n    uint newTCR = _getNewTCRFromTroveChange(\n      vars.oldCompositeCollInUSD,\n      false,\n      vars.oldCompositeDebtInUSD,\n      false,\n      vars.entireSystemColl,\n      vars.entireSystemDebt\n    );\n    _requireNewTCRisAboveCCR(newTCR);\n\n    // repay any open debts\n    for (uint i = 0; i < vars.debts.length; i++) {\n      DebtTokenAmount memory debtTokenAmount = vars.debts[i];\n\n      uint toRepay;\n      if (debtTokenAmount.debtToken.isStableCoin()) toRepay = debtTokenAmount.netDebt - STABLE_COIN_GAS_COMPENSATION;\n      else toRepay = debtTokenAmount.netDebt;\n      if (toRepay == 0) continue;\n\n      _poolRepayDebt(borrower, contractsCache.storagePool, debtTokenAmount.debtToken, toRepay);\n    }\n\n    // burn the gas compensation\n    _poolBurnGasComp(contractsCache.storagePool, vars.stableCoinEntry.debtToken);\n\n    // Send the collateral back to the user\n    for (uint i = 0; i < vars.colls.length; i++) {\n      TokenAmount memory collTokenAmount = vars.colls[i];\n\n      _poolSubtractColl(\n        borrower,\n        contractsCache.storagePool,\n        collTokenAmount.tokenAddress,\n        collTokenAmount.amount,\n        PoolType.Active\n      );\n    }\n\n    contractsCache.troveManager.removeStake(vars.collTokenAddresses, borrower);\n    contractsCache.troveManager.closeTroveByProtocol(vars.collTokenAddresses, borrower, Status.closedByOwner);\n  }\n\n  /**\n   * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n   */\n  function claimCollateral() external override {\n    collSurplusPool.claimColl(msg.sender);\n  }\n\n  // --- Helper functions ---\n\n  function _prepareTroveAdjustment(\n    address _borrower\n  ) internal returns (ContractsCache memory contractsCache, LocalVariables_adjustTrove memory vars) {\n    contractsCache = ContractsCache(troveManager, storagePool, debtTokenManager, collTokenManager);\n    vars.collTokenAddresses = contractsCache.collTokenManager.getCollTokenAddresses();\n\n    (vars.isInRecoveryMode, , vars.entireSystemColl, vars.entireSystemDebt) = contractsCache\n      .storagePool\n      .checkRecoveryMode();\n\n    _requireTroveisActive(contractsCache.troveManager, _borrower);\n    contractsCache.troveManager.applyPendingRewards(_borrower); // from redistributions\n\n    // fetching old/current debts and colls including prices + calc ICR\n    (vars.debts, vars.stableCoinEntry) = _getDebtTokenAmountsWithFetchedPrices(\n      contractsCache.debtTokenManager,\n      contractsCache.troveManager.getTroveDebt(_borrower)\n    );\n    vars.remainingStableDebt = vars.stableCoinEntry.netDebt;\n    vars.oldCompositeDebtInUSD = _getCompositeDebt(vars.debts);\n    vars.newCompositeDebtInUSD = vars.oldCompositeDebtInUSD;\n\n    vars.colls = contractsCache.troveManager.getTroveColl(_borrower);\n    vars.oldCompositeCollInUSD = _getCompositeColl(vars.colls);\n    vars.newCompositeCollInUSD = vars.oldCompositeCollInUSD;\n\n    vars.oldICR = LiquityMath._computeCR(vars.oldCompositeCollInUSD, vars.oldCompositeDebtInUSD);\n\n    return (contractsCache, vars);\n  }\n\n  function _finaliseTrove(\n    bool _isCollWithdrawal,\n    bool _isDebtIncrease,\n    ContractsCache memory contractsCache,\n    LocalVariables_adjustTrove memory vars,\n    address _borrower,\n    address _upperHint,\n    address _lowerHint\n  ) internal {\n    // calculate the new ICR\n    vars.newICR = LiquityMath._computeCR(vars.newCompositeCollInUSD, vars.newCompositeDebtInUSD);\n\n    // Check the adjustment satisfies all conditions for the current system mode\n    _requireValidAdjustmentInCurrentMode(_isCollWithdrawal, _isDebtIncrease, vars);\n\n    // update troves stake\n    contractsCache.troveManager.updateStakeAndTotalStakes(vars.collTokenAddresses, _borrower);\n\n    // update the troves list position\n    sortedTroves.update(\n      _borrower,\n      vars.newICR,\n      vars.remainingStableDebt - STABLE_COIN_GAS_COMPENSATION,\n      _upperHint,\n      _lowerHint\n    );\n  }\n\n  function _getNewTCRFromTroveChange(\n    uint _collChange,\n    bool _isCollIncrease,\n    uint _debtChange,\n    bool _isDebtIncrease,\n    uint entireSystemColl,\n    uint entireSystemDebt\n  ) internal pure returns (uint) {\n    uint totalColl = _isCollIncrease ? entireSystemColl + _collChange : entireSystemColl - _collChange;\n    uint totalDebt = _isDebtIncrease ? entireSystemDebt + _debtChange : entireSystemDebt - _debtChange;\n\n    uint newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n    return newTCR;\n  }\n\n  function _addBorrowingFees(\n    ITroveManager _troveManager,\n    DebtTokenAmount[] memory _debts,\n    DebtTokenAmount memory _stableCoinAmount,\n    uint _maxFeePercentage\n  ) internal returns (uint borrowingFee) {\n    _troveManager.decayStableCoinBaseRateFromBorrowing(_stableCoinAmount.netDebt); // decay the baseRate state variable\n\n    uint compositeDebtInUSD = _getCompositeDebt(_debts);\n    uint stableCoinDebtInUSE = priceFeed.getUSDValue(address(_stableCoinAmount.debtToken), _stableCoinAmount.netDebt);\n    borrowingFee =\n      _troveManager.getBorrowingFee(compositeDebtInUSD - stableCoinDebtInUSE, false) +\n      _troveManager.getBorrowingFee(stableCoinDebtInUSE, true);\n    _requireUserAcceptsFee(borrowingFee, compositeDebtInUSD, _maxFeePercentage);\n\n    // update troves debts\n    uint stableCoinPrice = _stableCoinAmount.debtToken.getPrice();\n    borrowingFee = (borrowingFee * DECIMAL_PRECISION) / stableCoinPrice;\n    _stableCoinAmount.netDebt += borrowingFee;\n    _stableCoinAmount.borrowingFee += borrowingFee;\n    return borrowingFee;\n  }\n\n  function _poolAddColl(\n    address _borrower,\n    IStoragePool _pool,\n    address _collAddress,\n    uint _amount,\n    PoolType _poolType\n  ) internal {\n    _pool.addValue(_collAddress, true, _poolType, _amount);\n    IERC20(_collAddress).transferFrom(_borrower, address(_pool), _amount);\n  }\n\n  function _poolSubtractColl(\n    address _borrower,\n    IStoragePool _pool,\n    address _collAddress,\n    uint _amount,\n    PoolType _poolType\n  ) internal {\n    _pool.withdrawalValue(_borrower, _collAddress, true, _poolType, _amount);\n  }\n\n  function _poolAddDebt(\n    address _tokenRecipient,\n    IStoragePool _storagePool,\n    IDebtToken _debtToken,\n    uint _netDebtIncrease,\n    uint _borrowingFee\n  ) internal {\n    _storagePool.addValue(address(_debtToken), false, PoolType.Active, _netDebtIncrease);\n\n    // payout issued debt to the recipient\n    uint mintAmount = _netDebtIncrease - _borrowingFee;\n    if (mintAmount > 0) _debtToken.mint(_tokenRecipient, mintAmount);\n\n    if (_borrowingFee == 0) return;\n\n    // forward the borrowing fee to the reserve pool (or gov staking)\n    uint govStakingPayout = _borrowingFee;\n    uint missingStableForReserveCap = reservePool.stableAmountUntilCap();\n    if (missingStableForReserveCap > 0) {\n      uint reserveTransfer = LiquityMath._min(_borrowingFee, missingStableForReserveCap);\n      govStakingPayout -= reserveTransfer;\n\n      _debtToken.mint(address(reservePool), reserveTransfer);\n    }\n    if (govStakingPayout > 0) _debtToken.mint(GOV_STAKING_ADDRESS, govStakingPayout);\n    emit PaidBorrowingFee(_tokenRecipient, _borrowingFee);\n  }\n\n  function _poolRepayDebt(\n    address _borrower,\n    IStoragePool _storagePool,\n    IDebtToken _debtToken,\n    uint _repayAmount\n  ) internal {\n    _requireSufficientDebtBalance(_debtToken, _borrower, _repayAmount);\n    _storagePool.subtractValue(address(_debtToken), false, PoolType.Active, _repayAmount);\n    _debtToken.burn(_borrower, _repayAmount);\n  }\n\n  function _poolBurnGasComp(IStoragePool _storagePool, IDebtToken _stableCoin) internal {\n    _storagePool.subtractValue(address(_stableCoin), false, PoolType.GasCompensation, STABLE_COIN_GAS_COMPENSATION);\n    _stableCoin.burn(address(_storagePool), STABLE_COIN_GAS_COMPENSATION);\n  }\n\n  // --- 'Require' wrapper functions ---\n\n  function _requireCallerIsSwapOperations() internal view {\n    if (msg.sender != swapOperations) revert NotFromSwapOps();\n  }\n\n  function _requireCallerIsBorrower(address _borrower) internal view {\n    if (msg.sender != _borrower) revert NotBorrower();\n  }\n\n  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n    uint status = _troveManager.getTroveStatus(_borrower);\n    if (status != 1) revert TroveClosedOrNotExist();\n  }\n\n  function _requireNotInRecoveryMode(bool _isInRecoveryMode) internal pure {\n    if (_isInRecoveryMode) revert NotAllowedInRecoveryMode();\n  }\n\n  function _requireTroveIsNotActive(ITroveManager _troveManager, address _borrower) internal view {\n    uint status = _troveManager.getTroveStatus(_borrower);\n    if (status == 1) revert ActiveTrove();\n  }\n\n  function _requireSufficientDebtBalance(IDebtToken _debtToken, address _borrower, uint _debtRepayment) internal view {\n    if (_debtToken.balanceOf(_borrower) < _debtRepayment) revert InsufficientDebtToRepay();\n  }\n\n  // adds stableCoin debt including gas compensation if not already included\n  function _getDebtTokenAmountsWithFetchedPrices(\n    IDebtTokenManager _dTokenManager,\n    TokenAmount[] memory _debts\n  ) internal view returns (DebtTokenAmount[] memory debtTokenAmounts, DebtTokenAmount memory stableCoinEntry) {\n    address stableCoinAddress = address(_dTokenManager.getStableCoin());\n\n    bool stableCoinIncluded = false;\n    for (uint i = 0; i < _debts.length; i++) {\n      if (_debts[i].tokenAddress != stableCoinAddress) continue;\n\n      stableCoinIncluded = true;\n      break;\n    }\n\n    if (stableCoinIncluded) debtTokenAmounts = new DebtTokenAmount[](_debts.length);\n    else debtTokenAmounts = new DebtTokenAmount[](_debts.length + 1);\n\n    for (uint i = 0; i < _debts.length; i++) {\n      IDebtToken debtToken = _dTokenManager.getDebtToken(_debts[i].tokenAddress);\n      debtTokenAmounts[i] = DebtTokenAmount(debtToken, _debts[i].amount, 0);\n\n      if (stableCoinIncluded && debtToken.isStableCoin()) stableCoinEntry = debtTokenAmounts[i];\n    }\n\n    if (!stableCoinIncluded) {\n      IDebtToken debtToken = _dTokenManager.getStableCoin();\n      debtTokenAmounts[_debts.length] = DebtTokenAmount(debtToken, 0, 0);\n      stableCoinEntry = debtTokenAmounts[_debts.length];\n    }\n\n    return (debtTokenAmounts, stableCoinEntry);\n  }\n\n  function _requireNonZeroDebtChange(uint _change) internal pure {\n    if (_change == 0) revert ZeroDebtChange();\n  }\n\n  function _requireValidAdjustmentInCurrentMode(\n    bool _isCollWithdrawal,\n    bool _isDebtIncrease,\n    LocalVariables_adjustTrove memory _vars\n  ) internal pure {\n    /*\n     *In Recovery Mode, only allow:\n     *\n     * - Pure collateral top-up\n     * - Pure debt repayment\n     * - Collateral top-up with debt repayment\n     * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n     *\n     * In Normal Mode, ensure:\n     *\n     * - The new ICR is above MCR\n     * - The adjustment won't pull the TCR below CCR\n     */\n    if (_vars.isInRecoveryMode) {\n      // BorrowerOps: Collateral withdrawal not permitted Recovery Mode\n      if (_isCollWithdrawal) revert CollWithdrawPermittedInRM();\n      if (_isDebtIncrease) _requireICRisAboveCCR(_vars.newICR);\n    } else {\n      // if Normal Mode\n      _requireICRisAboveMCR(_vars.newICR);\n\n      uint collChange = _vars.newCompositeCollInUSD > _vars.oldCompositeCollInUSD\n        ? _vars.newCompositeCollInUSD - _vars.oldCompositeCollInUSD\n        : _vars.oldCompositeCollInUSD - _vars.newCompositeCollInUSD;\n      uint debtChange = _vars.newCompositeDebtInUSD > _vars.oldCompositeDebtInUSD\n        ? _vars.newCompositeDebtInUSD - _vars.oldCompositeDebtInUSD\n        : _vars.oldCompositeDebtInUSD - _vars.newCompositeDebtInUSD;\n      uint newTCR = _getNewTCRFromTroveChange(\n        collChange,\n        !_isCollWithdrawal,\n        debtChange,\n        _isDebtIncrease,\n        _vars.entireSystemColl,\n        _vars.entireSystemDebt\n      );\n      _requireNewTCRisAboveCCR(newTCR);\n    }\n  }\n\n  function _requireICRisAboveMCR(uint _newICR) internal pure {\n    // BorrowerOps: An operation that would result in ICR < MCR is not permitted\n    if (_newICR < MCR) revert ICR_lt_MCR();\n  }\n\n  function _requireICRisAboveCCR(uint _newICR) internal pure {\n    // BorrowerOps: Operation must leave trove with ICR >= CCR\n    if (_newICR < CCR) revert ICR_lt_CCR();\n  }\n\n  function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n    // BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\n    if (_newICR < _oldICR) revert ICRDecreasedInRM();\n  }\n\n  function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n    // BorrowerOps: An operation that would result in TCR < CCR is not permitted\n    if (_newTCR < CCR) revert TCR_lt_CCR();\n  }\n\n  function _requireAtLeastMinNetDebt(uint _netDebt, uint _repayment) internal pure {\n    if (_netDebt < _repayment) revert Repaid_gt_CurrentDebt();\n  }\n\n  function _requireValidStableCoinRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n    // BorrowerOps: Amount repaid must not be larger than the Trove's debt\n    if (_debtRepayment > (_currentDebt - STABLE_COIN_GAS_COMPENSATION)) revert Repaid_gt_CurrentDebt();\n  }\n\n  function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isInRecoveryMode) internal pure {\n    if (_isInRecoveryMode) {\n      if (_maxFeePercentage > MAX_BORROWING_FEE) revert MaxFee_gt_100_InRM();\n    } else {\n      if (_maxFeePercentage < BORROWING_FEE_FLOOR || _maxFeePercentage > MAX_BORROWING_FEE) revert MaxFee_out_Range();\n    }\n  }\n\n  // --- ICR and TCR getters ---\n\n  function getCompositeDebt(DebtTokenAmount[] memory _debts) external view override returns (uint) {\n    return _getCompositeDebt(_debts);\n  }\n\n  function _getNetDebt(DebtTokenAmount[] memory _debts) internal view returns (uint) {\n    return _getCompositeDebt(_debts) - STABLE_COIN_GAS_COMPENSATION;\n  }\n\n  // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n  function _getCompositeDebt(DebtTokenAmount[] memory _debts) internal view returns (uint debtInUSD) {\n    for (uint i = 0; i < _debts.length; i++)\n      debtInUSD += priceFeed.getUSDValue(address(_debts[i].debtToken), _debts[i].netDebt);\n  }\n\n  function _getCompositeColl(TokenAmount[] memory _colls) internal view returns (uint collInUSD) {\n    for (uint i = 0; i < _colls.length; i++)\n      collInUSD += priceFeed.getUSDValue(_colls[i].tokenAddress, _colls[i].amount);\n  }\n}\n"
    },
    "contracts/CollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ICollSurplusPool.sol';\nimport './Dependencies/LiquityBase.sol';\n\ncontract CollSurplusPool is LiquityBase, Ownable(msg.sender), CheckContract, ICollSurplusPool {\n  string public constant NAME = 'CollSurplusPool';\n\n  address public liquidationOperationsAddress;\n  address public borrowerOperationsAddress;\n\n  mapping(address => TokenAmount[]) internal balances; // Collateral surplus claimable by trove owners\n\n  // --- Contract setters ---\n\n  function setAddresses(address _liquidationOperationsAddress, address _borrowerOperationsAddress) external onlyOwner {\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_liquidationOperationsAddress);\n\n    borrowerOperationsAddress = _borrowerOperationsAddress;\n    liquidationOperationsAddress = _liquidationOperationsAddress;\n\n    emit CollSurplusPoolInitialized(_liquidationOperationsAddress, _borrowerOperationsAddress);\n\n    renounceOwnership();\n  }\n\n  function getCollateral(address _account) external view override returns (TokenAmount[] memory) {\n    return balances[_account];\n  }\n\n  // --- Pool functionality ---\n\n  function accountSurplus(address _account, RAmount[] memory _collSurplus) external override {\n    _requireCallerIsProtocol();\n\n    TokenAmount[] storage accountBalances = balances[_account];\n    for (uint i = 0; i < _collSurplus.length; i++) {\n      RAmount memory rAmount = _collSurplus[i];\n      if (rAmount.collSurplus == 0) continue;\n\n      bool inserted = false;\n      for (uint a = 0; a < accountBalances.length; a++) {\n        if (accountBalances[a].tokenAddress != rAmount.tokenAddress) continue;\n\n        accountBalances[a].amount += rAmount.collSurplus;\n        inserted = true;\n        break;\n      }\n\n      if (!inserted) accountBalances.push(TokenAmount(rAmount.tokenAddress, rAmount.collSurplus));\n    }\n\n    emit CollBalanceUpdated(_account, accountBalances);\n  }\n\n  function claimColl(address _account) external override {\n    _requireCallerIsProtocol();\n\n    TokenAmount[] memory accountBalances = balances[_account];\n    for (uint i = 0; i < accountBalances.length; i++) {\n      TokenAmount memory tokenEntry = accountBalances[i];\n      if (tokenEntry.amount == 0) continue;\n      IERC20(tokenEntry.tokenAddress).transfer(_account, tokenEntry.amount);\n    }\n\n    delete balances[_account];\n    emit CollClaimed(_account);\n  }\n\n  // --- 'require' functions ---\n\n  function _requireCallerIsProtocol() internal view {\n    if (msg.sender != liquidationOperationsAddress && msg.sender != borrowerOperationsAddress) revert NotFromProtocol();\n  }\n}\n"
    },
    "contracts/CollTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ICollTokenManager.sol';\n\ncontract CollTokenManager is Ownable(msg.sender), CheckContract, ICollTokenManager {\n  string public constant NAME = 'CollTokenManager';\n\n  address public priceFeedAddress;\n\n  // --- Data structures ---\n\n  address[] public collTokenAddresses;\n\n  // --- Dependency setter ---\n\n  function setAddresses(address _priceFeedAddress) external onlyOwner {\n    checkContract(_priceFeedAddress);\n    priceFeedAddress = _priceFeedAddress;\n    emit CollTokenManagerInitialized(_priceFeedAddress);\n  }\n\n  // --- Getters ---\n\n  function getCollTokenAddresses() external view override returns (address[] memory) {\n    return collTokenAddresses;\n  }\n\n  // --- Setters ---\n\n  // todo oracle id/linking missing\n  function addCollToken(address _tokenAddress) external override onlyOwner {\n    for (uint i = 0; i < collTokenAddresses.length; i++)\n      if (collTokenAddresses[i] == _tokenAddress) revert TokenAlreadyAdded();\n\n    collTokenAddresses.push(_tokenAddress);\n    emit CollTokenAdded(_tokenAddress);\n  }\n}\n"
    },
    "contracts/DebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IDebtTokenManager.sol';\n\n/*\n *\n * Based upon OpenZeppelin's ERC20 contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n *\n * and their EIP2612 (ERC20Permit / ERC712) functionality:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n *\n *\n * --- Functionality added specific to the DToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending dToken directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool(): functions callable only Liquity core contracts, which move dTokens between Liquity <-> user.\n */\n\ncontract DebtToken is CheckContract, IDebtToken {\n  uint256 private _totalSupply;\n  string internal _NAME;\n  string internal _SYMBOL;\n  string internal _VERSION;\n  uint8 internal constant _DECIMALS = 18;\n  bool internal immutable _IS_STABLE_COIN;\n\n  // --- Data for EIP2612 ---\n\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n  // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n  bytes32 private constant _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n  uint256 private immutable _CACHED_CHAIN_ID;\n\n  bytes32 private immutable _HASHED_NAME;\n  bytes32 private immutable _HASHED_VERSION;\n\n  mapping(address => uint256) private _nonces;\n\n  // User data for dToken\n  mapping(address => uint256) private _balances;\n  // sender => spender => amount\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  // --- Addresses ---\n  address public immutable troveManagerAddress;\n  address public immutable redemptionOperationsAddress;\n  address public immutable borrowerOperationsAddress;\n  address public immutable stabilityPoolManagerAddress;\n  address public immutable debtTokenManagerAddress;\n  IPriceFeed public immutable priceFeed;\n\n  constructor(\n    address _troveManagerAddress,\n    address _redemptionOperationsAddress,\n    address _borrowerOperationsAddress,\n    address _stabilityPoolManagerAddress,\n    address _debtTokenManagerAddress,\n    address _priceFeedAddress,    \n    string memory _symbol,\n    string memory _name,\n    string memory _version,\n    bool _isStableCoin\n  ) {\n    checkContract(_troveManagerAddress);\n    checkContract(_redemptionOperationsAddress);\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_stabilityPoolManagerAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManagerAddress);\n\n    troveManagerAddress = _troveManagerAddress;\n    redemptionOperationsAddress = _redemptionOperationsAddress;\n    borrowerOperationsAddress = _borrowerOperationsAddress;\n    stabilityPoolManagerAddress = _stabilityPoolManagerAddress;\n    debtTokenManagerAddress = _debtTokenManagerAddress;\n    priceFeed = IPriceFeed(_priceFeedAddress);    \n\n    _NAME = _name;\n    _SYMBOL = _symbol;\n    _VERSION = _version;\n    _IS_STABLE_COIN = _isStableCoin;\n\n    bytes32 hashedName = keccak256(bytes(_NAME));\n    bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = _chainID();\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n  }\n\n  // --- Functions for intra-Liquity calls ---\n\n  function isStableCoin() external view override returns (bool) {\n    return _IS_STABLE_COIN;\n  }\n\n  function getPrice() external view override returns (uint) {\n    return priceFeed.getPrice(address(this));\n  }\n\n  function mint(address _account, uint256 _amount) external override {\n    _requireCallerIsBorrowerOperations();\n    _mint(_account, _amount);\n  }\n\n  function burn(address _account, uint256 _amount) external override {\n    _requireCallerIsBOorTroveMorSPorROorDebtToken();\n    _burn(_account, _amount);\n  }\n\n  function sendToPool(address _sender, address _poolAddress, uint256 _amount) external override {\n    // FIXME: This doesnt guarantee that receiver is really a pool\n    _requireCallerIsStabilityPoolManager();\n    _transfer(_sender, _poolAddress, _amount);\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    _requireValidRecipient(recipient);\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n    _requireValidRecipient(recipient);\n    _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n    _transfer(sender, recipient, amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n    return true;\n  }\n\n  // --- EIP 2612 Functionality ---\n\n  function domainSeparator() external view override returns (bytes32) {\n    if (_chainID() == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint amount,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    if (deadline < block.timestamp) revert ExpiredDeadline();\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        this.domainSeparator(),\n        keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner]++, deadline))\n      )\n    );\n\n    bytes32 signedMsg = MessageHashUtils.toEthSignedMessageHash(digest);\n    address recoveredAddress = ECDSA.recover(signedMsg, v, r, s);\n    if (recoveredAddress != owner) revert InvalidSignature();\n    _approve(owner, spender, amount);\n  }\n\n  function nonces(address owner) external view override returns (uint256) {\n    // FOR EIP 2612\n    return _nonces[owner];\n  }\n\n  // --- Internal operations ---\n\n  function _chainID() private view returns (uint256 chainID) {\n    assembly {\n      chainID := chainid()\n    }\n  }\n\n  function _buildDomainSeparator(bytes32 typeHash, bytes32 newName, bytes32 newVersion) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, newName, newVersion, _chainID(), address(this)));\n  }\n\n  // --- Internal operations ---\n  // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    assert(sender != address(0));\n    if (_balances[sender] < amount) revert InsufficientBalance();\n\n    _balances[sender] -= amount;\n    _balances[recipient] += amount;\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal {\n    assert(account != address(0));\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    assert(account != address(0));\n\n    _balances[account] -= amount;\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    assert(owner != address(0));\n    assert(spender != address(0));\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  // --- 'require' functions ---\n\n  function _requireValidRecipient(address _recipient) internal view {\n    // FIXME: _recipient != address(0) is already asserted on all _transfer calls; exclude check in either of them\n    if (_recipient == address(0) || _recipient == address(this)) revert ZeroAddress();\n    if (\n      _recipient == stabilityPoolManagerAddress ||\n      _recipient == troveManagerAddress ||\n      _recipient == borrowerOperationsAddress\n    ) revert NotAllowedDirectTransfer();\n  }\n\n  function _requireCallerIsBorrowerOperations() internal view {\n    if (msg.sender != borrowerOperationsAddress) revert NotFromBorrowerOps();\n  }\n\n  function _requireCallerIsBOorTroveMorSPorROorDebtToken() internal view {\n    if (\n      msg.sender != borrowerOperationsAddress &&\n      msg.sender != troveManagerAddress &&\n      msg.sender != stabilityPoolManagerAddress &&\n      msg.sender != redemptionOperationsAddress && \n      !IDebtTokenManager(debtTokenManagerAddress).isDebtToken(address(this))\n    ) revert NotFromBOorTroveMorSPorDebtToken();\n  }\n\n  function _requireCallerIsStabilityPoolManager() internal view {\n    if (msg.sender != stabilityPoolManagerAddress) revert NotFromSPManager();\n  }\n\n  // --- Optional functions ---\n\n  // FIXME: Use auto-generated getters from Solidity instead. Gas cost is nearly identical but the scope would be clearer that these arguments are indeed not internal/private but PUBLIC\n  // Make all below variable \"public\" and access like \"name()\"\n  function name() external view override returns (string memory) {\n    return _NAME;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return _SYMBOL;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return _DECIMALS;\n  }\n\n  function version() external view override returns (string memory) {\n    return _VERSION;\n  }\n\n  function permitTypeHash() external pure override returns (bytes32) {\n    return _PERMIT_TYPEHASH;\n  }\n}\n"
    },
    "contracts/DebtTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './DebtToken.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\n\ncontract DebtTokenManager is Ownable(msg.sender), CheckContract, IDebtTokenManager {\n  string public constant NAME = 'DTokenManager';\n\n  IStabilityPoolManager public stabilityPoolManager;\n\n  // --- Data structures ---\n\n  mapping(address => IDebtToken) public debtTokens;\n  IDebtToken[] public debtTokensArray;\n  address[] public debtTokenAddresses;\n  IDebtToken public stableCoin;\n\n  // --- Dependency setter ---\n\n  function setAddresses(address _stabilityPoolManagerAddress) external onlyOwner {\n    checkContract(_stabilityPoolManagerAddress);\n    stabilityPoolManager = IStabilityPoolManager(_stabilityPoolManagerAddress);\n    emit DebtTokenManagerInitialized(_stabilityPoolManagerAddress);\n  }\n\n  // --- Getters ---\n\n  function getStableCoin() external view override returns (IDebtToken) {\n    return stableCoin;\n  }\n\n  function isDebtToken(address _address) external view override returns (bool) {\n    return address(debtTokens[_address]) != address(0);\n  }\n\n  function getDebtToken(address _address) external view override returns (IDebtToken debtToken) {\n    debtToken = debtTokens[_address];\n    if (address(debtToken) == address(0)) revert InvalidDebtToken();\n    return debtToken;\n  }\n\n  function getDebtTokenAddresses() external view override returns (address[] memory) {\n    return debtTokenAddresses;\n  }\n\n  // --- Setters ---\n\n  // todo price oracle id/linking missing...\n  function addDebtToken(address _debtTokenAddress) external override onlyOwner {\n    checkContract(_debtTokenAddress);\n\n    IDebtToken debtToken = IDebtToken(_debtTokenAddress);\n    bool isStableCoin = debtToken.isStableCoin();\n    if (isStableCoin && address(stableCoin) != address(0)) revert StableCoinAlreadyExists();\n\n    string memory symbol = debtToken.symbol();\n    for (uint i = 0; i < debtTokensArray.length; i++) {\n      if (keccak256(bytes(debtTokensArray[i].symbol())) != keccak256(bytes(symbol))) continue;\n      revert SymbolAlreadyExists();\n    }\n\n    debtTokenAddresses.push(_debtTokenAddress);\n    debtTokens[_debtTokenAddress] = debtToken;\n    if (isStableCoin) stableCoin = debtToken;\n\n    stabilityPoolManager.addStabilityPool(debtToken);\n\n    emit DebtTokenAdded(_debtTokenAddress);\n  }\n}\n"
    },
    "contracts/Dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\ncontract CheckContract {\n  using Address for address;\n\n  error ZeroAddress();\n  error NotContract();\n\n  /**\n   * Check that the account is an already deployed non-destroyed contract.\n   * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\n   */\n  function checkContract(address _account) internal view {\n    if (_account == address(0)) revert ZeroAddress();\n\n    uint256 size;\n    assembly {\n      size := extcodesize(_account)\n    }\n    if (size == 0) revert NotContract();\n  }\n}\n"
    },
    "contracts/Dependencies/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n *\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n   * given `owner`'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases `owner`'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   *\n   * `owner` can limit the time a Permit is valid for by setting `deadline` to\n   * a value in the near future. The deadline argument can be set to uint(-1) to\n   * create Permits that effectively never expire.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function permitTypeHash() external view returns (bytes32);\n\n  function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/Dependencies/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ITellor {\n  /**\n   * @dev Helps initialize a dispute by assigning it a disputeId\n   * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n   * invalidated value information to POS voting\n   * @param _requestId being disputed\n   * @param _timestamp being disputed\n   * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n   * requires 5 miners to submit a value.\n   */\n  function beginDispute(uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) external;\n\n  /**\n   * @dev Allows token holders to vote\n   * @param _disputeId is the dispute id\n   * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n   */\n  function vote(uint256 _disputeId, bool _supportsDispute) external;\n\n  /**\n   * @dev tallies the votes.\n   * @param _disputeId is the dispute id\n   */\n  function tallyVotes(uint256 _disputeId) external;\n\n  /**\n   * @dev Allows for a fork to be proposed\n   * @param _propNewTellorAddress address for new proposed Tellor\n   */\n  function proposeFork(address _propNewTellorAddress) external;\n\n  /**\n   * @dev Add tip to Request value from oracle\n   * @param _requestId being requested to be mined\n   * @param _tip amount the requester is willing to pay to be get on queue. Miners\n   * mine the onDeckQueryHash, or the api with the highest payout pool\n   */\n  function addTip(uint256 _requestId, uint256 _tip) external;\n\n  /**\n   * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n   * @param _nonce uint submitted by miner\n   * @param _requestId the apiId being mined\n   * @param _value of api query\n   *\n   */\n  function submitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external;\n\n  /**\n   * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n   * @param _nonce uint submitted by miner\n   * @param _requestId is the array of the 5 PSR's being mined\n   * @param _value is an array of 5 values\n   */\n  function submitMiningSolution(\n    string calldata _nonce,\n    uint256[5] calldata _requestId,\n    uint256[5] calldata _value\n  ) external;\n\n  /**\n   * @dev Allows the current owner to propose transfer control of the contract to a\n   * newOwner and the ownership is pending until the new owner calls the claimOwnership\n   * function\n   * @param _pendingOwner The address to transfer ownership to.\n   */\n  function proposeOwnership(address payable _pendingOwner) external;\n\n  /**\n   * @dev Allows the new owner to claim control of the contract\n   */\n  function claimOwnership() external;\n\n  /**\n   * @dev This function allows miners to deposit their stake.\n   */\n  function depositStake() external;\n\n  /**\n   * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n   * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n   * can withdraw the stake\n   */\n  function requestStakingWithdraw() external;\n\n  /**\n   * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n   */\n  function withdrawStake() external;\n\n  /**\n   * @dev This function approves a _spender an _amount of tokens to use\n   * @param _spender address\n   * @param _amount amount the spender is being approved for\n   * @return true if spender appproved successfully\n   */\n  function approve(address _spender, uint256 _amount) external returns (bool);\n\n  /**\n   * @dev Allows for a transfer of tokens to _to\n   * @param _to The address to send tokens to\n   * @param _amount The amount of tokens to send\n   * @return true if transfer is successful\n   */\n  function transfer(address _to, uint256 _amount) external returns (bool);\n\n  /**\n   * @dev Sends _amount tokens to _to from _from on the condition it\n   * is approved by _from\n   * @param _from The address holding the tokens being transferred\n   * @param _to The address of the recipient\n   * @param _amount The amount of tokens to be transferred\n   * @return True if the transfer was successful\n   */\n  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n\n  /**\n   * @dev Allows users to access the token's name\n   */\n  function name() external pure returns (string memory);\n\n  /**\n   * @dev Allows users to access the token's symbol\n   */\n  function symbol() external pure returns (string memory);\n\n  /**\n   * @dev Allows users to access the number of decimals\n   */\n  function decimals() external pure returns (uint8);\n\n  /**\n   * @dev Getter for the current variables that include the 5 requests Id's\n   * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip\n   */\n  function getNewCurrentVariables()\n    external\n    view\n    returns (bytes32 _challenge, uint256[5] memory _requestIds, uint256 _difficutly, uint256 _tip);\n\n  /**\n   * @dev Getter for the top tipped 5 requests Id's\n   * @return _requestIds the 5 requestsId\n   */\n  function getTopRequestIDs() external view returns (uint256[5] memory _requestIds);\n\n  /**\n   * @dev Getter for the 5 requests Id's next in line to get mined\n   * @return idsOnDeck tipsOnDeck  the 5 requestsId\n   */\n  function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\n\n  /**\n   * @dev Updates the Tellor address after a proposed fork has\n   * passed the vote and day has gone by without a dispute\n   * @param _disputeId the disputeId for the proposed fork\n   */\n  function updateTellor(uint256 _disputeId) external;\n\n  /**\n   * @dev Allows disputer to unlock the dispute fee\n   * @param _disputeId to unlock fee from\n   */\n  function unlockDisputeFee(uint256 _disputeId) external;\n\n  /**\n   * @param _user address\n   * @param _spender address\n   * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n   */\n  function allowance(address _user, address _spender) external view returns (uint256);\n\n  /**\n   * @dev This function returns whether or not a given user is allowed to trade a given amount\n   * @param _user address\n   * @param _amount uint of amount\n   * @return true if the user is alloed to trade the amount specified\n   */\n  function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\n\n  /**\n   * @dev Gets balance of owner specified\n   * @param _user is the owner address used to look up the balance\n   * @return Returns the balance associated with the passed in _user\n   */\n  function balanceOf(address _user) external view returns (uint256);\n\n  /**\n   * @dev Queries the balance of _user at a specific _blockNumber\n   * @param _user The address from which the balance will be retrieved\n   * @param _blockNumber The block number when the balance is queried\n   * @return The balance at _blockNumber\n   */\n  function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256);\n\n  /**\n   * @dev This function tells you if a given challenge has been completed by a given miner\n   * @param _challenge the challenge to search for\n   * @param _miner address that you want to know if they solved the challenge\n   * @return true if the _miner address provided solved the\n   */\n  function didMine(bytes32 _challenge, address _miner) external view returns (bool);\n\n  /**\n   * @dev Checks if an address voted in a given dispute\n   * @param _disputeId to look up\n   * @param _address to look up\n   * @return bool of whether or not party voted\n   */\n  function didVote(uint256 _disputeId, address _address) external view returns (bool);\n\n  /**\n   * @dev allows Tellor to read data from the addressVars mapping\n   * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\n   * These are examples of how the variables are saved within other functions:\n   * addressVars[keccak256(\"_owner\")]\n   * addressVars[keccak256(\"tellorContract\")]\n   * return address\n   */\n  function getAddressVars(bytes32 _data) external view returns (address);\n\n  /**\n   * @dev Gets all dispute variables\n   * @param _disputeId to look up\n   * @return bytes32 hash of dispute\n   * @return bool executed where true if it has been voted on\n   * @return bool disputeVotePassed\n   * @return bool isPropFork true if the dispute is a proposed fork\n   * @return address of reportedMiner\n   * @return address of reportingParty\n   * @return address of proposedForkAddress\n   *    uint of requestId\n   *    uint of timestamp\n   *    uint of value\n   *    uint of minExecutionDate\n   *    uint of numberOfVotes\n   *    uint of blocknumber\n   *    uint of minerSlot\n   *    uint of quorum\n   *    uint of fee\n   * @return int count of the current tally\n   */\n  function getAllDisputeVars(\n    uint256 _disputeId\n  ) external view returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256);\n\n  /**\n   * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n   * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n   */\n  function getCurrentVariables() external view returns (bytes32, uint256, uint256, string memory, uint256, uint256);\n\n  /**\n   * @dev Checks if a given hash of miner,requestId has been disputed\n   * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n   * @return uint disputeId\n   */\n  function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\n\n  /**\n   * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n   * @param _disputeId is the dispute id;\n   * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n   * the variables/strings used to save the data in the mapping. The variables names are\n   * commented out under the disputeUintVars under the Dispute struct\n   * @return uint value for the bytes32 data submitted\n   */\n  function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns (uint256);\n\n  /**\n   * @dev Gets the a value for the latest timestamp available\n   * @return value for timestamp of last proof of work submited\n   * @return true if the is a timestamp for the lastNewValue\n   */\n  function getLastNewValue() external view returns (uint256, bool);\n\n  /**\n   * @dev Gets the a value for the latest timestamp available\n   * @param _requestId being requested\n   * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n   */\n  function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\n\n  /**\n   * @dev Gets blocknumber for mined timestamp\n   * @param _requestId to look up\n   * @param _timestamp is the timestamp to look up blocknumber\n   * @return uint of the blocknumber which the dispute was mined\n   */\n  function getMinedBlockNum(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\n\n  /**\n   * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n   * @param _requestId to look up\n   * @param _timestamp is the timestamp to look up miners for\n   * @return the 5 miners' addresses\n   */\n  function getMinersByRequestIdAndTimestamp(\n    uint256 _requestId,\n    uint256 _timestamp\n  ) external view returns (address[5] memory);\n\n  /**\n   * @dev Counts the number of values that have been submited for the request\n   * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n   * request so far\n   * @param _requestId the requestId to look up\n   * @return uint count of the number of values received for the requestId\n   */\n  function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\n\n  /**\n   * @dev Getter function for the specified requestQ index\n   * @param _index to look up in the requestQ array\n   * @return uint of reqeuestId\n   */\n  function getRequestIdByRequestQIndex(uint256 _index) external view returns (uint256);\n\n  /**\n   * @dev Getter function for requestId based on timestamp\n   * @param _timestamp to check requestId\n   * @return uint of reqeuestId\n   */\n  function getRequestIdByTimestamp(uint256 _timestamp) external view returns (uint256);\n\n  /**\n   * @dev Getter function for requestId based on the queryHash\n   * @param _request is the hash(of string api and granularity) to check if a request already exists\n   * @return uint requestId\n   */\n  function getRequestIdByQueryHash(bytes32 _request) external view returns (uint256);\n\n  /**\n   * @dev Getter function for the requestQ array\n   * @return the requestQ arrray\n   */\n  function getRequestQ() external view returns (uint256[51] memory);\n\n  /**\n   * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n   * for the requestId specified\n   * @param _requestId to look up\n   * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n   * the variables/strings used to save the data in the mapping. The variables names are\n   * commented out under the apiUintVars under the requestDetails struct\n   * @return uint value of the apiUintVars specified in _data for the requestId specified\n   */\n  function getRequestUintVars(uint256 _requestId, bytes32 _data) external view returns (uint256);\n\n  /**\n   * @dev Gets the API struct variables that are not mappings\n   * @param _requestId to look up\n   * @return string of api to query\n   * @return string of symbol of api to query\n   * @return bytes32 hash of string\n   * @return bytes32 of the granularity(decimal places) requested\n   * @return uint of index in requestQ array\n   * @return uint of current payout/tip for this requestId\n   */\n  function getRequestVars(\n    uint256 _requestId\n  ) external view returns (string memory, string memory, bytes32, uint256, uint256, uint256);\n\n  /**\n   * @dev This function allows users to retireve all information about a staker\n   * @param _staker address of staker inquiring about\n   * @return uint current state of staker\n   * @return uint startDate of staking\n   */\n  function getStakerInfo(address _staker) external view returns (uint256, uint256);\n\n  /**\n   * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n   * @param _requestId to look up\n   * @param _timestamp is the timestampt to look up miners for\n   * @return address[5] array of 5 addresses ofminers that mined the requestId\n   */\n  function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (uint256[5] memory);\n\n  /**\n   * @dev Gets the timestamp for the value based on their index\n   * @param _requestID is the requestId to look up\n   * @param _index is the value index to look up\n   * @return uint timestamp\n   */\n  function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256);\n\n  /**\n   * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\n   * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n   * the variables/strings used to save the data in the mapping. The variables names are\n   * commented out under the uintVars under the TellorStorageStruct struct\n   * This is an example of how data is saved into the mapping within other functions:\n   * self.uintVars[keccak256(\"stakerCount\")]\n   * @return uint of specified variable\n   */\n  function getUintVar(bytes32 _data) external view returns (uint256);\n\n  /**\n   * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n   * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n   */\n  function getVariablesOnDeck() external view returns (uint256, uint256, string memory);\n\n  /**\n   * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n   * @param _requestId to look up\n   * @param _timestamp is the timestamp to look up miners for\n   * @return bool true if requestId/timestamp is under dispute\n   */\n  function isInDispute(uint256 _requestId, uint256 _timestamp) external view returns (bool);\n\n  /**\n   * @dev Retreive value from oracle based on timestamp\n   * @param _requestId being requested\n   * @param _timestamp to retreive data/value from\n   * @return value for timestamp submitted\n   */\n  function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\n\n  /**\n   * @dev Getter for the total_supply of oracle tokens\n   * @return uint total supply\n   */\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/Dependencies/LiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './LiquityMath.sol';\nimport '../Interfaces/IBase.sol';\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract LiquityBase is IBase {\n  uint internal constant DECIMAL_PRECISION = 1e18;\n  uint32 public constant SWAP_FEE_PRECISION = 1e6;\n  uint32 public constant SWAP_BASE_FEE = 0.003e6; // 0.3%\n  uint public constant _100pct = 1e18; // 1e18 == 100%\n  uint public constant MCR = 1.1e18; // 110%, Minimum collateral ratio for individual troves\n  uint public constant CCR = 1.5e18; // 150%, Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n  uint public constant STABLE_COIN_GAS_COMPENSATION = 200e18; // Amount of stable to be locked in gas pool on opening troves\n  uint public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n  uint public constant MAX_BORROWING_FEE = 0.05e18; // 5%\n  uint public constant BORROWING_FEE_FLOOR = 0.005e18; // 0.5%\n  uint public constant REDEMPTION_FEE_FLOOR = 0.005e18; // 0.5%\n\n  // todo update\n  address public constant GOV_STAKING_ADDRESS = address(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266);\n  uint32 public constant GOV_SWAP_FEE = 0.5e6; // 50% of the dynamic swap fee\n\n  // Return the coll amount of to be drawn from a trove's collateral and sent as gas compensation.\n  function _getCollGasCompensation(uint _collAmount) internal pure returns (uint) {\n    return _collAmount / PERCENT_DIVISOR;\n  }\n\n  function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\n    if (_fee == 0) return;\n\n    uint feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n    // Fee exceeded provided maximum\n    if (feePercentage > _maxFeePercentage) revert FeeExceedMaxPercentage();\n  }\n}\n"
    },
    "contracts/Dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LiquityMath {\n  uint internal constant DECIMAL_PRECISION = 1e18;\n\n  function _min(uint _a, uint _b) internal pure returns (uint) {\n    return (_a < _b) ? _a : _b;\n  }\n\n  function _max(uint _a, uint _b) internal pure returns (uint) {\n    return (_a >= _b) ? _a : _b;\n  }\n\n  /*\n   * Multiply two decimal numbers and use normal rounding rules:\n   * -round product up if 19'th mantissa digit >= 5\n   * -round product down if 19'th mantissa digit < 5\n   *\n   * Used only inside the exponentiation, _decPow().\n   */\n  function decMul(uint x, uint y) internal pure returns (uint decProd) {\n    uint prod_xy = x * y;\n\n    decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\n  }\n\n  /*\n   * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n   *\n   * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n   *\n   * Called by two functions that represent time in units of minutes:\n   * 1) TroveManager._calcDecayedBaseRate\n   * 2) CommunityIssuance._getCumulativeIssuanceFraction\n   *\n   * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n   * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n   *\n   * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n   * negligibly different from just passing the cap, since:\n   *\n   * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n   * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n   */\n  function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n    if (_minutes > 525600000) {\n      _minutes = 525600000;\n    } // cap to avoid overflow\n\n    if (_minutes == 0) {\n      return DECIMAL_PRECISION;\n    }\n\n    uint y = DECIMAL_PRECISION;\n    uint x = _base;\n    uint n = _minutes;\n\n    // Exponentiation-by-squaring\n    while (n > 1) {\n      if (n % 2 == 0) {\n        x = decMul(x, x);\n        n = n / 2;\n      } else {\n        // if (n % 2 != 0)\n        y = decMul(x, y);\n        x = decMul(x, x);\n        n = (n - 1) / 2;\n      }\n    }\n\n    return decMul(x, y);\n  }\n\n  function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n    return (_a >= _b) ? _a - _b : _b - _a;\n  }\n\n  function _computeCR(uint _coll, uint _debt) internal pure returns (uint) {\n    if (_debt > 0) return (_coll * DECIMAL_PRECISION) / _debt;\n\n    // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n    // if (_debt == 0)\n    return 2 ** 256 - 1;\n  }\n\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n  function _sqrt(uint y) internal pure returns (uint z) {\n    if (y > 3) {\n      z = y;\n      uint x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n  }\n}\n"
    },
    "contracts/Dependencies/TellorCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../Interfaces/ITellorCaller.sol';\nimport './ITellor.sol';\n\n/*\n * This contract has a single external function that calls Tellor: getTellorCurrentValue().\n *\n * The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert,\n * this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n *\n * The function comes from Tellor's own wrapper contract, 'UsingTellor.sol':\n * https://github.com/tellor-io/usingtellor/blob/master/contracts/UsingTellor.sol\n *\n */\ncontract TellorCaller is ITellorCaller {\n  ITellor public tellor;\n\n  constructor(address _tellorMasterAddress) {\n    tellor = ITellor(_tellorMasterAddress);\n  }\n\n  /*\n   * getTellorCurrentValue(): identical to getCurrentValue() in UsingTellor.sol\n   *\n   * @dev Allows the user to get the latest value for the requestId specified\n   * @param _requestId is the requestId to look up the value for\n   * @return ifRetrieve bool true if it is able to retrieve a value, the value, and the value's timestamp\n   * @return value the value retrieved\n   * @return _timestampRetrieved the value's timestamp\n   */\n  function getTellorCurrentValue(\n    uint256 _requestId\n  ) external view override returns (bool ifRetrieve, uint256 value, uint256 _timestampRetrieved) {\n    uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\n    uint256 _time = tellor.getTimestampbyRequestIDandIndex(_requestId, _count - 1);\n    uint256 _value = tellor.retrieveData(_requestId, _time);\n    if (_value > 0) return (true, _value, _time);\n    return (false, 0, _time);\n  }\n}\n"
    },
    "contracts/Dependencies/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n  uint224 constant Q112 = 2 ** 112;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 y) internal pure returns (uint224 z) {\n    z = uint224(y) * Q112; // never overflows\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n    z = x / uint224(y);\n  }\n}\n"
    },
    "contracts/GovSubsidy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\nimport './Interfaces/IReservePool.sol';\nimport './Interfaces/ISwapOperations.sol';\nimport './Interfaces/IGovSubsidy.sol';\nimport './Dependencies/LiquityBase.sol';\n\ncontract GovSubsidy is LiquityBase, Ownable(msg.sender), CheckContract, IGovSubsidy {\n  string public constant NAME = 'GovSubsidy';\n\n  IStabilityPoolManager public stabilityPoolManager;\n  IReservePool public reservePool;\n  ISwapOperations public swapOperations;\n\n  // 100% in total (DECIMAL_PRECISION)\n  uint public relativeStabilityPoolManager;\n  uint public relativeReservePool;\n  uint public relativeSwapOperations;\n\n  function setAddresses(\n    address _stabilityPoolManager,\n    address _reservePool,\n    address _swapOperations\n  ) external onlyOwner {\n    checkContract(_stabilityPoolManager);\n    checkContract(_reservePool);\n    checkContract(_swapOperations);\n\n    stabilityPoolManager = IStabilityPoolManager(_stabilityPoolManager);\n    reservePool = IReservePool(_reservePool);\n    swapOperations = ISwapOperations(_swapOperations);\n\n    emit GovSubsidyInitialized(_stabilityPoolManager, _reservePool, _swapOperations);\n  }\n\n  function updateRewardDistribution(\n    uint _relativeStabilityPoolManager,\n    uint _relativeReservePool,\n    uint _relativeSwapOperations\n  ) external onlyOwner {\n    if (_relativeStabilityPoolManager + _relativeReservePool + _relativeSwapOperations != DECIMAL_PRECISION)\n      revert InvalidRewardDistribution();\n    relativeStabilityPoolManager = _relativeStabilityPoolManager;\n    relativeReservePool = _relativeReservePool;\n    relativeSwapOperations = _relativeSwapOperations;\n  }\n\n  function distribute() external {\n    // todo distribute gov token based on the configured distribution\n  }\n}\n"
    },
    "contracts/HintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\n\ncontract HintHelpers is LiquityBase, Ownable(msg.sender), CheckContract {\n  string public constant NAME = 'HintHelpers';\n\n  ISortedTroves public sortedTroves;\n  ITroveManager public troveManager;\n\n  // --- Events ---\n\n  event HintHelpersInitialized(address _sortedTrovesAddress, address _troveManagerAddress);\n\n  // --- Dependency setters ---\n\n  function setAddresses(address _sortedTrovesAddress, address _troveManagerAddress) external onlyOwner {\n    checkContract(_sortedTrovesAddress);\n    checkContract(_troveManagerAddress);\n\n    sortedTroves = ISortedTroves(_sortedTrovesAddress);\n    troveManager = ITroveManager(_troveManagerAddress);\n\n    emit HintHelpersInitialized(_sortedTrovesAddress, _troveManagerAddress);\n    renounceOwnership();\n  }\n\n  // --- Functions ---\n\n  /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the\n    sortedTroves list from the correct insert position of the Trove to be inserted.\n\n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will\n    be <= sqrt(length) positions away from the correct insert position.\n    */\n  function getApproxHint(\n    uint _CR,\n    uint _numTrials,\n    uint _inputRandomSeed\n  ) external view returns (address hintAddress, uint diff, uint latestRandomSeed) {\n    uint arrayLength = sortedTroves.getSize();\n    if (arrayLength == 0) return (address(0), 0, _inputRandomSeed);\n\n    hintAddress = sortedTroves.getLast();\n    diff = LiquityMath._getAbsoluteDifference(_CR, sortedTroves.getUsedCR(hintAddress));\n    latestRandomSeed = _inputRandomSeed;\n\n    uint i = 1;\n    while (i < _numTrials) {\n      latestRandomSeed = uint(keccak256(abi.encodePacked(latestRandomSeed)));\n\n      uint arrayIndex = latestRandomSeed % arrayLength;\n      address currentAddress = sortedTroves.getByIndex(arrayIndex);\n\n      // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n      uint currentDiff = LiquityMath._getAbsoluteDifference(_CR, sortedTroves.getUsedCR(currentAddress));\n      if (currentDiff < diff) {\n        diff = currentDiff;\n        hintAddress = currentAddress;\n      }\n\n      i++;\n    }\n  }\n}\n"
    },
    "contracts/Interfaces/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBase {\n  enum PoolType {\n    Active, // assets in active troves\n    Default, // assets from redistributions, which are not yet claimed by the trove owners\n    GasCompensation // stableCoin from gas compensation\n  }\n\n  error FeeExceedMaxPercentage();\n\n  struct MintMeta {\n    address upperHint;\n    address lowerHint;\n    uint maxFeePercentage;\n  }\n\n  struct RAmount {\n    address tokenAddress;\n    bool isColl; // coll or debt token\n    uint amount; // initial value in trove\n    uint pendingReward; // gained rewards since deposit\n    uint gasCompensation; // gas compensation for liquidation\n    uint toLiquidate; // amount + pendingReward - gasCompensation\n    uint toRedistribute; // across other open troves\n    uint toOffset; // by stability pools\n    uint collSurplus; // coll only, in case of an ICR > MCR liquidation\n  }\n\n  struct CAmount {\n    address tokenAddress;\n    bool isColl; // coll or debt token\n    uint amount;\n  }\n\n  struct TokenAmount {\n    address tokenAddress;\n    uint amount;\n  }\n}\n"
    },
    "contracts/Interfaces/IBBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\nimport './IDebtToken.sol';\nimport './IStabilityPool.sol';\n\ninterface IBBase is IBase {\n  enum Status {\n    nonExistent,\n    active,\n    closedByOwner,\n    closedByLiquidationInNormalMode,\n    closedByLiquidationInRecoveryMode\n  }\n\n  struct DebtTokenAmount {\n    IDebtToken debtToken;\n    uint netDebt;\n    uint borrowingFee; // only in case of stable coin\n  }\n\n  struct RemainingStability {\n    IStabilityPool stabilityPool;\n    address tokenAddress;\n    uint remaining;\n    uint debtToOffset; // debt amount which will be removed from the stability pool to liquidate the trove\n    TokenAmount[] collGained; // coll which will be sent to the SP as rewards (multiple entries with same token address are possible)\n  }\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations is IBBase {\n  // --- Events ---\n\n  event BorrowerOperationsInitialized(\n    address _troveManagerAddress,\n    address _storagePoolAddress,\n    address _stabilityPoolAddress,\n    address _reservePoolAddress,\n    address _priceFeedAddress,\n    address _debtTokenManagerAddress,\n    address _collTokenManagerAddress,\n    address _swapOperationsAddress,\n    address _sortedTrovesAddress,\n    address _collSurplusPoolAddress\n  );\n  event TroveCreated(address _borrower, TokenAmount[] _colls);\n  event PaidBorrowingFee(address indexed _borrower, uint amount);\n\n  // --- Custom Errors ---\n\n  error NotFromStabilityPool();\n  error NotFromSwapOps();\n  error CollWithdrawPermittedInRM();\n  error ICR_lt_MCR();\n  error ICR_lt_CCR();\n  error TCR_lt_CCR();\n  error ICRDecreasedInRM();\n  error MaxFee_gt_100_InRM();\n  error MaxFee_out_Range();\n  error Repaid_gt_CurrentDebt();\n  error TroveClosedOrNotExist();\n  error ActiveTrove();\n  error NotAllowedInRecoveryMode();\n  error NotBorrower();\n  error WithdrawAmount_gt_Coll();\n  error ZeroDebtChange();\n  error InsufficientDebtToRepay();\n  error ZeroDebtRepay();\n\n  // --- Functions ---\n\n  function openTrove(TokenAmount[] memory _colls) external;\n\n  function openTroveWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external;\n\n  function addColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) external;\n\n  function addCollWithPermit(\n    TokenAmount[] memory _colls,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s,\n    address _upperHint,\n    address _lowerHint\n  ) external;\n\n  function withdrawColl(TokenAmount[] memory _colls, address _upperHint, address _lowerHint) external;\n\n  function increaseDebt(address _borrower, address _to, TokenAmount[] memory _debts, MintMeta memory _meta) external;\n\n  function repayDebt(TokenAmount[] memory _debts, address _upperHint, address _lowerHint) external;\n\n  function repayDebtFromPoolBurn(\n    address borrower,\n    TokenAmount[] memory _debts,\n    address _upperHint,\n    address _lowerHint\n  ) external;\n\n  function closeTrove() external;\n\n  function claimCollateral() external;\n\n  function getCompositeDebt(DebtTokenAmount[] memory _debts) external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\n\ninterface ICollSurplusPool is IBase {\n  // --- Events ---\n\n  event CollSurplusPoolInitialized(address _liquidationOperationsAddress, address _borrowerOperationsAddress);\n  event CollBalanceUpdated(address indexed _account, TokenAmount[] _collSurplus);\n  event CollClaimed(address _to);\n\n  error NotFromProtocol();\n\n  // --- Contract setters ---\n\n  function getCollateral(address _account) external view returns (TokenAmount[] memory);\n\n  function accountSurplus(address _account, RAmount[] memory _collSurplus) external;\n\n  function claimColl(address _account) external;\n}\n"
    },
    "contracts/Interfaces/ICollTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICollTokenManager {\n  // --- Events ---\n  event CollTokenManagerInitialized(address _priceFeedAddress);\n  event CollTokenAdded(address _collTokenAddress);\n\n  // --- Custom Errors ---\n  error TokenAlreadyAdded();\n\n  // --- Functions ---\n\n  function getCollTokenAddresses() external view returns (address[] memory);\n\n  function addCollToken(address _tokenAddress) external;\n}\n"
    },
    "contracts/Interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '../Dependencies/IERC2612.sol';\nimport './IBase.sol';\n\ninterface IDebtToken is IERC20, IERC20Metadata, IERC2612, IBase {\n  // --- Custom Errors ---\n  error NotFromBorrowerOps();\n  error NotFromBOorTroveMorSPorDebtToken();\n  error NotFromSPManager();\n  error NotFromTroveMorSP();\n  error NotAllowedDirectTransfer();\n  error InvalidSignature();\n  error ExpiredDeadline();\n  error InsufficientBalance();\n\n  // --- Functions ---\n\n  function isStableCoin() external view returns (bool);\n\n  function getPrice() external view returns (uint);\n\n  function mint(address _account, uint256 _amount) external;\n\n  function burn(address _account, uint256 _amount) external;\n\n  function sendToPool(address _sender, address _poolAddress, uint256 _amount) external;\n\n  function totalSupply() external view override returns (uint256);\n\n  function balanceOf(address account) external view override returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external override returns (bool);\n\n  function allowance(address owner, address spender) external view override returns (uint256);\n\n  function approve(address spender, uint256 amount) external override returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n  function domainSeparator() external view override returns (bytes32);\n\n  function permit(\n    address owner,\n    address spender,\n    uint amount,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override;\n\n  function nonces(address owner) external view override returns (uint256);\n\n  function name() external view override returns (string memory);\n\n  function symbol() external view override returns (string memory);\n\n  function decimals() external view override returns (uint8);\n\n  function version() external view override returns (string memory);\n\n  function permitTypeHash() external view override returns (bytes32);\n}\n"
    },
    "contracts/Interfaces/IDebtTokenManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\n\n// Common interface for the dToken Manager.\ninterface IDebtTokenManager {\n  // --- Events ---\n\n  event DebtTokenManagerInitialized(address _stabilityPoolManagerAddress);\n  event DebtTokenAdded(address _debtTokenAddress);\n\n  // --- Custom Errors ---\n\n  error InvalidDebtToken();\n  error SymbolAlreadyExists();\n  error StableCoinAlreadyExists();\n\n  // --- Functions ---\n\n  function getStableCoin() external view returns (IDebtToken);\n\n  function isDebtToken(address _address) external view returns (bool);\n\n  function getDebtToken(address _address) external view returns (IDebtToken);\n\n  function getDebtTokenAddresses() external view returns (address[] memory);\n\n  function addDebtToken(address _debtTokenAddress) external;\n}\n"
    },
    "contracts/Interfaces/IGovSubsidy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\nimport './IDebtToken.sol';\n\ninterface IGovSubsidy is IBBase {\n  error InvalidRewardDistribution();\n\n  event GovSubsidyInitialized(address _stabilityPoolManager, address _reservePool, address _swapOperations);\n\n  function updateRewardDistribution(\n    uint _relativeStabilityPoolManager,\n    uint _relativeReservePool,\n    uint _relativeSwapOperations\n  ) external;\n\n  function distribute() external;\n}\n"
    },
    "contracts/Interfaces/ILiquidationOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\nimport './IBBase.sol';\nimport './IPriceFeed.sol';\nimport './IDebtTokenManager.sol';\n\ninterface ILiquidationOperations is IBBase {\n  // --- Events ---\n\n  event LiquidationOperationsInitialized(\n    address _troveManager,\n    address _storgePool,\n    address _priceFeed,\n    address _debtTokenManager,\n    address _collTokenManager,\n    address _stabilityPoolManager,\n    address _collSurplusPool\n  );\n\n  event LiquidationSummary(\n    TokenAmount[] liquidatedDebt,\n    TokenAmount[] liquidatedColl,\n    uint totalStableCoinGasCompensation,\n    TokenAmount[] totalCollGasCompensation\n  );\n\n  // --- Errors ---\n\n  error NoLiquidatableTrove();\n  error EmptyArray();\n\n  // --- Functions ---\n\n  function liquidate(address _borrower) external;\n\n  function batchLiquidateTroves(address[] calldata _troveArray) external;\n}\n"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\n\ninterface IPriceFeed is IBase {\n  enum Status {\n    working,\n    oraclesUntrusted\n  }\n\n  // --- Events ---\n  event LastGoodPriceUpdated(address _token, uint _lastGoodPrice);\n  event PriceFeedStatusChanged(address _token, Status newStatus);\n  event TokenPriceChanged(address _token);\n\n  // --- Function ---\n  function getPrice(address _tokenAddress) external view returns (uint price);\n\n  function getUSDValue(address _token, uint _amount) external view returns (uint usdValue);\n\n  function getAmountFromUSDValue(address _token, uint256 _usdValue) external view returns (uint amount);\n}\n"
    },
    "contracts/Interfaces/IRedemptionOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\nimport './IBBase.sol';\nimport './IPriceFeed.sol';\nimport './IDebtTokenManager.sol';\n\ninterface IRedemptionOperations is IBBase {\n  // --- structs ---\n\n  struct RedemptionCollAmount {\n    address collToken;\n    uint drawn;\n    uint redemptionFee;\n    uint sendToRedeemer;\n  }\n\n  struct RedeemIteration {\n    address trove;\n    address upperHint;\n    address lowerHint;\n    uint expectedCR;\n  }\n\n  struct SingleRedemptionVariables {\n    TokenAmount stableCoinEntry;\n    //\n    uint stableCoinLot; // redeemer pays for the debts of the trove owner\n    TokenAmount[] collLots; // will be removed from the troves coll and paid to the redeemer\n    //\n    uint troveCollInUSD;\n    uint troveDebtInUSD;\n    uint resultingCR;\n  }\n\n  // --- Events ---\n\n  event RedemptionOperationsInitialized(\n    address _troveManager,\n    address _storgePool,\n    address _priceFeed,\n    address _debtTokenManager,\n    address _collTokenManager,\n    address _sortedTrovesAddress\n  );\n  event RedeemedFromTrove(address _borrower, uint stableAmount, TokenAmount[] _drawnCollAmounts);\n  event SuccessfulRedemption(\n    uint _attemptedStableAmount,\n    uint _actualStableAmount,\n    RedemptionCollAmount[] _collPayouts\n  );\n\n  // --- Errors ---\n\n  error ZeroAmount();\n  error InvalidMaxFeePercent();\n  error LessThanMCR();\n  error ExceedDebtBalance();\n  error NoRedeems();\n  error GreaterThanTCR();\n  error TooHighRedeemFee();\n  error InvalidRedemptionHint();\n  error HintUnknown();\n  error HintBelowMCR();\n  error InvalidHintLowerCRExists();\n\n  // --- Functions ---\n\n  function redeemCollateral(\n    uint _stableCoinAmount,\n    RedeemIteration[] memory _iterations,\n    uint _maxFeePercentage\n  ) external;\n\n  function calculateTroveRedemption(\n    address _borrower,\n    uint _redeemMaxAmount,\n    bool _includePendingRewards\n  ) external returns (SingleRedemptionVariables memory vars);\n\n  function getRedemptionRate() external view returns (uint);\n\n  function getRedemptionRateWithDecay() external view returns (uint);\n\n  function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/IReservePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\nimport './IDebtToken.sol';\n\ninterface IReservePool is IBBase {\n  error NotFromSPM();\n\n  event ReservePoolInitialized(\n    address _stabilityPoolManager,\n    address _priceFeed,\n    address _stableDebtTokenAddress,\n    address _govTokenAddress\n  );\n  event ReserveCapChanged(uint newReserveCap, uint newGovReserveCap);\n  event WithdrewReserves(uint govAmount, uint stableAmount);\n\n  function stableDebtToken() external view returns (IDebtToken);\n\n  function govToken() external view returns (IERC20);\n\n  function setRelativeStableCap(uint _relativeStableCap) external;\n\n  function stableAmountUntilCap() external view returns (uint);\n\n  function isGovReserveCapReached() external view returns (bool);\n\n  function withdrawValue(address stabilityPool, uint withdrawAmount) external returns (uint usedGov, uint usedStable);\n}\n"
    },
    "contracts/Interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISortedTroves {\n  // --- Errors ---\n\n  error SizeCantBeZero();\n  error ListIsFull();\n  error ListAlreadyContainsNode();\n  error ListDoesNotContainNode();\n  error IdCantBeZero();\n  error CRNotPositive();\n  error CallerNotBrOrTrContract();\n\n  // --- Events ---\n\n  event SortedTrovesInitialised(\n    address _troveManagerAddress,\n    address _borrowerOperationsAddress,\n    address _redemptionOperationsAddress\n  );\n  event NodeAdded(address _id, uint _CR);\n  event NodeRemoved(address _id);\n\n  // --- Functions ---\n\n  function update(address _id, uint256 _newCR, uint _redeemableDebt, address _prevId, address _nextId) external;\n\n  function remove(address _id) external;\n\n  function contains(address _id) external view returns (bool);\n\n  function isEmpty() external view returns (bool);\n\n  function getSize() external view returns (uint256);\n\n  function getFirst() external view returns (address);\n\n  function getLast() external view returns (address);\n\n  function getNext(address _id) external view returns (address);\n\n  function getPrev(address _id) external view returns (address);\n\n  function getByIndex(uint _index) external view returns (address);\n\n  function getUsedCR(address _id) external view returns (uint);\n\n  function validInsertPosition(uint256 _CR, address _prevId, address _nextId) external view returns (bool);\n\n  function findInsertPosition(uint256 _CR, address _prevId, address _nextId) external view returns (address, address);\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IDebtToken.sol';\nimport './IBase.sol';\n\ninterface IStabilityPool is IBase {\n  // --- Events ---\n\n  event StabilityPoolInitialized(address stabilityPoolManagerAddress, address depositTokenAddress);\n\n  event StabilityProvided(address user, uint amount);\n  event StabilityWithdrawn(address user, uint amount);\n  event StabilityGainsWithdrawn(address user, uint depositLost, TokenAmount[] gainsWithdrawn);\n\n  // used as trigger to update the users compounded deposit and current coll gains (there is not user specific event for that)\n  event StabilityOffset(uint removedDeposit, TokenAmount[] addedGains);\n\n  event P_Updated(uint _P);\n  event S_Updated(address _tokenAddress, uint _S, uint128 _epoch, uint128 _scale);\n  event EpochUpdated(uint128 _currentEpoch);\n  event ScaleUpdated(uint128 _currentScale);\n  event DepositSnapshotUpdated(address indexed _depositor);\n  // event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n\n  // --- Errors  ---\n\n  error NotFromStabilityPoolManager();\n  error ZeroAmount();\n  error NotOneTrove();\n\n  // --- Functions ---\n\n  function getDepositToken() external view returns (IDebtToken);\n\n  function getTotalDeposit() external view returns (uint);\n\n  function getDepositorDeposit(address _depositor) external view returns (uint);\n\n  function getCompoundedDebtDeposit(address _depositor) external view returns (uint);\n\n  function getTotalGainedColl() external view returns (TokenAmount[] memory coll);\n\n  function getDepositorCollGain(address _depositor, address _collToken) external view returns (uint);\n\n  function getDepositorCollSnapshot(address _depositor, address _collToken) external view returns (uint);\n\n  function provideToSP(address user, uint _amount) external;\n\n  function withdrawFromSP(address user, uint _amount) external;\n\n  function withdrawGains(address user) external;\n\n  function offset(uint _debtToOffset, TokenAmount[] memory _collToAdd) external;\n}\n"
    },
    "contracts/Interfaces/IStabilityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\n\ninterface IStabilityPoolManager is IBBase {\n  // --- Events ---\n\n  event StabilityPoolManagerInitiated(\n    address liquidationOperationsAddress,\n    address storgePoolAddress,\n    address reservePoolAddress,\n    address debtTokenManagerAddress,\n    address priceFeedAddress\n  );\n  event StabilityPoolAdded(address stabilityPoolAddress);\n\n  // --- Custom Errors ---\n  error NotFromLiquidationOps();\n  error NotFromReservePool();\n  error PoolNotExist();\n  error PoolExist();\n  error Unauthorized();\n\n  // --- Functions ---\n  function getStabilityPool(IDebtToken _debtToken) external view returns (IStabilityPool);\n\n  function getRemainingStability(\n    address[] memory collTokenAddresses\n  ) external view returns (RemainingStability[] memory);\n\n  function getTotalDeposits() external view returns (TokenAmount[] memory deposits);\n\n  function getTotalDeposit(address _debtTokenAddress) external view returns (uint amount);\n\n  function getDepositorDeposits(address _depositor) external view returns (TokenAmount[] memory deposits);\n\n  function getDepositorDeposit(address _depositor, address _debtTokenAddress) external view returns (uint amount);\n\n  function getCompoundedDeposits() external view returns (TokenAmount[] memory deposits);\n\n  function getDepositorCompoundedDeposit(\n    address _depositor,\n    address _debtTokenAddress\n  ) external view returns (uint amount);\n\n  function getDepositorCompoundedDeposits(address _depositor) external view returns (TokenAmount[] memory deposits);\n\n  function getDepositorCollGains(\n    address _depositor,\n    address[] memory collTokenAddresses\n  ) external view returns (TokenAmount[] memory collGains);\n\n  function provideStability(TokenAmount[] memory _debts) external;\n\n  function withdrawStability(TokenAmount[] memory _debts) external;\n\n  function withdrawGains() external;\n\n  function offset(RemainingStability[] memory _toOffset) external;\n\n  function addStabilityPool(IDebtToken _debtToken) external;\n}\n"
    },
    "contracts/Interfaces/IStoragePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBase.sol';\n\ninterface IStoragePool is IBase {\n  // --- Events ---\n\n  event StoragePoolInitialized(\n    address _borrowerOperationsAddress,\n    address _troveManagerAddress,\n    address _redemptionOperationsAddress,\n    address _liquidationOperationsAddress,\n    address _stabilityPoolManagerAddress,\n    address _priceFeedAddress\n  );\n  event StoragePoolValueUpdated(address _tokenAddress, bool _isColl, PoolType _poolType, uint _updatedAmount);\n\n  // --- Custom Errors ---\n\n  error NotFromBOorTroveMorSP();\n  error PoolEntryDoesntExist();\n\n  // --- Functions ---\n\n  function getValue(address _tokenAddress, bool _isColl, PoolType _poolType) external view returns (uint);\n\n  function addValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) external;\n\n  function subtractValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) external;\n\n  function withdrawalValue(\n    address _receiver,\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _poolType,\n    uint _amount\n  ) external;\n\n  function transferBetweenTypes(\n    address _tokenAddress,\n    bool _isCool,\n    PoolType _fromType,\n    PoolType _toType,\n    uint _amount\n  ) external;\n\n  function getEntireSystemColl() external view returns (uint entireSystemColl);\n\n  function getEntireSystemDebt() external view returns (uint entireSystemDebt);\n\n  function getTokenTotalAmount(address _tokenAddress, bool _isColl) external view returns (uint);\n\n  function checkRecoveryMode()\n    external\n    view\n    returns (bool isInRecoveryMode, uint TCR, uint entireSystemColl, uint entireSystemDebt);\n}\n"
    },
    "contracts/Interfaces/ISwapCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISwapCallee {\n  function swapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/Interfaces/ISwapERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISwapERC20 {\n  error PermitExpired();\n  error InvalidSignature();\n\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address owner) external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/ISwapOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IBBase.sol';\n\ninterface ISwapOperations is IBBase {\n  error Forbidden();\n  error IdenticalAddresses();\n  error PairExists();\n  error Expired();\n  error PairDoesNotExist();\n  error InsufficientAAmount();\n  error InsufficientBAmount();\n  error InsufficientInputAmount();\n  error InsufficientOutputAmount();\n  error ExcessiveInputAmount();\n  error InsufficientLiquidity();\n  error InsufficientAmount();\n  error InvalidPath();\n  error TransferFromFailed();\n  error PairRequiresStable();  \n\n  event SwapOperationsInitialized(\n    address borrowerOperations,\n    address troveManager,\n    address priceFeed,\n    address debtTokenManager\n  );\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  struct RemoveLiquidtyPermitParams {\n    address tokenA;\n    address tokenB;\n    uint liquidity;\n    uint amountAMin;\n    uint amountBMin;\n    uint deadline;\n    bool approveMax;\n    address _upperHint;\n    address _lowerHint;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  // **** GETTER ****\n\n  function allPairs(uint) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) external pure returns (uint amountOut);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) external pure returns (uint amountIn);\n\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n  // **** OPERATIONS ****\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  function addLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  // automatically repays any related open loans from the borrower (msg.sender)\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address _upperHint,\n    address _lowerHint,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactTokensForTokensWithPermit(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint[] memory amounts);\n\n  function openLongPosition(\n    uint stableToMintIn,\n    uint debtOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function openShortPosition(\n    uint debtToMintIn,\n    uint stableOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n}\n"
    },
    "contracts/Interfaces/ISwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './ISwapERC20.sol';\n\ninterface ISwapPair is ISwapERC20 {\n  error Locked();\n  error TransferFailed();\n  error Forbidden();\n  error Overflow();\n  error InsufficientLiquidityMinted();\n  error InsufficientLiquidityBurned();\n  error InsufficientInputAmount();\n  error InsufficientOutputAmount();\n  error InsufficientLiquidity();\n  error InvalidTo();\n  error K();\n  error NotFromSwapOperations();\n\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    uint32 currentSwapFee,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  // **** GETTER ****\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint);\n\n  function price1CumulativeLast() external view returns (uint);\n\n  function getSwapFee() external view returns (uint32 swapFee);\n\n  // **** OPERATIONS ****\n\n  function mint(address to) external returns (uint liquidity);\n\n  function burn(\n    address to,\n    uint liquidity,\n    uint debt0,\n    uint debt1\n  ) external returns (uint amount0, uint amount1, uint burned0, uint burned1);\n\n  function swap(uint amount0Out, uint amount1Out, address to) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address, address, address) external;\n}\n"
    },
    "contracts/Interfaces/ITellorCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITellorCaller {\n  function getTellorCurrentValue(uint256 _requestId) external view returns (bool, uint256, uint256);\n}\n"
    },
    "contracts/Interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './IStabilityPool.sol';\nimport './IDebtToken.sol';\nimport './IBBase.sol';\nimport './IPriceFeed.sol';\nimport './IDebtTokenManager.sol';\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IBBase {\n  // --- Events ---\n\n  event TroveManagerInitialized(\n    address _borrowerOperationsAddress,\n    address _redemptionOperationsAddress,\n    address _liquidationOperationsAddress,\n    address _storagePoolAddress,\n    address _priceFeedAddress,\n    address _sortedTrovesAddress\n  );\n\n  event TroveAppliedRewards(address _borrower, CAmount[] _appliedRewards);\n  event TroveClosed(address _borrower, Status _closingState);\n  event TroveIndexUpdated(address _borrower, uint _newIndex);\n  event TroveCollChanged(address _borrower, address[] _collTokenAddresses);\n\n  event StableCoinBaseRateUpdated(uint _baseRate);\n  event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n  event TotalStakesUpdated(TokenAmount[] _totalStakes);\n  event SystemSnapshotsUpdated(TokenAmount[] _totalStakesSnapshot, TokenAmount[] _totalCollateralSnapshot);\n  event LTermsUpdated(CAmount[] _liquidatedTokens);\n  event TroveSnapshotsUpdated(CAmount[] _liquidatedTokens);\n\n  // --- Errors ---\n\n  error NotFromBorrowerOrRedemptionOps();\n  error InvalidTrove();\n  error OnlyOneTrove();\n\n  // --- Functions ---\n\n  function getTroveOwnersCount() external view returns (uint);\n\n  function getTroveStatus(address _borrower) external view returns (uint);\n\n  function isTroveActive(address _borrower) external view returns (bool);\n\n  function setTroveStatus(address _borrower, uint num) external;\n\n  //\n\n  function getCurrentICR(address _borrower) external view returns (uint ICR, uint currentDebtInUSD);\n\n  function getICRIncludingPatch(\n    address _borrower,\n    TokenAmount[] memory addedColl,\n    TokenAmount[] memory removedColl,\n    TokenAmount[] memory addedDebt,\n    TokenAmount[] memory removedDebt\n  ) external view returns (uint ICR);\n\n  //\n\n  function updateStakeAndTotalStakes(address[] memory collTokenAddresses, address _borrower) external;\n\n  function removeStake(address[] memory collTokenAddresses, address _borrower) external;\n\n  function updateSystemSnapshots_excludeCollRemainder(TokenAmount[] memory totalCollGasCompensation) external;\n\n  function getTroveStakes(address _borrower, address _token) external view returns (uint);\n\n  function getTroveStakeValue(address _borrower) external view returns (uint);\n\n  //\n\n  function redistributeDebtAndColl(address[] memory collTokenAddresses, CAmount[] memory toRedistribute) external;\n\n  function getPendingReward(\n    address _borrower,\n    address _tokenAddress,\n    bool _isColl\n  ) external view returns (uint pendingReward);\n\n  function applyPendingRewards(address _borrower) external;\n\n  function updateTroveRewardSnapshots(address _borrower) external;\n\n  //\n\n  function increaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external;\n\n  function decreaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external;\n\n  function increaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external;\n\n  function decreaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external;\n\n  //\n\n  function getEntireDebtAndColl(\n    address _borrower\n  )\n    external\n    view\n    returns (\n      RAmount[] memory amounts,\n      uint troveCollInUSD,\n      uint troveDebtInUSD,\n      uint troveDebtInUSDWithoutGasCompensation\n    );\n\n  function getTroveDebt(address _borrower) external view returns (TokenAmount[] memory);\n\n  function getTroveRepayableDebt(address _borrower, address _debtTokenAddress, bool _includingStableCoinGasCompensation) external view returns (uint amount);\n\n  function getTroveRepayableDebts(address _borrower, bool _includingStableCoinGasCompensation) external view returns (TokenAmount[] memory);\n\n  function getTroveColl(address _borrower) external view returns (TokenAmount[] memory);\n\n  function getTroveWithdrawableColl(address _borrower, address _collTokenAddress) external view returns (uint amount);\n\n  function getTroveWithdrawableColls(address _borrower) external view returns (TokenAmount[] memory colls);\n\n  //\n\n  function addTroveOwnerToArray(address _borrower) external returns (uint128 index);\n\n  function closeTroveByProtocol(address[] memory collTokenAddresses, address _borrower, Status closedStatus) external;\n\n  //\n\n  function getStableCoinBaseRate() external view returns (uint);\n\n  function getBorrowingRate(bool isStableCoin) external view returns (uint);\n\n  function getBorrowingRateWithDecay(bool isStableCoin) external view returns (uint);\n\n  function getBorrowingFee(uint debt, bool isStableCoin) external view returns (uint);\n\n  function getBorrowingFeeWithDecay(uint debt, bool isStableCoin) external view returns (uint);\n\n  function decayStableCoinBaseRateFromBorrowing(uint borrowedStable) external;\n\n  function updateStableCoinBaseRateFromRedemption(uint _totalRedeemedStable, uint _totalStableCoinSupply) external;\n\n  function calcDecayedStableCoinBaseRate() external view returns (uint);\n}\n"
    },
    "contracts/LiquidationOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IBBase.sol';\nimport './Interfaces/ICollTokenManager.sol';\nimport './Interfaces/IRedemptionOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ILiquidationOperations.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\nimport './Interfaces/ICollSurplusPool.sol';\n\ncontract LiquidationOperations is LiquityBase, Ownable(msg.sender), CheckContract, ILiquidationOperations {\n  string public constant NAME = 'LiquidationOperations';\n\n  // --- Connected contract declarations ---\n\n  ITroveManager public troveManager;\n  IStoragePool public storagePool;\n  IPriceFeed public priceFeed;\n  IDebtTokenManager public debtTokenManager;\n  ICollTokenManager public collTokenManager;\n  IStabilityPoolManager public stabilityPoolManager;\n  ICollSurplusPool public collSurplusPool;\n\n  // --- Data structures ---\n\n  struct LocalVariables_OuterLiquidationFunction {\n    address[] collTokenAddresses;\n    //\n    RemainingStability[] remainingStabilities;\n    CAmount[] tokensToRedistribute;\n    TokenAmount[] collSurplus;\n    //\n    uint totalStableCoinGasCompensation; // paid out to the liquidator\n    TokenAmount[] totalCollGasCompensation; // paid out to the liquidator\n    //\n    uint entireSystemCollInUSD;\n    uint entireSystemDebtInUSD;\n    uint TCR;\n    bool isRecoveryMode;\n  }\n\n  struct LocalVariables_LiquidationSequence {\n    uint ICR;\n    //\n    RAmount[] troveAmountsIncludingRewards;\n    uint troveDebtInUSD;\n    uint troveDebtInUSDWithoutGasCompensation;\n    uint troveCollInUSD;\n  }\n\n  // --- Dependency setter ---\n\n  function setAddresses(\n    address _troveManagerAddress,\n    address _storagePoolAddress,\n    address _priceFeedAddress,\n    address _debtTokenManagerAddress,\n    address _collTokenManagerAddress,\n    address _stabilityPoolManagerAddress,\n    address _collSurplusPoolAddress\n  ) external onlyOwner {\n    checkContract(_troveManagerAddress);\n    checkContract(_storagePoolAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManagerAddress);\n    checkContract(_collTokenManagerAddress);\n    checkContract(_stabilityPoolManagerAddress);\n    checkContract(_collSurplusPoolAddress);\n\n    troveManager = ITroveManager(_troveManagerAddress);\n    storagePool = IStoragePool(_storagePoolAddress);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n    debtTokenManager = IDebtTokenManager(_debtTokenManagerAddress);\n    collTokenManager = ICollTokenManager(_collTokenManagerAddress);\n    stabilityPoolManager = IStabilityPoolManager(_stabilityPoolManagerAddress);\n    collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n\n    emit LiquidationOperationsInitialized(\n      _troveManagerAddress,\n      _storagePoolAddress,\n      _priceFeedAddress,\n      _debtTokenManagerAddress,\n      _collTokenManagerAddress,\n      _stabilityPoolManagerAddress,\n      _collSurplusPoolAddress\n    );\n\n    renounceOwnership();\n  }\n\n  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n  function liquidate(address _borrower) public override {\n    address[] memory borrowers = new address[](1);\n    borrowers[0] = _borrower;\n    batchLiquidateTroves(borrowers);\n  }\n\n  /*\n   * Attempt to liquidate a custom list of troves provided by the caller.\n   */\n  function batchLiquidateTroves(address[] memory _troveArray) public override {\n    if (_troveArray.length == 0) revert EmptyArray();\n\n    LocalVariables_OuterLiquidationFunction memory vars;\n    vars.collTokenAddresses = collTokenManager.getCollTokenAddresses();\n\n    (vars.isRecoveryMode, vars.TCR, vars.entireSystemCollInUSD, vars.entireSystemDebtInUSD) = storagePool\n      .checkRecoveryMode();\n    vars.remainingStabilities = stabilityPoolManager.getRemainingStability(vars.collTokenAddresses);\n    _initializeEmptyTokensToRedistribute(vars); // all set to 0 (nothing to redistribute)\n\n    bool atLeastOneTroveLiquidated = false;\n    for (uint i = 0; i < _troveArray.length; i++) {\n      address trove = _troveArray[i];\n      if (!troveManager.isTroveActive(trove)) continue; // Skip non-active troves\n      if (troveManager.getTroveOwnersCount() <= 1) continue; // don't liquidate if last trove\n\n      bool liquidated = _executeTroveLiquidation(vars, trove);\n      if (liquidated && !atLeastOneTroveLiquidated) atLeastOneTroveLiquidated = true;\n    }\n    if (!atLeastOneTroveLiquidated) revert NoLiquidatableTrove();\n\n    // move tokens into the stability pools\n    stabilityPoolManager.offset(vars.remainingStabilities);\n\n    // and redistribute the rest (which could not be handled by the stability pool)\n    troveManager.redistributeDebtAndColl(vars.collTokenAddresses, vars.tokensToRedistribute);\n\n    // move tokens from active pool into the collSurplus, in case there was a capped liquidation\n    for (uint i = 0; i < vars.collSurplus.length; i++) {\n      if (vars.collSurplus[i].amount == 0) continue;\n      storagePool.withdrawalValue(\n        address(collSurplusPool),\n        vars.collSurplus[i].tokenAddress,\n        true,\n        PoolType.Active,\n        vars.collSurplus[i].amount\n      );\n    }\n\n    // Update system snapshots\n    troveManager.updateSystemSnapshots_excludeCollRemainder(vars.totalCollGasCompensation);\n\n    // Send gas compensation to caller\n    _sendGasCompensation(msg.sender, vars.totalStableCoinGasCompensation, vars.totalCollGasCompensation);\n\n    // liquidation event\n    _emitLiquidationSummaryEvent(vars);\n  }\n\n  function _initializeEmptyTokensToRedistribute(LocalVariables_OuterLiquidationFunction memory vars) internal view {\n    address[] memory debtTokenAddresses = debtTokenManager.getDebtTokenAddresses();\n\n    vars.tokensToRedistribute = new CAmount[](debtTokenAddresses.length + vars.collTokenAddresses.length);\n    vars.totalCollGasCompensation = new TokenAmount[](vars.collTokenAddresses.length);\n    vars.collSurplus = new TokenAmount[](vars.collTokenAddresses.length);\n    for (uint i = 0; i < vars.collTokenAddresses.length; i++) {\n      vars.tokensToRedistribute[i] = CAmount(vars.collTokenAddresses[i], true, 0);\n      vars.totalCollGasCompensation[i] = TokenAmount(vars.collTokenAddresses[i], 0);\n      vars.collSurplus[i] = TokenAmount(vars.collTokenAddresses[i], 0);\n    }\n    for (uint i = 0; i < debtTokenAddresses.length; i++)\n      vars.tokensToRedistribute[vars.collTokenAddresses.length + i] = CAmount(debtTokenAddresses[i], false, 0);\n  }\n\n  function _executeTroveLiquidation(\n    LocalVariables_OuterLiquidationFunction memory outerVars,\n    address trove\n  ) internal returns (bool liquidated) {\n    LocalVariables_LiquidationSequence memory vars;\n    (\n      vars.troveAmountsIncludingRewards,\n      vars.troveCollInUSD,\n      vars.troveDebtInUSD,\n      vars.troveDebtInUSDWithoutGasCompensation\n    ) = troveManager.getEntireDebtAndColl(trove);\n    vars.ICR = LiquityMath._computeCR(vars.troveCollInUSD, vars.troveDebtInUSD);\n\n    // ICR >= TCR, skipping liquidation, no matter what mode\n    if (vars.ICR >= outerVars.TCR) return false;\n\n    // ICR >= MCR in normal mode, skipping liquidation\n    if (vars.ICR >= MCR && !outerVars.isRecoveryMode) return false;\n\n    _movePendingTroveRewardsToActivePool(vars.troveAmountsIncludingRewards);\n    troveManager.removeStake(outerVars.collTokenAddresses, trove);\n\n    if (vars.ICR >= MCR) {\n      // capped trove liquidation (at 1.1 * the total debts value)\n      // remaining collateral will stay in the trove\n      _getCappedOffsetVals(\n        vars.troveCollInUSD,\n        vars.troveDebtInUSDWithoutGasCompensation,\n        vars.troveAmountsIncludingRewards,\n        outerVars.remainingStabilities\n      );\n\n      // patch the collSurplus claim, tokens will be transferred in the outer scope\n      collSurplusPool.accountSurplus(trove, vars.troveAmountsIncludingRewards);\n    } else {\n      // full trove liquidation\n      _getOffsetAndRedistributionVals(\n        vars.troveDebtInUSDWithoutGasCompensation,\n        vars.troveAmountsIncludingRewards,\n        outerVars.remainingStabilities\n      );\n    }\n\n    troveManager.closeTroveByProtocol(\n      outerVars.collTokenAddresses,\n      trove,\n      outerVars.isRecoveryMode ? Status.closedByLiquidationInRecoveryMode : Status.closedByLiquidationInNormalMode\n    );\n    _mergeCollGasAndSurplusCompensation(\n      vars.troveAmountsIncludingRewards,\n      outerVars.totalCollGasCompensation,\n      outerVars.collSurplus\n    );\n    _mergeTokensToRedistribute(vars.troveAmountsIncludingRewards, outerVars.tokensToRedistribute);\n    outerVars.totalStableCoinGasCompensation += STABLE_COIN_GAS_COMPENSATION;\n\n    // updating TCR\n    for (uint a = 0; a < vars.troveAmountsIncludingRewards.length; a++) {\n      RAmount memory rAmount = vars.troveAmountsIncludingRewards[a];\n      outerVars.entireSystemCollInUSD -= priceFeed.getUSDValue(rAmount.tokenAddress, rAmount.gasCompensation);\n      if (rAmount.isColl)\n        outerVars.entireSystemCollInUSD -= priceFeed.getUSDValue(rAmount.tokenAddress, rAmount.toOffset);\n      else outerVars.entireSystemDebtInUSD -= priceFeed.getUSDValue(rAmount.tokenAddress, rAmount.toOffset);\n    }\n    outerVars.TCR = LiquityMath._computeCR(outerVars.entireSystemCollInUSD, outerVars.entireSystemDebtInUSD);\n    outerVars.isRecoveryMode = outerVars.TCR < CCR;\n\n    return true;\n  }\n\n  // adding up the coll gas compensation\n  function _mergeCollGasAndSurplusCompensation(\n    RAmount[] memory troveAmountsIncludingRewards,\n    TokenAmount[] memory totalCollGasCompensation,\n    TokenAmount[] memory totalCollSurplus\n  ) internal pure {\n    for (uint i = 0; i < troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmount = troveAmountsIncludingRewards[i];\n      if (!rAmount.isColl) continue;\n\n      if (rAmount.gasCompensation > 0)\n        for (uint ib = 0; ib < totalCollGasCompensation.length; ib++) {\n          if (totalCollGasCompensation[ib].tokenAddress != rAmount.tokenAddress) continue;\n          totalCollGasCompensation[ib].amount += rAmount.gasCompensation;\n          break;\n        }\n\n      if (rAmount.collSurplus > 0)\n        for (uint ib = 0; ib < totalCollSurplus.length; ib++) {\n          if (totalCollSurplus[ib].tokenAddress != rAmount.tokenAddress) continue;\n          totalCollSurplus[ib].amount += rAmount.collSurplus;\n          break;\n        }\n    }\n  }\n\n  // adding up the token to redistribute\n  function _mergeTokensToRedistribute(\n    RAmount[] memory troveAmountsIncludingRewards,\n    CAmount[] memory tokensToRedistribute\n  ) internal pure {\n    for (uint i = 0; i < troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmount = troveAmountsIncludingRewards[i];\n      if (rAmount.toRedistribute == 0) continue;\n\n      for (uint ib = 0; ib < tokensToRedistribute.length; ib++) {\n        if (\n          tokensToRedistribute[ib].tokenAddress != rAmount.tokenAddress ||\n          tokensToRedistribute[ib].isColl != rAmount.isColl\n        ) continue;\n\n        tokensToRedistribute[ib].amount += rAmount.toRedistribute;\n        break;\n      }\n    }\n  }\n\n  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n  function _movePendingTroveRewardsToActivePool(RAmount[] memory _troveAmountsIncludingRewards) internal {\n    for (uint i = 0; i < _troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmount = _troveAmountsIncludingRewards[i];\n      if (rAmount.pendingReward == 0) continue;\n\n      storagePool.transferBetweenTypes(\n        rAmount.tokenAddress,\n        rAmount.isColl,\n        PoolType.Default,\n        PoolType.Active,\n        rAmount.pendingReward\n      );\n    }\n  }\n\n  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n   * redistributed to active troves.\n   */\n  function _getOffsetAndRedistributionVals(\n    uint troveDebtInUSDWithoutGasCompensation,\n    RAmount[] memory troveAmountsIncludingRewards,\n    RemainingStability[] memory remainingStabilities\n  ) internal view {\n    /*\n     * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n     * between all active troves.\n     *\n     *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n     *\n     *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n     *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n     *\n     */\n\n    // by default the entire coll needs to be redistributed\n    for (uint i = 0; i < troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmount = troveAmountsIncludingRewards[i];\n      if (rAmount.isColl) rAmount.toRedistribute = rAmount.toLiquidate;\n    }\n\n    _debtOffset(troveDebtInUSDWithoutGasCompensation, troveAmountsIncludingRewards, remainingStabilities);\n  }\n\n  // Get its offset coll/debt and gas comp.\n  function _getCappedOffsetVals(\n    uint troveCollInUSD,\n    uint troveDebtInUSDWithoutGasCompensation,\n    RAmount[] memory troveAmountsIncludingRewards,\n    RemainingStability[] memory remainingStabilities\n  ) internal view {\n    // capping the to be liquidated collateral to 1.1 * the total debts value\n    uint cappedLimit = troveDebtInUSDWithoutGasCompensation * MCR; // total debt * 1.1\n    for (uint i = 0; i < troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmount = troveAmountsIncludingRewards[i];\n      if (!rAmount.isColl) continue; // coll will be handled later in the debts loop\n\n      uint collToLiquidateInUSD = priceFeed.getUSDValue(rAmount.tokenAddress, rAmount.toLiquidate);\n      uint collToLiquidateInUSDCapped = (cappedLimit * collToLiquidateInUSD) / troveCollInUSD;\n      rAmount.toLiquidate = priceFeed.getAmountFromUSDValue(rAmount.tokenAddress, collToLiquidateInUSDCapped);\n    }\n\n    _debtOffset(troveDebtInUSDWithoutGasCompensation, troveAmountsIncludingRewards, remainingStabilities);\n  }\n\n  function _debtOffset(\n    uint troveDebtInUSDWithoutGasCompensation,\n    RAmount[] memory troveAmountsIncludingRewards,\n    RemainingStability[] memory remainingStabilities\n  ) internal view {\n    // checking if some debt can be offset by the matching stability pool\n    for (uint i = 0; i < troveAmountsIncludingRewards.length; i++) {\n      RAmount memory rAmountDebt = troveAmountsIncludingRewards[i];\n      if (rAmountDebt.isColl) continue; // coll will be handled by the debts loop\n\n      // find the right remainingStability entry for the current debt token\n      RemainingStability memory remainingStability;\n      for (uint ii = 0; ii < remainingStabilities.length; ii++) {\n        if (remainingStabilities[ii].tokenAddress == rAmountDebt.tokenAddress) {\n          remainingStability = remainingStabilities[ii];\n          break;\n        }\n      }\n\n      // trying to hand the debt over to the stability pool\n      if (remainingStability.remaining > 0) {\n        rAmountDebt.toOffset = LiquityMath._min(rAmountDebt.toLiquidate, remainingStability.remaining);\n        remainingStability.debtToOffset += rAmountDebt.toOffset;\n        remainingStability.remaining -= rAmountDebt.toOffset;\n\n        uint offsetPercentage = (priceFeed.getUSDValue(rAmountDebt.tokenAddress, rAmountDebt.toOffset) *\n          DECIMAL_PRECISION) / troveDebtInUSDWithoutGasCompensation; // relative to the troves total debt\n\n        // moving the offsetPercentage of each coll into the stable pool\n        for (uint ii = 0; ii < troveAmountsIncludingRewards.length; ii++) {\n          RAmount memory rAmountColl = troveAmountsIncludingRewards[ii];\n          if (!rAmountColl.isColl) continue; // debt already handled one step above\n\n          rAmountColl.toOffset = (rAmountColl.toLiquidate * offsetPercentage) / DECIMAL_PRECISION;\n          rAmountColl.toRedistribute -= rAmountColl.toOffset;\n\n          // find the right collGained entry and add the value\n          for (uint iii = 0; iii < remainingStability.collGained.length; iii++) {\n            if (remainingStability.collGained[iii].tokenAddress != rAmountColl.tokenAddress) continue;\n\n            remainingStability.collGained[iii].amount += rAmountColl.toOffset;\n            break;\n          }\n        }\n      }\n\n      // remaining debt needs to be redistributed\n      rAmountDebt.toRedistribute = rAmountDebt.toLiquidate - rAmountDebt.toOffset;\n    }\n  }\n\n  function _sendGasCompensation(\n    address _liquidator,\n    uint _stableCoinGasCompensation,\n    TokenAmount[] memory _collGasCompensation\n  ) internal {\n    // stable payout\n    if (_stableCoinGasCompensation != 0) {\n      IDebtToken stableCoin = debtTokenManager.getStableCoin();\n      storagePool.withdrawalValue(\n        _liquidator,\n        address(stableCoin),\n        false,\n        PoolType.GasCompensation,\n        _stableCoinGasCompensation\n      );\n    }\n\n    // coll payout\n    for (uint i = 0; i < _collGasCompensation.length; i++) {\n      if (_collGasCompensation[i].amount == 0) continue;\n      storagePool.withdrawalValue(\n        _liquidator,\n        _collGasCompensation[i].tokenAddress,\n        true,\n        PoolType.Active,\n        _collGasCompensation[i].amount\n      );\n    }\n  }\n\n  function _emitLiquidationSummaryEvent(LocalVariables_OuterLiquidationFunction memory vars) internal {\n    TokenAmount[] memory liquidatedColl = new TokenAmount[](vars.collTokenAddresses.length);\n    for (uint i = 0; i < vars.collTokenAddresses.length; i++) {\n      liquidatedColl[i] = TokenAmount(\n        vars.collTokenAddresses[i],\n        vars.tokensToRedistribute[i].amount // works because of the initialisation of the array (first debts, then colls)\n      );\n    }\n\n    TokenAmount[] memory liquidatedDebt = new TokenAmount[](vars.remainingStabilities.length);\n    for (uint i = 0; i < vars.remainingStabilities.length; i++) {\n      RemainingStability memory remainingStability = vars.remainingStabilities[i];\n\n      uint redistributed = vars.tokensToRedistribute[vars.collTokenAddresses.length + i].amount; // has the same token order in the array\n      liquidatedDebt[i] = TokenAmount(remainingStability.tokenAddress, remainingStability.debtToOffset + redistributed);\n\n      for (uint ii = 0; ii < vars.collTokenAddresses.length; ii++) {\n        liquidatedColl[ii].amount += remainingStability.collGained[ii].amount;\n      }\n    }\n\n    emit LiquidationSummary(\n      liquidatedDebt,\n      liquidatedColl,\n      vars.totalStableCoinGasCompensation,\n      vars.totalCollGasCompensation\n    );\n  }\n}\n"
    },
    "contracts/Mock/MockBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../BorrowerOperations.sol';\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract MockBorrowerOperations is BorrowerOperations {\n  function increaseDebts(TokenAmount[] memory _debts, MintMeta memory _meta) external {\n    // separate minting is allowed for better testing\n    // _requireCallerIsSwapOperations();\n\n    _increaseDebt(msg.sender, msg.sender, _debts, _meta);\n  }\n\n  function mock_increaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external {\n    troveManager.increaseTroveColl(_borrower, _collTokenAmounts);\n  }\n\n  // Payable fallback function\n\n  // STORAGE POOL TESTER PROXIES\n  function testStoragePool_addValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) external {\n    storagePool.addValue(_tokenAddress, _isColl, _poolType, _amount);\n  }\n\n  function testStoragePool_subtractValue(\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _poolType,\n    uint _amount\n  ) external {\n    storagePool.subtractValue(_tokenAddress, _isColl, _poolType, _amount);\n  }\n\n  function testStoragePool_transferBetweenTypes(\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _fromType,\n    PoolType _toType,\n    uint _amount\n  ) external {\n    storagePool.transferBetweenTypes(_tokenAddress, _isColl, _fromType, _toType, _amount);\n  }\n\n  function testStoragePool_withdrawalValue(\n    address _receiver,\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _poolType,\n    uint _amount\n  ) external {\n    storagePool.withdrawalValue(_receiver, _tokenAddress, _isColl, _poolType, _amount);\n  }\n\n  // DEBTTOKEN TESTER PROXIES\n\n  function testDebtToken_mint(address _account, uint256 _amount, IDebtToken _debtToken) external {\n    _debtToken.mint(_account, _amount);\n  }\n\n  function testDebtToken_burn(address _account, uint256 _amount, IDebtToken _debtToken) external {\n    _debtToken.burn(_account, _amount);\n  }\n\n  // TROVE MANAGER TESTER PROXIES\n\n  function testTroveManager_increaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external {\n    troveManager.increaseTroveDebt(_borrower, _debtTokenAmounts);\n  }\n\n  function testTroveManager_setTroveStatus(address _borrower, uint _num) external {\n    troveManager.setTroveStatus(_borrower, _num);\n  }\n\n  function testTroveManager_closeTrove(address[] memory collTokenAddresses, address _borrower) external {\n    troveManager.closeTroveByProtocol(collTokenAddresses, _borrower, Status.closedByOwner);\n  }\n}\n"
    },
    "contracts/Mock/MockDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../DebtToken.sol';\n\ncontract MockDebtToken is DebtToken {\n  bytes32 private immutable _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n  constructor(\n    address _troveManagerAddress,\n    address _redeemerOperationsAddress,\n    address _borrowerOperationsAddress,\n    address _stabilityPoolManagerAddress,\n    address _debtTokenManagerAddress,\n    address _priceFeedAddress,    \n    string memory _symbol,\n    string memory _name,\n    string memory _version,\n    bool _isStableCoin\n  )\n    DebtToken(\n      _troveManagerAddress,\n      _redeemerOperationsAddress,\n      _borrowerOperationsAddress,\n      _stabilityPoolManagerAddress,\n      _debtTokenManagerAddress,\n      _priceFeedAddress,\n      _symbol,\n      _name,\n      _version,\n      _isStableCoin\n    )\n  {}\n\n  function unprotectedMint(address _account, uint256 _amount) external {\n    // No check on caller here\n    _mint(_account, _amount);\n  }\n\n  function unprotectedBurn(address _account, uint _amount) external {\n    // No check on caller here\n    _burn(_account, _amount);\n  }\n\n  function unprotectedSendToPool(address _sender, address _poolAddress, uint256 _amount) external {\n    // No check on caller here\n    _transfer(_sender, _poolAddress, _amount);\n  }\n\n  function callInternalApprove(address owner, address spender, uint256 amount) external {\n    _approve(owner, spender, amount);\n  }\n\n  function getChainId() external view returns (uint256 chainID) {\n    //return _chainID(); // it’s private\n    assembly {\n      chainID := chainid()\n    }\n  }\n\n  function getDigest(\n    address owner,\n    address spender,\n    uint amount,\n    uint nonce,\n    uint deadline\n  ) external view returns (bytes32) {\n    return\n      keccak256(\n        abi.encodePacked(\n          uint16(0x1901),\n          this.domainSeparator(),\n          keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, nonce, deadline))\n        )\n      );\n  }\n\n  function recoverAddress(bytes32 digest, uint8 v, bytes32 r, bytes32 s) external pure returns (address) {\n    bytes32 signedMsg = MessageHashUtils.toEthSignedMessageHash(digest);\n    address recoveredAddress = ECDSA.recover(signedMsg, v, r, s);\n    return recoveredAddress;\n  }\n}\n"
    },
    "contracts/Mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';\n\ncontract MockERC20 is ERC20Permit {\n  uint8 private _decimals;\n\n  constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol) ERC20Permit(name) {\n    _decimals = decimals_;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function unprotectedMint(address _account, uint256 _amount) external {\n    _mint(_account, _amount);\n  }\n}\n"
    },
    "contracts/Mock/MockLiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../Dependencies/LiquityMath.sol';\n\n/* Tester contract for math functions in Math.sol library. */\n\ncontract MockLiquityMath {\n  function callMax(uint _a, uint _b) external pure returns (uint) {\n    return LiquityMath._max(_a, _b);\n  }\n\n  // Non-view wrapper for gas test\n  function callDecPowTx(uint _base, uint _n) external pure returns (uint) {\n    return LiquityMath._decPow(_base, _n);\n  }\n\n  // External wrapper\n  function callDecPow(uint _base, uint _n) external pure returns (uint) {\n    return LiquityMath._decPow(_base, _n);\n  }\n}\n"
    },
    "contracts/Mock/MockPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../Interfaces/IPriceFeed.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\n/*\n * PriceFeed placeholder for testnet and development. The price is simply set manually and saved in a state\n * variable. The contract does not connect to a live Chainlink price feed.\n */\ncontract MockPriceFeed is IPriceFeed {\n  mapping(address => uint256) private tokenPrices;\n\n  // --- Functions ---\n\n  // View price getter for simplicity in tests\n  function getPrice(address _tokenAddress) external view override returns (uint price) {\n    // todo include priceCache into tests\n    //    // first try to get the price from the cache\n    //    for (uint i = 0; i < _priceCache.prices.length; i++) {\n    //      if (_priceCache.prices[i].tokenAddress != _tokenAddress) continue;\n    //\n    //      price = _priceCache.prices[i].amount;\n    //      if (price != 0) return price;\n    //    }\n\n    uint256 tokenPrice = tokenPrices[_tokenAddress];\n    if (tokenPrice != 0) return tokenPrice;\n    return 1e18; // 1$ as fallback\n  }\n\n  function setTokenPrice(address tokenAddress, uint256 price) external returns (bool) {\n    tokenPrices[tokenAddress] = price;\n    return true;\n  }\n\n  function getUSDValue(address _token, uint256 _amount) external view returns (uint usdValue) {\n    uint price = tokenPrices[_token];\n    uint8 decimals = IERC20Metadata(_token).decimals();\n    usdValue = (price * _amount) / 10 ** decimals;\n  }\n\n  function getAmountFromUSDValue(address _token, uint256 _usdValue) external view returns (uint amount) {\n    uint price = tokenPrices[_token];\n    uint8 decimals = IERC20Metadata(_token).decimals();\n    amount = (_usdValue * 10 ** decimals) / price;\n  }\n}\n"
    },
    "contracts/Mock/MockStabilityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../StabilityPoolManager.sol';\n\ncontract MockStabilityPoolManager is StabilityPoolManager {\n  // DEBTTOKEN TESTER PROXIES\n  function testDebtToken_sendToPool(\n    address _sender,\n    address _poolAddress,\n    uint256 _amount,\n    IDebtToken _debtToken\n  ) external {\n    _debtToken.sendToPool(_sender, _poolAddress, _amount);\n  }\n}\n"
    },
    "contracts/Mock/MockTroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '../TroveManager.sol';\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract MockTroveManager is TroveManager {\n  function computeICR(uint _coll, uint _debt) external pure returns (uint) {\n    return LiquityMath._computeCR(_coll, _debt);\n  }\n\n  function getCollGasCompensation(uint _coll) external pure returns (uint) {\n    return _getCollGasCompensation(_coll);\n  }\n\n  function getLiquidatedTokens(address tokenAddress, bool isColl) external view returns (uint) {\n    return liquidatedTokens[tokenAddress][isColl];\n  }\n\n  function setLastFeeOpTimeToNow() external {\n    lastFeeOperationTime = block.timestamp;\n  }\n\n  function setBaseRate(uint _baseRate) external {\n    stableCoinBaseRate = _baseRate;\n  }\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/ITellorCaller.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Dependencies/LiquityMath.sol';\n\ncontract PriceFeed is Ownable(msg.sender), CheckContract, IPriceFeed {\n  string public constant NAME = 'PriceFeed';\n  uint internal constant DECIMAL_PRECISION = 1e18;\n\n  //  ITellorCaller public tellorCaller;\n\n  // @dev The last good prices seen from an oracle by Apollon, prices in 18 decimals\n  mapping(address => uint) public lastGoodPrices;\n\n  // --- Dependency setters ---\n\n  function setAddresses() external onlyOwner {}\n\n  // --- Functions ---\n\n  function getPrice(address _tokenAddress) external view returns (uint price) {\n    price = lastGoodPrices[_tokenAddress];\n\n    if (price == 0) {\n      // TODO: fetch price\n    }\n  }\n\n  /**\n   * @notice Get USD value of given amount of token in 18 decimals\n   * @param _token Token Address to get USD value of\n   * @param _amount Amount of token to get USD value of\n   * @return usdValue USD value of given amount in 18 decimals\n   */\n  function getUSDValue(address _token, uint256 _amount) external view returns (uint usdValue) {\n    uint price = lastGoodPrices[_token];\n    uint8 decimals = IERC20Metadata(_token).decimals();\n    usdValue = (price * _amount) / 10 ** decimals;\n  }\n\n  function getAmountFromUSDValue(address _token, uint256 _usdValue) external view returns (uint amount) {\n    uint price = lastGoodPrices[_token];\n    uint8 decimals = IERC20Metadata(_token).decimals();\n    amount = (_usdValue * 10 ** decimals) / price;\n  }\n}\n"
    },
    "contracts/RedemptionOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IBBase.sol';\nimport './Interfaces/ICollTokenManager.sol';\nimport './Interfaces/IRedemptionOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ISortedTroves.sol';\n\ncontract RedemptionOperations is LiquityBase, Ownable(msg.sender), CheckContract, IRedemptionOperations {\n  string public constant NAME = 'RedemptionOperations';\n\n  // --- Connected contract declarations ---\n\n  ITroveManager public troveManager;\n  IDebtTokenManager public debtTokenManager;\n  ICollTokenManager public collTokenManager;\n  IStoragePool public storagePool;\n  IPriceFeed public priceFeed;\n  ISortedTroves public sortedTroves;\n\n  // --- Data structures ---\n\n  struct RedemptionVariables {\n    address[] collTokenAddresses;\n    RedemptionCollAmount[] totalCollDrawn;\n    //\n    uint totalStableSupplyAtStart;\n    uint totalRedeemedStable;\n  }\n\n  // --- Dependency setter ---\n\n  function setAddresses(\n    address _troveManagerAddress,\n    address _storagePoolAddress,\n    address _priceFeedAddress,\n    address _debtTokenManagerAddress,\n    address _collTokenManagerAddress,\n    address _sortedTrovesAddress\n  ) external onlyOwner {\n    checkContract(_troveManagerAddress);\n    checkContract(_storagePoolAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManagerAddress);\n    checkContract(_collTokenManagerAddress);\n    checkContract(_sortedTrovesAddress);\n\n    troveManager = ITroveManager(_troveManagerAddress);\n    storagePool = IStoragePool(_storagePoolAddress);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n    debtTokenManager = IDebtTokenManager(_debtTokenManagerAddress);\n    collTokenManager = ICollTokenManager(_collTokenManagerAddress);\n    sortedTroves = ISortedTroves(_sortedTrovesAddress);\n\n    emit RedemptionOperationsInitialized(\n      _troveManagerAddress,\n      _storagePoolAddress,\n      _priceFeedAddress,\n      _debtTokenManagerAddress,\n      _collTokenManagerAddress,\n      _sortedTrovesAddress\n    );\n\n    renounceOwnership();\n  }\n\n  function redeemCollateral(\n    uint _stableCoinAmount,\n    RedeemIteration[] memory _iterations,\n    uint _maxFeePercentage\n  ) external override {\n    IDebtToken stableCoin = debtTokenManager.getStableCoin();\n    RedemptionVariables memory vars;\n    vars.collTokenAddresses = collTokenManager.getCollTokenAddresses();\n    vars.totalStableSupplyAtStart =\n      storagePool.getValue(address(stableCoin), false, PoolType.Active) +\n      storagePool.getValue(address(stableCoin), false, PoolType.Default);\n\n    if (_stableCoinAmount == 0) revert ZeroAmount();\n    if (_maxFeePercentage < REDEMPTION_FEE_FLOOR || _maxFeePercentage > DECIMAL_PRECISION)\n      revert InvalidMaxFeePercent();\n    if (_stableCoinAmount > stableCoin.balanceOf(msg.sender)) revert ExceedDebtBalance();\n\n    (, uint TCR, , ) = storagePool.checkRecoveryMode();\n    if (TCR < MCR) revert LessThanMCR();\n\n    // Confirm redeemer's balance is less than total stable coin supply\n    assert(stableCoin.balanceOf(msg.sender) <= vars.totalStableSupplyAtStart);\n\n    // seed drawn coll\n    vars.totalCollDrawn = new RedemptionCollAmount[](vars.collTokenAddresses.length);\n    for (uint i = 0; i < vars.totalCollDrawn.length; i++) vars.totalCollDrawn[i].collToken = vars.collTokenAddresses[i];\n\n    for (uint i = 0; i < _iterations.length; i++) {\n      RedeemIteration memory iteration = _iterations[i];\n      checkValidRedemptionHint(iteration.trove);\n\n      troveManager.applyPendingRewards(iteration.trove);\n      SingleRedemptionVariables memory troveRedemption = calculateTroveRedemption(\n        iteration.trove,\n        _stableCoinAmount - vars.totalRedeemedStable,\n        false\n      );\n\n      // resulting CR differs from the expected CR, we bail in that case, because all following iterations will consume too much gas by searching for a updated hints\n      if (troveRedemption.resultingCR != iteration.expectedCR) break;\n\n      // updating the troves stable debt\n      DebtTokenAmount[] memory debtDecrease = new DebtTokenAmount[](1);\n      debtDecrease[0] = DebtTokenAmount(debtTokenManager.getStableCoin(), troveRedemption.stableCoinLot, 0);\n      troveManager.decreaseTroveDebt(iteration.trove, debtDecrease);\n\n      // updating the troves stable coll\n      troveManager.decreaseTroveColl(iteration.trove, troveRedemption.collLots);\n      troveManager.updateStakeAndTotalStakes(vars.collTokenAddresses, iteration.trove);\n\n      // update the troves position in the sorted list\n      // in case the trove was fully redeemed, it will be removed from the list\n      sortedTroves.update(\n        iteration.trove,\n        troveRedemption.resultingCR,\n        troveRedemption.stableCoinEntry.amount - troveRedemption.stableCoinLot - STABLE_COIN_GAS_COMPENSATION, // amount which is still redeemable from that trove (after the current one...)\n        iteration.upperHint,\n        iteration.lowerHint\n      );\n      emit RedeemedFromTrove(iteration.trove, troveRedemption.stableCoinLot, troveRedemption.collLots);\n\n      // sum up redeemed stable and drawn collateral\n      vars.totalRedeemedStable += troveRedemption.stableCoinLot;\n      for (uint a = 0; a < troveRedemption.collLots.length; a++) {\n        for (uint b = 0; b < vars.totalCollDrawn.length; b++) {\n          if (troveRedemption.collLots[a].tokenAddress != vars.collTokenAddresses[b]) continue;\n\n          vars.totalCollDrawn[b].drawn += troveRedemption.collLots[a].amount;\n          break;\n        }\n      }\n\n      // we have redeemed enough\n      if (_stableCoinAmount - vars.totalRedeemedStable == 0) break;\n    }\n\n    if (vars.totalRedeemedStable == 0) revert NoRedeems();\n\n    // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n    // Use the saved total stable supply value, from before it was reduced by the redemption.\n    troveManager.updateStableCoinBaseRateFromRedemption(vars.totalRedeemedStable, vars.totalStableSupplyAtStart);\n\n    // Calculate the redemption fee\n    for (uint i = 0; i < vars.totalCollDrawn.length; i++) {\n      RedemptionCollAmount memory collEntry = vars.totalCollDrawn[i];\n\n      collEntry.redemptionFee = _getRedemptionFee(collEntry.drawn);\n      collEntry.sendToRedeemer = collEntry.drawn - collEntry.redemptionFee;\n\n      _requireUserAcceptsFee(collEntry.redemptionFee, collEntry.drawn, _maxFeePercentage);\n    }\n\n    // Burn the total stable coin that is cancelled with debt, and send the redeemed coll to msg.sender\n    storagePool.subtractValue(address(stableCoin), false, PoolType.Active, vars.totalRedeemedStable);\n    stableCoin.burn(msg.sender, vars.totalRedeemedStable);\n\n    // transfer the drawn collateral to the redeemer\n    for (uint i = 0; i < vars.totalCollDrawn.length; i++) {\n      RedemptionCollAmount memory collEntry = vars.totalCollDrawn[i];\n      if (collEntry.sendToRedeemer == 0) continue;\n\n      storagePool.withdrawalValue(\n        msg.sender,\n        vars.collTokenAddresses[i],\n        true,\n        PoolType.Active,\n        collEntry.sendToRedeemer\n      );\n      storagePool.withdrawalValue(\n        GOV_STAKING_ADDRESS,\n        vars.collTokenAddresses[i],\n        true,\n        PoolType.Active,\n        collEntry.redemptionFee\n      );\n    }\n\n    emit SuccessfulRedemption(_stableCoinAmount, vars.totalRedeemedStable, vars.totalCollDrawn);\n  }\n\n  function checkValidRedemptionHint(address _redemptionHint) internal view {\n    if (!troveManager.isTroveActive(_redemptionHint)) revert HintUnknown();\n\n    // is case the sorted troves list is empty, all troves which minted stable are either redeemed or liquidated\n    // the remaining stable is now in \"pending rewards\" of non listed troves\n    if (sortedTroves.isEmpty()) return;\n\n    (uint hintCR, ) = troveManager.getCurrentICR(_redemptionHint);\n    if (hintCR < MCR) revert HintBelowMCR(); // should be liquidated, not redeemed from\n    if (!sortedTroves.contains(_redemptionHint)) revert InvalidRedemptionHint();\n\n    address nextTrove = sortedTroves.getNext(_redemptionHint);\n    (uint nextTroveCR, ) = troveManager.getCurrentICR(nextTrove);\n    if (nextTrove != address(0) && nextTroveCR > MCR) revert InvalidHintLowerCRExists();\n  }\n\n  function calculateTroveRedemption(\n    address _borrower,\n    uint _redeemMaxAmount,\n    bool _includePendingRewards\n  ) public view override returns (SingleRedemptionVariables memory vars) {\n    address stableCoinAddress = address(debtTokenManager.getStableCoin());\n\n    // stable coin debt should always exists because of the gas comp\n    TokenAmount[] memory troveDebt = _includePendingRewards\n      ? troveManager.getTroveRepayableDebts(_borrower, true) // with pending rewards\n      : troveManager.getTroveDebt(_borrower); // without pending rewards\n    if (troveDebt.length == 0) revert InvalidRedemptionHint();\n    for (uint i = 0; i < troveDebt.length; i++) {\n      TokenAmount memory debtEntry = troveDebt[i];\n\n      if (debtEntry.tokenAddress == stableCoinAddress) vars.stableCoinEntry = debtEntry;\n      vars.troveDebtInUSD += priceFeed.getUSDValue(debtEntry.tokenAddress, debtEntry.amount);\n    }\n\n    vars.collLots = _includePendingRewards\n      ? troveManager.getTroveWithdrawableColls(_borrower)\n      : troveManager.getTroveColl(_borrower);\n    for (uint i = 0; i < vars.collLots.length; i++)\n      vars.troveCollInUSD += priceFeed.getUSDValue(vars.collLots[i].tokenAddress, vars.collLots[i].amount);\n\n    // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n    vars.stableCoinLot = LiquityMath._min(_redeemMaxAmount, vars.stableCoinEntry.amount - STABLE_COIN_GAS_COMPENSATION);\n\n    // calculate the coll lot\n    uint newCollInUSD = vars.troveCollInUSD;\n    for (uint i = 0; i < vars.collLots.length; i++) {\n      TokenAmount memory collEntry = vars.collLots[i];\n\n      uint collEntryInUSD = priceFeed.getUSDValue(collEntry.tokenAddress, collEntry.amount);\n      uint collToRedeemInUSD = (vars.stableCoinLot * collEntryInUSD) / vars.troveCollInUSD;\n      collEntry.amount = priceFeed.getAmountFromUSDValue(collEntry.tokenAddress, collToRedeemInUSD);\n      newCollInUSD -= collToRedeemInUSD;\n    }\n\n    vars.resultingCR = LiquityMath._computeCR(newCollInUSD, vars.troveDebtInUSD - vars.stableCoinLot);\n    return vars;\n  }\n\n  function getRedemptionRate() public view override returns (uint) {\n    return _calcRedemptionRate(troveManager.getStableCoinBaseRate());\n  }\n\n  function getRedemptionRateWithDecay() public view override returns (uint) {\n    return _calcRedemptionRate(troveManager.calcDecayedStableCoinBaseRate());\n  }\n\n  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n    return\n      LiquityMath._min(\n        REDEMPTION_FEE_FLOOR + _baseRate,\n        DECIMAL_PRECISION // cap at a maximum of 100%\n      );\n  }\n\n  function _getRedemptionFee(uint _collDrawn) internal view returns (uint) {\n    return _calcRedemptionFee(getRedemptionRate(), _collDrawn);\n  }\n\n  function getRedemptionFeeWithDecay(uint _collDrawn) external view override returns (uint) {\n    return _calcRedemptionFee(getRedemptionRateWithDecay(), _collDrawn);\n  }\n\n  function _calcRedemptionFee(uint _redemptionRate, uint _collDrawn) internal pure returns (uint) {\n    if (_collDrawn == 0) return 0;\n\n    uint redemptionFee = (_redemptionRate * _collDrawn) / DECIMAL_PRECISION;\n    if (redemptionFee >= _collDrawn) revert TooHighRedeemFee(); // Fee would eat up all returned collateral\n    return redemptionFee;\n  }\n}\n"
    },
    "contracts/ReservePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\n\nimport './Interfaces/IReservePool.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\nimport './Interfaces/IPriceFeed.sol';\n\ncontract ReservePool is LiquityBase, Ownable(msg.sender), CheckContract, IReservePool {\n  string public constant NAME = 'ReservePool';\n\n  address public stabilityPoolManagerAddress;\n  IPriceFeed public priceFeed;\n\n  IDebtToken public stableDebtToken;\n  uint public relativeStableCap; // percentage of total issued stable coins\n\n  IERC20 public govToken;\n  uint public govReserveCap;\n\n  function setAddresses(\n    address _stabilityPoolManager,\n    address _priceFeed,\n    address _stableDebtTokenAddress,\n    address _govTokenAddress,\n    uint _relativeStableCap,\n    uint _govReserveCap\n  ) external onlyOwner {\n    checkContract(_stabilityPoolManager);\n    checkContract(_stableDebtTokenAddress);\n\n    stabilityPoolManagerAddress = _stabilityPoolManager;\n    priceFeed = IPriceFeed(_priceFeed);\n    stableDebtToken = IDebtToken(_stableDebtTokenAddress);\n    govToken = IERC20(_govTokenAddress);\n\n    relativeStableCap = _relativeStableCap;\n    govReserveCap = _govReserveCap;\n\n    emit ReservePoolInitialized(_stabilityPoolManager, _priceFeed, _stableDebtTokenAddress, _govTokenAddress);\n    emit ReserveCapChanged(_relativeStableCap, govReserveCap);\n  }\n\n  function setRelativeStableCap(uint _relativeStableCap) external onlyOwner {\n    relativeStableCap = _relativeStableCap;\n    emit ReserveCapChanged(relativeStableCap, govReserveCap);\n  }\n\n  function stableAmountUntilCap() external view returns (uint) {\n    uint totalStableSupply = stableDebtToken.totalSupply();\n    uint capTarget = (totalStableSupply * relativeStableCap) / DECIMAL_PRECISION;\n    uint stableBalance = stableDebtToken.balanceOf(address(this));\n\n    if (stableBalance >= capTarget) return 0;\n    return capTarget - stableBalance;\n  }\n\n  function isGovReserveCapReached() external view returns (bool) {\n    return govToken.balanceOf(address(this)) >= govReserveCap;\n  }\n\n  /**\n   * @notice Withdraw reserves to stability pool to repay possible loss when offset debts\n   * @dev Try to withdraw with gov tokens first, when not enough then stablecoins.\n   * @param stabilityPool Address of stability pool\n   * @param withdrawAmountInUSD USD value of amounts to withdraw (same as stable debt token amount)\n   * @return usedGov Gov token amount of withdrawn\n   * @return usedStable Stable token amount of withdrawn\n   */\n  function withdrawValue(\n    address stabilityPool,\n    uint withdrawAmountInUSD\n  ) external returns (uint usedGov, uint usedStable) {\n    _requireCallerIsStabilityPoolManager();\n\n    uint govDecimal = IERC20Metadata(address(govToken)).decimals();\n    uint govTokenPrice = priceFeed.getPrice(address(govToken));\n    usedGov = (withdrawAmountInUSD * 10 ** govDecimal) / govTokenPrice;\n    usedGov = Math.min(usedGov, govToken.balanceOf(address(this)));\n    govToken.transfer(stabilityPool, usedGov);\n\n    usedStable = withdrawAmountInUSD - (usedGov * govTokenPrice) / 10 ** govDecimal;\n    usedStable = Math.min(usedStable, stableDebtToken.balanceOf(address(this)));\n    stableDebtToken.transfer(stabilityPool, usedStable);\n\n    emit WithdrewReserves(usedGov, usedStable);\n  }\n\n  function _requireCallerIsStabilityPoolManager() internal view {\n    if (msg.sender != stabilityPoolManagerAddress) revert NotFromSPM();\n  }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/IBorrowerOperations.sol';\n\nimport 'hardhat/console.sol';\n\ncontract SortedTroves is Ownable(msg.sender), CheckContract, ISortedTroves {\n  string public constant NAME = 'SortedTroves';\n\n  address public borrowerOperationsAddress;\n  address public troveManagerAddress;\n  address public redemptionOperationsAddress;\n\n  struct Node {\n    uint listIndex;\n    bool exists;\n    uint usedCR; // nodes CR when it was last used (inserted or reinserted into the list)\n    address nextId; // Id of next node (smaller CR) in the list\n    address prevId; // Id of previous node (larger CR) in the list\n  }\n  struct Data {\n    address head; // Head of the list. Also the node in the list with the largest CR\n    address tail; // Tail of the list. Also the node in the list with the smallest CR\n    mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n    address[] list; // List of ids in the list\n  }\n  Data public data;\n\n  // --- Contract setters ---\n\n  function setAddresses(\n    address _troveManagerAddress,\n    address _borrowerOperationsAddress,\n    address _redemptionOperationsAddress\n  ) external onlyOwner {\n    checkContract(_troveManagerAddress);\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_redemptionOperationsAddress);\n\n    troveManagerAddress = _troveManagerAddress;\n    borrowerOperationsAddress = _borrowerOperationsAddress;\n    redemptionOperationsAddress = _redemptionOperationsAddress;\n\n    emit SortedTrovesInitialised(_troveManagerAddress, _borrowerOperationsAddress, _redemptionOperationsAddress);\n    renounceOwnership();\n  }\n\n  /*\n   * @dev Re-insert the node at a new position, based on its new CR\n   * @param _id Node's id\n   * @param _newCR Node's new CR\n   * @param _redeemableDebt Amount of stablecoin minted by the node\n   * @param _prevId Id of previous node for the new insert position\n   * @param _nextId Id of next node for the new insert position\n   */\n  function update(address _id, uint _CR, uint _redeemableDebt, address _prevId, address _nextId) external override {\n    _requireCallerIsProtocol();\n    _remove(_id);\n\n    // only included troves which minted some stable into the list\n    if (_redeemableDebt == 0) return;\n\n    if (contains(_id)) revert ListAlreadyContainsNode();\n    if (_id == address(0)) revert IdCantBeZero();\n    if (_CR == 0) revert CRNotPositive();\n\n    address prevId = _prevId;\n    address nextId = _nextId;\n    if (!_validInsertPosition(_CR, prevId, nextId)) {\n      // Sender's hint was not a valid insert position\n      // Use sender's hint to find a valid insert position\n      (prevId, nextId) = _findInsertPosition(_CR, prevId, nextId);\n    }\n\n    if (prevId == address(0) && nextId == address(0)) {\n      // Insert as head and tail\n      data.head = _id;\n      data.tail = _id;\n    } else if (prevId == address(0)) {\n      // Insert before `prevId` as the head\n      data.nodes[_id].nextId = data.head;\n      data.nodes[data.head].prevId = _id;\n      data.head = _id;\n    } else if (nextId == address(0)) {\n      // Insert after `nextId` as the tail\n      data.nodes[_id].prevId = data.tail;\n      data.nodes[data.tail].nextId = _id;\n      data.tail = _id;\n    } else {\n      // Insert at insert position between `prevId` and `nextId`\n      data.nodes[_id].nextId = nextId;\n      data.nodes[_id].prevId = prevId;\n      data.nodes[prevId].nextId = _id;\n      data.nodes[nextId].prevId = _id;\n    }\n\n    data.nodes[_id].exists = true;\n    data.nodes[_id].usedCR = _CR;\n    data.nodes[_id].listIndex = data.list.length;\n    data.list.push(_id);\n\n    emit NodeAdded(_id, _CR);\n  }\n\n  function remove(address _id) external override {\n    _requireCallerIsProtocol();\n    _remove(_id);\n  }\n\n  /*\n   * @dev Remove a node from the list\n   * @param _id Node's id\n   */\n  function _remove(address _id) internal {\n    // List must contain the node\n    if (!contains(_id)) return;\n\n    if (data.list.length > 1) {\n      // List contains more than a single node\n      if (_id == data.head) {\n        // The removed node is the head\n        // Set head to next node\n        data.head = data.nodes[_id].nextId;\n        // Set prev pointer of new head to null\n        data.nodes[data.head].prevId = address(0);\n      } else if (_id == data.tail) {\n        // The removed node is the tail\n        // Set tail to previous node\n        data.tail = data.nodes[_id].prevId;\n        // Set next pointer of new tail to null\n        data.nodes[data.tail].nextId = address(0);\n      } else {\n        // The removed node is neither the head nor the tail\n        // Set next pointer of previous node to the next node\n        data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\n        // Set prev pointer of next node to the previous node\n        data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\n      }\n\n      uint toRemoveIndex = data.nodes[_id].listIndex;\n      if (toRemoveIndex < data.list.length) {\n        data.list[toRemoveIndex] = data.list[data.list.length - 1];\n        data.nodes[data.list[toRemoveIndex]].listIndex = toRemoveIndex;\n      }\n      data.list.pop();\n    } else {\n      // List contains a single node\n      // Set the head and tail to null\n      data.head = address(0);\n      data.tail = address(0);\n      data.list.pop();\n    }\n\n    delete data.nodes[_id];\n    emit NodeRemoved(_id);\n  }\n\n  /*\n   * @dev Check if a pair of nodes is a valid insertion point for a new node with the given CR\n   * @param _CR Node's CR\n   * @param _prevId Id of previous node for the insert position\n   * @param _nextId Id of next node for the insert position\n   */\n  function validInsertPosition(uint _CR, address _prevId, address _nextId) external view override returns (bool) {\n    return _validInsertPosition(_CR, _prevId, _nextId);\n  }\n\n  function _validInsertPosition(uint _CR, address _prevId, address _nextId) internal view returns (bool) {\n    // `(null, null)` is a valid insert position if the list is empty\n    if (_prevId == address(0) && _nextId == address(0)) return isEmpty();\n\n    // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n    uint nextCR = data.nodes[_nextId].usedCR;\n    if (_prevId == address(0)) return data.head == _nextId && _CR >= nextCR;\n\n    // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n    uint prevCR = data.nodes[_prevId].usedCR;\n    if (_nextId == address(0)) return data.tail == _prevId && _CR <= prevCR;\n\n    // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_CR` falls between the two nodes' CRs\n    return data.nodes[_prevId].nextId == _nextId && prevCR >= _CR && _CR >= nextCR;\n  }\n\n  /*\n   * @dev Find the insert position for a new node with the given CR\n   * @param _CR Node's CR\n   * @param _prevId Id of previous node for the insert position\n   * @param _nextId Id of next node for the insert position\n   */\n  function findInsertPosition(\n    uint _CR,\n    address _prevId,\n    address _nextId\n  ) external view override returns (address, address) {\n    return _findInsertPosition(_CR, _prevId, _nextId);\n  }\n\n  function _findInsertPosition(uint _CR, address _prevId, address _nextId) internal view returns (address, address) {\n    address prevId = _prevId;\n    address nextId = _nextId;\n\n    // `prevId` / `nextId` does not exist anymore or now has a smaller CR than the given CR\n    if (prevId != address(0) && (!contains(prevId) || _CR > data.nodes[prevId].usedCR)) prevId = address(0);\n    if (nextId != address(0) && (!contains(nextId) || _CR < data.nodes[nextId].usedCR)) nextId = address(0);\n\n    // No hint - descend list starting from head\n    if (prevId == address(0) && nextId == address(0)) return _descendList(_CR, data.head);\n\n    // No `prevId` for hint - ascend list starting from `nextId`\n    if (prevId == address(0)) return _ascendList(_CR, nextId);\n\n    // No `nextId` for hint - descend list starting from `prevId`\n    if (nextId == address(0)) return _descendList(_CR, prevId);\n\n    // Descend list starting from `prevId`\n    return _descendList(_CR, prevId);\n  }\n\n  /*\n   * @dev Descend the list (larger CRs to smaller CRs) to find a valid insert position\n   * @param _CR Node's CR\n   * @param _startId Id of node to start descending the list from\n   */\n  function _descendList(uint _CR, address _startId) internal view returns (address, address) {\n    // If `_startId` is the head, check if the insert position is before the head\n    if (data.head == _startId && _CR >= data.nodes[_startId].usedCR) return (address(0), _startId);\n\n    address prevId = _startId;\n    address nextId = data.nodes[prevId].nextId;\n\n    // Descend the list until we reach the end or until we find a valid insert position\n    while (prevId != address(0) && !_validInsertPosition(_CR, prevId, nextId)) {\n      prevId = data.nodes[prevId].nextId;\n      nextId = data.nodes[prevId].nextId;\n    }\n\n    return (prevId, nextId);\n  }\n\n  /*\n   * @dev Ascend the list (smaller CRs to larger CRs) to find a valid insert position\n   * @param _CR Node's CR\n   * @param _startId Id of node to start ascending the list from\n   */\n  function _ascendList(uint _CR, address _startId) internal view returns (address, address) {\n    // If `_startId` is the tail, check if the insert position is after the tail\n    if (data.tail == _startId && _CR <= data.nodes[_startId].usedCR) return (_startId, address(0));\n\n    address nextId = _startId;\n    address prevId = data.nodes[nextId].prevId;\n\n    // Ascend the list until we reach the end or until we find a valid insertion point\n    while (nextId != address(0) && !_validInsertPosition(_CR, prevId, nextId)) {\n      nextId = data.nodes[nextId].prevId;\n      prevId = data.nodes[nextId].prevId;\n    }\n\n    return (prevId, nextId);\n  }\n\n  // --- 'require' functions ---\n\n  function _requireCallerIsProtocol() internal view {\n    if (\n      msg.sender != borrowerOperationsAddress &&\n      msg.sender != troveManagerAddress &&\n      msg.sender != redemptionOperationsAddress\n    ) revert CallerNotBrOrTrContract();\n  }\n\n  // --- Getters ---\n\n  /*\n   * @dev Checks if the list contains a node\n   */\n  function contains(address _id) public view override returns (bool) {\n    return data.nodes[_id].exists;\n  }\n\n  /*\n   * @dev Checks if the list is empty\n   */\n  function isEmpty() public view override returns (bool) {\n    return data.list.length == 0;\n  }\n\n  /*\n   * @dev Returns the current size of the list\n   */\n  function getSize() external view override returns (uint256) {\n    return data.list.length;\n  }\n\n  /*\n   * @dev Returns the first node in the list (node with the largest CR)\n   */\n  function getFirst() external view override returns (address) {\n    return data.head;\n  }\n\n  /*\n   * @dev Returns the last node in the list (node with the smallest CR)\n   */\n  function getLast() external view override returns (address) {\n    return data.tail;\n  }\n\n  /*\n   * @dev Returns the next node (with a smaller CR) in the list for a given node\n   * @param _id Node's id\n   */\n  function getNext(address _id) external view override returns (address) {\n    return data.nodes[_id].nextId;\n  }\n\n  /*\n   * @dev Returns the previous node (with a larger CR) in the list for a given node\n   * @param _id Node's id\n   */\n  function getPrev(address _id) external view override returns (address) {\n    return data.nodes[_id].prevId;\n  }\n\n  function getByIndex(uint _index) external view override returns (address) {\n    return data.list[_index];\n  }\n\n  function getUsedCR(address _id) external view override returns (uint) {\n    return data.nodes[_id].usedCR;\n  }\n}\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\n\n/*\n * The Stability Pool holds debt tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its debt gets offset with\n * token in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of debt tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a debt token loss, in proportion to their deposit as a share of total deposits.\n * Calculated separately by debt token groups.\n * They also receive a coll token gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total debt token in the Stability Pool, depletes 40% of each deposit (of the same token).\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and coll gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and gains, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion LUSD has depleted to < 1 LUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S GAINS OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated gain, during the epoch in which the deposit was non-zero and earned gains.\n *\n * We calculate the depositor's accumulated gains for the scale at which they made the deposit, using the gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated gains, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An LQTY issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track LQTY gains for depositors, where 'G' is the sum corresponding to LQTY gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is LiquityBase, CheckContract, IStabilityPool {\n  string public constant NAME = 'StabilityPool';\n\n  address public stabilityPoolManagerAddress;\n\n  // --- Data structures ---\n\n  IDebtToken public depositToken;\n  uint256 public totalDeposits;\n\n  struct Snapshots {\n    mapping(address => uint) sums; // [coll token address] -> snapshot of S(um)\n    uint P;\n    uint128 scale;\n    uint128 epoch;\n  }\n  mapping(address => Snapshots) public depositSnapshots; // [depositor address] -> snapshots struct\n  mapping(address => uint) public deposits; // [depositor address] -> deposit amount\n\n  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n   * after a series of liquidations have occurred, each of which cancel some debt with the deposit.\n   *\n   * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n   * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n   */\n  uint public P = DECIMAL_PRECISION;\n\n  uint public constant SCALE_FACTOR = 1e9;\n  uint128 public currentScale; // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n  uint128 public currentEpoch; // With each offset that fully empties the Pool, the epoch is incremented by 1\n\n  /*Gains sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n   * is the depositor's snapshot of S taken at the time t when the deposit was made.\n   *\n   * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n   *\n   * - The inner mapping records the sum S at different scales\n   * - The outer mapping records the (scale => sum) mappings, for different epochs.\n   */\n\n  address[] public usedCollTokens;\n  mapping(address => uint) public totalGainedColl; // [token address] -> total gained collateral\n  mapping(uint128 => mapping(uint128 => mapping(address => uint))) public epochToScaleToCollTokenToSum; // [epoch][scale][collTokenAddress] => sum\n\n  mapping(address => uint) public lastErrorOffset; // [tokenAddress] value, Error trackers for the error correction in the offset calculation\n\n  constructor(address _stabilityPoolManagerAddress, address _depositTokenAddress) {\n    checkContract(_stabilityPoolManagerAddress);\n    checkContract(_depositTokenAddress);\n\n    stabilityPoolManagerAddress = _stabilityPoolManagerAddress;\n    depositToken = IDebtToken(_depositTokenAddress);\n\n    emit StabilityPoolInitialized(_stabilityPoolManagerAddress, _depositTokenAddress);\n  }\n\n  // --- Getters for public variables. Required by IPool interface ---\n\n  function getTotalGainedColl() external view override returns (TokenAmount[] memory coll) {\n    coll = new TokenAmount[](usedCollTokens.length);\n    for (uint i = 0; i < usedCollTokens.length; i++) {\n      coll[i].tokenAddress = usedCollTokens[i];\n      coll[i].amount = totalGainedColl[usedCollTokens[i]];\n    }\n    return coll;\n  }\n\n  function getTotalDeposit() external view override returns (uint) {\n    return totalDeposits;\n  }\n\n  function getDepositToken() external view override returns (IDebtToken) {\n    return depositToken;\n  }\n\n  function getDepositorCollSnapshot(address _depositor, address _collToken) external view override returns (uint) {\n    return depositSnapshots[_depositor].sums[_collToken];\n  }\n\n  // --- External Depositor Functions ---\n\n  /*  provideToSP():\n   * - Triggers a GOV issuance, based on time passed since the last issuance. The GOV issuance is shared between *all* depositors\n   * - Sends depositor's accumulated gains to depositor\n   * - Increases deposit stake, and takes new snapshots.\n   */\n  function provideToSP(address depositor, uint _amount) external override {\n    _requireCallerIsStabilityPoolManager();\n    _requireNonZeroAmount(_amount);\n\n    uint remainingDeposit = getCompoundedDebtDeposit(depositor);\n    _payoutCollGains(depositor, remainingDeposit);\n\n    totalDeposits += _amount;\n\n    // update deposit snapshots\n    uint newDeposit = remainingDeposit + _amount;\n    _updateDepositAndSnapshots(depositor, newDeposit);\n\n    emit StabilityProvided(depositor, _amount);\n  }\n\n  /*  withdrawFromSP():\n   * - Sends all depositor's accumulated gains to depositor\n   * - Decreases deposit and takes new snapshots.\n   * - If _amount > userDeposit, the user withdraws all of their compounded deposit.\n   */\n  function withdrawFromSP(address user, uint depositToWithdrawal) external override {\n    _requireCallerIsStabilityPoolManager();\n\n    uint remainingDeposit = getCompoundedDebtDeposit(user);\n    depositToWithdrawal = LiquityMath._min(depositToWithdrawal, remainingDeposit);\n    if (depositToWithdrawal == 0) return;\n\n    // coll gain and deposit payout\n    _payoutCollGains(user, remainingDeposit);\n\n    depositToken.transfer(user, depositToWithdrawal);\n    totalDeposits -= depositToWithdrawal;\n\n    // update current deposit snapshot\n    uint newDeposit = remainingDeposit - depositToWithdrawal;\n    _updateDepositAndSnapshots(user, newDeposit);\n\n    emit StabilityWithdrawn(user, depositToWithdrawal);\n  }\n\n  /* withdrawGains:\n   * - Triggers a GOV issuance, based on time passed since the last issuance. The GOV issuance is shared between *all* depositors\n   * - Sends all depositor's GOV gain to depositor\n   * - Transfers the depositor's entire gains to its wallet\n   * - Leaves their compounded deposit in the Stability Pool\n   * - Updates snapshots for deposit stake */\n  function withdrawGains(address user) external override {\n    _requireCallerIsStabilityPoolManager();\n\n    // coll gain payout\n    uint remainingDeposit = getCompoundedDebtDeposit(user);\n    _payoutCollGains(user, remainingDeposit);\n\n    // update deposit snapshots\n    _updateDepositAndSnapshots(user, remainingDeposit);\n  }\n\n  //    // --- GOV issuance functions ---\n  //\n  //    function _triggerLQTYIssuance(ICommunityIssuance _communityIssuance) internal {\n  //        uint LQTYIssuance = _communityIssuance.issueLQTY();\n  //       _updateG(LQTYIssuance);\n  //    }\n  //\n  //    function _updateG(uint _LQTYIssuance) internal {\n  //        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n  //        /*\n  //        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later\n  //        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n  //        *\n  //        */\n  //        if (totalLUSD == 0 || _LQTYIssuance == 0) {return;}\n  //\n  //        uint LQTYPerUnitStaked;\n  //        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n  //\n  //        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n  //        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n  //\n  //        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n  //    }\n  //\n  //    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n  //        /*\n  //        * Calculate the LQTY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n  //        * cumulative error low in the running total G:\n  //        *\n  //        * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n  //        * function was called.\n  //        * 2) Calculate \"per-unit-staked\" ratio.\n  //        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n  //        * 4) Store this error for use in the next correction when this function is called.\n  //        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n  //        */\n  //        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n  //\n  //        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n  //        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n  //\n  //        return LQTYPerUnitStaked;\n  //    }\n  //\n  //    function _payOutLQTYGains(ICommunityIssuance _communityIssuance, address _depositor) internal {\n  //        // Pay out depositor's LQTY gain\n  //        uint depositorLQTYGain = getDepositorLQTYGain(_depositor);\n  //        _communityIssuance.sendLQTY(_depositor, depositorLQTYGain);\n  //        emit LQTYPaidToDepositor(_depositor, depositorLQTYGain);\n  //    }\n  //\n  //    /*\n  //* Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n  //* Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n  //* where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n  //* d0 is the last recorded deposit value.\n  //*/\n  //    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n  //        uint initialDeposit = deposits[_depositor].initialValue;\n  //        if (initialDeposit == 0) {return 0;}\n  //\n  //        Snapshots storage snapshots = depositSnapshots[_depositor];\n  //        uint LQTYGain = _getLQTYGainFromSnapshots(initialDeposit, snapshots);\n  //        return LQTYGain;\n  //    }\n  //\n  //    function _getLQTYGainFromSnapshots(uint initialStake, Snapshots storage snapshots) internal view returns (uint) {\n  //        /*\n  //         * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.\n  //         * If it does, the second portion of the LQTY gain is scaled by 1e9.\n  //         * If the gain spans no scale change, the second portion will be 0.\n  //         */\n  //        uint128 epochSnapshot = snapshots.epoch;\n  //        uint128 scaleSnapshot = snapshots.scale;\n  //        uint G_Snapshot = snapshots.G;\n  //        uint P_Snapshot = snapshots.P;\n  //\n  //        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n  //        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(SCALE_FACTOR);\n  //\n  //        uint LQTYGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n  //\n  //        return LQTYGain;\n  //    }\n\n  // --- Liquidation functions ---\n\n  /*\n   * Cancels out the specified debt against the tokens contained in the Stability Pool (as far as possible)\n   * and transfers the Trove's collateral from ActivePool to StabilityPool.\n   * Only called by liquidation functions in the TroveManager.\n   */\n  function offset(uint _debtToOffset, TokenAmount[] memory _collToAdd) external override {\n    _requireCallerIsStabilityPoolManager();\n\n    uint _totalDeposits = totalDeposits;\n    if (_totalDeposits == 0) return;\n\n    // adding coll token address into the usedCollTokens array, if they are not already there\n    for (uint i = 0; i < _collToAdd.length; i++) {\n      TokenAmount memory collEntry = _collToAdd[i];\n\n      bool found = false;\n      for (uint ii = 0; ii < usedCollTokens.length; ii++) {\n        if (usedCollTokens[ii] != collEntry.tokenAddress) continue;\n        found = true;\n        break;\n      }\n      if (!found) usedCollTokens.push(collEntry.tokenAddress);\n    }\n\n    (TokenAmount[] memory collGainPerUnitStaked, uint depositLossPerUnitStaked) = _computeRewardsPerUnitStaked(\n      _collToAdd,\n      _debtToOffset,\n      _totalDeposits\n    );\n\n    _updateRewardSumAndProduct(collGainPerUnitStaked, depositLossPerUnitStaked); // updates S and P\n\n    totalDeposits -= _debtToOffset;\n    emit StabilityOffset(_debtToOffset, _collToAdd);\n  }\n\n  function _computeRewardsPerUnitStaked(\n    TokenAmount[] memory _collToAdd,\n    uint _depositToOffset,\n    uint _totalDeposits\n  ) internal returns (TokenAmount[] memory collGainPerUnitStaked, uint depositLossPerUnitStaked) {\n    /*\n     * Compute the rewards. Uses a \"feedback\" error correction, to keep\n     * the cumulative error in the P and S state variables low:\n     *\n     * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n     * function was called.\n     * 2) Calculate \"per-unit-staked\" ratios.\n     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store these errors for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n     */\n\n    assert(_depositToOffset <= _totalDeposits);\n\n    collGainPerUnitStaked = new TokenAmount[](_collToAdd.length);\n    for (uint i = 0; i < _collToAdd.length; i++) {\n      address tokenAddress = _collToAdd[i].tokenAddress;\n      collGainPerUnitStaked[i].tokenAddress = tokenAddress;\n\n      uint collNumerator = _collToAdd[i].amount * DECIMAL_PRECISION + lastErrorOffset[tokenAddress];\n      collGainPerUnitStaked[i].amount = collNumerator / _totalDeposits;\n      lastErrorOffset[tokenAddress] = collNumerator - (collGainPerUnitStaked[i].amount * _totalDeposits);\n\n      totalGainedColl[tokenAddress] += _collToAdd[i].amount;\n    }\n\n    if (_depositToOffset == _totalDeposits) {\n      depositLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n      lastErrorOffset[address(depositToken)] = 0;\n    } else {\n      uint depositLossNumerator = _depositToOffset * DECIMAL_PRECISION - lastErrorOffset[address(depositToken)];\n      /*\n       * Add 1 to make error in quotient positive. We want \"slightly too much\" deposit loss,\n       * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool.\n       */\n      depositLossPerUnitStaked = depositLossNumerator / _totalDeposits + 1;\n      lastErrorOffset[address(depositToken)] = depositLossPerUnitStaked * _totalDeposits - depositLossNumerator;\n    }\n\n    return (collGainPerUnitStaked, depositLossPerUnitStaked);\n  }\n\n  // Update the Stability Pool reward sum S and product P\n  function _updateRewardSumAndProduct(\n    TokenAmount[] memory collGainPerUnitStaked,\n    uint depositLossPerUnitStaked\n  ) internal {\n    assert(depositLossPerUnitStaked <= DECIMAL_PRECISION);\n\n    /*\n     * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool deposit in the liquidation.\n     * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - depositLossPerUnitStaked)\n     */\n\n    uint currentP = P;\n\n    uint newP;\n    uint128 currentScaleCached = currentScale;\n    uint128 currentEpochCached = currentEpoch;\n\n    /*\n     * Calculate the new S first, before we update P.\n     * The coll gain for any given depositor from a liquidation depends on the value of their deposit\n     * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n     *\n     * Since S corresponds to coll gain, and P to deposit loss, we update S first.\n     */\n    for (uint i = 0; i < collGainPerUnitStaked.length; i++) {\n      address tokenAddress = collGainPerUnitStaked[i].tokenAddress;\n      uint currentS = epochToScaleToCollTokenToSum[currentEpochCached][currentScaleCached][tokenAddress];\n      uint marginalCollGain = collGainPerUnitStaked[i].amount * currentP;\n      uint newS = currentS + marginalCollGain;\n      epochToScaleToCollTokenToSum[currentEpochCached][currentScaleCached][tokenAddress] = newS;\n      emit S_Updated(tokenAddress, newS, currentEpochCached, currentScaleCached);\n    }\n\n    // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n    uint newProductFactor = uint(DECIMAL_PRECISION) - depositLossPerUnitStaked;\n    if (newProductFactor == 0) {\n      currentEpoch = currentEpochCached + 1;\n      emit EpochUpdated(currentEpoch);\n      currentScale = 0;\n      emit ScaleUpdated(currentScale);\n      newP = DECIMAL_PRECISION;\n\n      // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n    } else if ((currentP * newProductFactor) / DECIMAL_PRECISION < SCALE_FACTOR) {\n      newP = (currentP * newProductFactor * SCALE_FACTOR) / DECIMAL_PRECISION;\n      currentScale = currentScaleCached + 1;\n      emit ScaleUpdated(currentScale);\n    } else {\n      newP = (currentP * newProductFactor) / DECIMAL_PRECISION;\n    }\n\n    assert(newP > 0);\n    P = newP;\n    emit P_Updated(newP);\n  }\n\n  // --- Reward calculator functions ---\n\n  function _payoutCollGains(address _depositor, uint remainingDeposit) internal {\n    TokenAmount[] memory collGains = new TokenAmount[](usedCollTokens.length);\n    for (uint i = 0; i < usedCollTokens.length; i++) {\n      address collTokenAddress = usedCollTokens[i];\n      uint collGain = getDepositorCollGain(_depositor, collTokenAddress);\n      if (collGain == 0) continue;\n\n      totalGainedColl[collTokenAddress] -= collGain;\n      IERC20(collTokenAddress).transfer(_depositor, collGain);\n      collGains[i] = TokenAmount(collTokenAddress, collGain);\n    }\n\n    uint initialDeposit = deposits[_depositor];\n    uint depositLoss = initialDeposit - remainingDeposit;\n    emit StabilityGainsWithdrawn(_depositor, depositLoss, collGains);\n  }\n\n  /* Calculates the gains earned by the deposit since its last snapshots were taken.\n   * Given by the formula:  E = d0 * (S - S(0))/P(0)\n   * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n   * d0 is the last recorded deposit value.\n   */\n  function getDepositorCollGain(address _depositor, address _collToken) public view override returns (uint collGain) {\n    uint initialDeposit = deposits[_depositor];\n    if (initialDeposit == 0) return 0;\n\n    Snapshots storage snapshots = depositSnapshots[_depositor];\n    collGain = _getCollGainFromSnapshots(initialDeposit, _collToken, snapshots);\n    return collGain;\n  }\n\n  function _getCollGainFromSnapshots(\n    uint initialDeposit,\n    address collToken,\n    Snapshots storage snapshots\n  ) internal view returns (uint) {\n    /*\n     * Grab the sum 'S' from the epoch at which the stake was made. The coll gain may span up to one scale change.\n     * If it does, the second portion of the gain is scaled by 1e9.\n     * If the gain spans no scale change, the second portion will be 0.\n     */\n    uint128 epochSnapshot = snapshots.epoch;\n    uint128 scaleSnapshot = snapshots.scale;\n    uint firstPortion = epochToScaleToCollTokenToSum[epochSnapshot][scaleSnapshot][collToken] -\n      snapshots.sums[collToken];\n    uint secondPortion = epochToScaleToCollTokenToSum[epochSnapshot][scaleSnapshot + 1][collToken] / SCALE_FACTOR;\n\n    uint collGain = (initialDeposit * (firstPortion + secondPortion)) / snapshots.P / DECIMAL_PRECISION;\n    return collGain;\n  }\n\n  // --- Compounded deposit ---\n\n  function getDepositorDeposit(address _depositor) external view override returns (uint) {\n    return deposits[_depositor];\n  }\n\n  /*\n   * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n   * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n   */\n  function getCompoundedDebtDeposit(address _depositor) public view override returns (uint) {\n    uint initialDeposit = deposits[_depositor];\n    if (initialDeposit == 0) return 0;\n\n    Snapshots storage snapshots = depositSnapshots[_depositor];\n    uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n    return compoundedDeposit;\n  }\n\n  // Internal function, used to calculcate compounded deposits.\n  function _getCompoundedStakeFromSnapshots(\n    uint _initialStake,\n    Snapshots storage _snapshots\n  ) internal view returns (uint) {\n    // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n    if (_snapshots.epoch < currentEpoch) return 0;\n\n    uint compoundedStake;\n    uint128 scaleDiff = currentScale - _snapshots.scale;\n\n    /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n     * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n     * at least 1e-9 -- so return 0.\n     */\n    if (scaleDiff == 0) compoundedStake = (_initialStake * P) / _snapshots.P;\n    else if (scaleDiff == 1) compoundedStake = (_initialStake * P) / _snapshots.P / SCALE_FACTOR;\n    else compoundedStake = 0; // if scaleDiff >= 2\n\n    /*\n     * If compounded deposit is less than a billionth of the initial deposit, return 0.\n     *\n     * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n     * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n     * than it's theoretical value.\n     *\n     * Thus it's unclear whether this line is still really needed.\n     */\n    if (compoundedStake < _initialStake / 1e9) return 0;\n\n    return compoundedStake;\n  }\n\n  // --- Stability Pool Deposit Functionality ---\n\n  function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n    deposits[_depositor] = _newValue;\n\n    if (_newValue == 0) {\n      delete depositSnapshots[_depositor];\n      emit DepositSnapshotUpdated(_depositor);\n      return;\n    }\n\n    uint128 currentScaleCached = currentScale;\n    depositSnapshots[_depositor].scale = currentScaleCached;\n\n    uint128 currentEpochCached = currentEpoch;\n    depositSnapshots[_depositor].epoch = currentEpochCached;\n\n    uint currentP = P;\n    depositSnapshots[_depositor].P = currentP;\n\n    for (uint i = 0; i < usedCollTokens.length; i++) {\n      depositSnapshots[_depositor].sums[usedCollTokens[i]] = epochToScaleToCollTokenToSum[currentEpochCached][\n        currentScaleCached\n      ][usedCollTokens[i]];\n    }\n\n    emit DepositSnapshotUpdated(_depositor);\n  }\n\n  // --- 'require' functions ---\n\n  function _requireCallerIsStabilityPoolManager() internal view {\n    if (msg.sender != stabilityPoolManagerAddress) revert NotFromStabilityPoolManager();\n  }\n\n  function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n    if (_initialDeposit == 0) revert ZeroAmount();\n  }\n\n  function _requireNonZeroAmount(uint _amount) internal pure {\n    if (_amount == 0) revert ZeroAmount();\n  }\n}\n"
    },
    "contracts/StabilityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IReservePool.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './StabilityPool.sol';\n\ncontract StabilityPoolManager is Ownable(msg.sender), CheckContract, IStabilityPoolManager {\n  string public constant NAME = 'StabilityPoolManager';\n\n  address public liquidationOperationsAddress;\n  IStoragePool public storagePool;\n  IReservePool public reservePool;\n  IPriceFeed public priceFeed;\n  address public debtTokenManagerAddress;\n\n  // --- Data structures ---\n\n  mapping(IDebtToken => IStabilityPool) public stabilityPools;\n  IStabilityPool[] public stabilityPoolsArray;\n\n  // --- Dependency setter ---\n\n  function setAddresses(\n    address _liquidationOperationsAddress,\n    address _priceFeedAddress,\n    address _storagePoolAddress,\n    address _reservePoolAddress,\n    address _debtTokenManagerAddress\n  ) external onlyOwner {\n    checkContract(_liquidationOperationsAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_storagePoolAddress);\n    checkContract(_reservePoolAddress);\n    checkContract(_debtTokenManagerAddress);\n\n    liquidationOperationsAddress = _liquidationOperationsAddress;\n    priceFeed = IPriceFeed(_priceFeedAddress);\n    storagePool = IStoragePool(_storagePoolAddress);\n    reservePool = IReservePool(_reservePoolAddress);\n    debtTokenManagerAddress = _debtTokenManagerAddress;\n\n    emit StabilityPoolManagerInitiated(\n      _liquidationOperationsAddress,\n      _storagePoolAddress,\n      _reservePoolAddress,\n      _debtTokenManagerAddress,\n      _priceFeedAddress\n    );\n\n    renounceOwnership();\n  }\n\n  // --- Getters ---\n\n  function getStabilityPool(IDebtToken _debtToken) external view override returns (IStabilityPool) {\n    IStabilityPool stabilityPool = stabilityPools[_debtToken];\n    if (address(stabilityPool) == address(0)) revert PoolNotExist();\n    return stabilityPool;\n  }\n\n  function getStabilityPools() external view returns (IStabilityPool[] memory) {\n    return stabilityPoolsArray;\n  }\n\n  function getRemainingStability(\n    address[] memory collTokenAddresses\n  ) external view override returns (RemainingStability[] memory) {\n    RemainingStability[] memory remainingStability = new RemainingStability[](stabilityPoolsArray.length);\n\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      TokenAmount[] memory collGained = new TokenAmount[](collTokenAddresses.length);\n      for (uint a = 0; a < collTokenAddresses.length; a++) collGained[a] = TokenAmount(collTokenAddresses[a], 0);\n\n      remainingStability[i] = RemainingStability({\n        stabilityPool: stabilityPoolsArray[i],\n        tokenAddress: address(stabilityPoolsArray[i].getDepositToken()),\n        remaining: stabilityPoolsArray[i].getTotalDeposit(),\n        debtToOffset: 0,\n        collGained: collGained\n      });\n    }\n\n    return remainingStability;\n  }\n\n  function getTotalDeposits() external view override returns (TokenAmount[] memory deposits) {\n    deposits = new TokenAmount[](stabilityPoolsArray.length);\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      deposits[i] = TokenAmount(\n        address(stabilityPoolsArray[i].getDepositToken()),\n        stabilityPoolsArray[i].getTotalDeposit()\n      );\n    }\n\n    return deposits;\n  }\n\n  function getTotalDeposit(address _debtTokenAddress) external view returns (uint amount) {\n    IStabilityPool pool = stabilityPools[IDebtToken(_debtTokenAddress)];\n    if (address(pool) == address(0)) return 0;\n    return pool.getTotalDeposit();\n  }\n\n  function getCompoundedDeposits() external view override returns (TokenAmount[] memory deposits) {\n    deposits = new TokenAmount[](stabilityPoolsArray.length);\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      deposits[i] = TokenAmount(\n        address(stabilityPoolsArray[i].getDepositToken()),\n        stabilityPoolsArray[i].getCompoundedDebtDeposit(msg.sender)\n      );\n    }\n\n    return deposits;\n  }\n\n  function getDepositorDeposits(address _depositor) external view override returns (TokenAmount[] memory deposits) {\n    deposits = new TokenAmount[](stabilityPoolsArray.length);\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      deposits[i] = TokenAmount(\n        address(stabilityPoolsArray[i].getDepositToken()),\n        stabilityPoolsArray[i].getDepositorDeposit(_depositor)\n      );\n    }\n\n    return deposits;\n  }\n\n  function getDepositorDeposit(\n    address _depositor,\n    address _debtTokenAddress\n  ) external view override returns (uint amount) {\n    IStabilityPool pool = stabilityPools[IDebtToken(_debtTokenAddress)];\n    if (address(pool) == address(0)) return 0;\n    return pool.getDepositorDeposit(_depositor);\n  }\n\n  function getDepositorCompoundedDeposit(\n    address _depositor,\n    address _debtTokenAddress\n  ) external view override returns (uint amount) {\n    IStabilityPool pool = stabilityPools[IDebtToken(_debtTokenAddress)];\n    if (address(pool) == address(0)) return 0;\n    return pool.getCompoundedDebtDeposit(_depositor);\n  }\n\n  function getDepositorCompoundedDeposits(\n    address _depositor\n  ) external view override returns (TokenAmount[] memory deposits) {\n    deposits = new TokenAmount[](stabilityPoolsArray.length);\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      deposits[i] = TokenAmount(\n        address(stabilityPoolsArray[i].getDepositToken()),\n        stabilityPoolsArray[i].getCompoundedDebtDeposit(_depositor)\n      );\n    }\n\n    return deposits;\n  }\n\n  function getDepositorCollGains(\n    address _depositor,\n    address[] memory collTokenAddresses\n  ) external view override returns (TokenAmount[] memory collGains) {\n    collGains = new TokenAmount[](collTokenAddresses.length);\n    for (uint i = 0; i < collTokenAddresses.length; i++) {\n      for (uint ii = 0; ii < stabilityPoolsArray.length; ii++) {\n        collGains[i] = TokenAmount(\n          address(stabilityPoolsArray[ii].getDepositToken()),\n          stabilityPoolsArray[ii].getDepositorCollGain(_depositor, collTokenAddresses[i])\n        );\n      }\n    }\n\n    return collGains;\n  }\n\n  // --- Setters ---\n\n  function provideStability(TokenAmount[] memory _debts) external override {\n    address user = msg.sender;\n\n    for (uint i = 0; i < _debts.length; i++) {\n      IDebtToken debtToken = IDebtToken(_debts[i].tokenAddress);\n      IStabilityPool stabilityPool = stabilityPools[debtToken];\n      if (address(stabilityPool) == address(0)) revert PoolNotExist();\n\n      debtToken.sendToPool(user, address(stabilityPool), _debts[i].amount);\n      stabilityPool.provideToSP(user, _debts[i].amount);\n    }\n  }\n\n  function withdrawStability(TokenAmount[] memory _debts) external override {\n    address user = msg.sender;\n\n    for (uint i = 0; i < _debts.length; i++) {\n      IDebtToken debtToken = IDebtToken(_debts[i].tokenAddress);\n      IStabilityPool stabilityPool = stabilityPools[debtToken];\n      if (address(stabilityPool) == address(0)) revert PoolNotExist();\n\n      stabilityPool.withdrawFromSP(user, _debts[i].amount);\n    }\n  }\n\n  function withdrawGains() external override {\n    address user = msg.sender;\n\n    for (uint i = 0; i < stabilityPoolsArray.length; i++) {\n      IStabilityPool stabilityPool = stabilityPoolsArray[i];\n      stabilityPool.withdrawGains(user);\n    }\n  }\n\n  function offset(RemainingStability[] memory _toOffset) external override {\n    _requireCallerIsLiquidationOps();\n\n    IStoragePool storagePoolCached = storagePool;\n    for (uint i = 0; i < _toOffset.length; i++) {\n      RemainingStability memory remainingStability = _toOffset[i];\n      address stabilityPoolAddress = address(remainingStability.stabilityPool);\n      if (remainingStability.debtToOffset == 0) continue;\n\n      // Burn the debt that was successfully offset\n      remainingStability.stabilityPool.getDepositToken().burn(stabilityPoolAddress, remainingStability.debtToOffset);\n\n      // move the coll from the active pool into the stability pool\n      IDebtToken stableDebt = reservePool.stableDebtToken();\n      IERC20 govToken = reservePool.govToken();\n      uint stableCollIndex = remainingStability.collGained.length; // out range index as default\n      uint govTokenCollIndex = remainingStability.collGained.length;\n\n      for (uint ii = 0; ii < remainingStability.collGained.length; ii++) {\n        if (remainingStability.collGained[ii].tokenAddress == address(stableDebt)) stableCollIndex = ii;\n        if (remainingStability.collGained[ii].tokenAddress == address(govToken)) govTokenCollIndex = ii;\n        if (remainingStability.collGained[ii].amount == 0) continue;\n\n        storagePoolCached.withdrawalValue(\n          stabilityPoolAddress,\n          remainingStability.collGained[ii].tokenAddress,\n          true,\n          PoolType.Active,\n          remainingStability.collGained[ii].amount\n        );\n      }\n\n      // check possible loss\n      uint gainedCollValue = _getGainedCollValue(remainingStability.collGained);\n      uint offsetValue = priceFeed.getUSDValue(remainingStability.tokenAddress, remainingStability.debtToOffset);\n      if (offsetValue > gainedCollValue) {\n        // Repay loss from reserve pool\n        (uint repaidGov, uint repaidStable) = reservePool.withdrawValue(\n          stabilityPoolAddress,\n          offsetValue - gainedCollValue\n        );\n\n        // add repaid gov token to coll gained array\n        if (repaidGov > 0) {\n          if (govTokenCollIndex >= remainingStability.collGained.length) {\n            // govTokenCollIndex not found in prev loop, add to end of array\n            TokenAmount[] memory collGained = new TokenAmount[](remainingStability.collGained.length + 1);\n            for (uint ii = 0; ii < remainingStability.collGained.length; ii++) {\n              collGained[ii] = remainingStability.collGained[ii];\n            }\n            collGained[remainingStability.collGained.length] = TokenAmount({\n              tokenAddress: address(govToken),\n              amount: repaidGov\n            });\n            remainingStability.collGained = collGained;\n          } else {\n            remainingStability.collGained[govTokenCollIndex].amount += repaidGov;\n          }\n        }\n        // add repaid stableCoin to coll gained array\n        if (repaidStable > 0) {\n          if (stableCollIndex >= remainingStability.collGained.length) {\n            // stablecoinIndex not found in prev loop, add to end of array\n            TokenAmount[] memory collGained = new TokenAmount[](remainingStability.collGained.length + 1);\n            for (uint ii = 1; ii < remainingStability.collGained.length; ii++) {\n              collGained[ii] = remainingStability.collGained[ii];\n            }\n            collGained[remainingStability.collGained.length] = TokenAmount({\n              tokenAddress: address(stableDebt),\n              amount: repaidStable\n            });\n            remainingStability.collGained = collGained;\n          } else {\n            remainingStability.collGained[stableCollIndex].amount += repaidStable;\n          }\n        }\n      }\n\n      // update internal pool stake snapshots\n      remainingStability.stabilityPool.offset(remainingStability.debtToOffset, remainingStability.collGained);\n\n      // Cancel the liquidated debt with the debt in the stability pool\n      storagePoolCached.subtractValue(\n        remainingStability.tokenAddress,\n        false,\n        PoolType.Active,\n        remainingStability.debtToOffset\n      );\n    }\n  }\n\n  function addStabilityPool(IDebtToken _debtToken) external override {\n    if (msg.sender != debtTokenManagerAddress) revert Unauthorized();\n    if (address(stabilityPools[_debtToken]) != address(0)) revert PoolExist();\n\n    IStabilityPool stabilityPool = new StabilityPool(address(this), address(_debtToken));\n\n    stabilityPools[_debtToken] = stabilityPool;\n    stabilityPoolsArray.push(stabilityPool);\n    emit StabilityPoolAdded(address(stabilityPool));\n  }\n\n  function _getGainedCollValue(TokenAmount[] memory collGained) internal view returns (uint gainedValue) {\n    for (uint i = 0; i < collGained.length; i++) {\n      gainedValue += priceFeed.getUSDValue(collGained[i].tokenAddress, collGained[i].amount);\n    }\n  }\n\n  function _requireCallerIsLiquidationOps() internal view {\n    if (msg.sender != liquidationOperationsAddress) revert NotFromLiquidationOps();\n  }\n\n  function _requireCallerIsReservePool() internal view {\n    if (msg.sender != address(reservePool)) revert NotFromReservePool();\n  }\n}\n"
    },
    "contracts/StoragePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IStabilityPoolManager.sol';\n\n/*\n * The Active Pool holds the collateral and debt (but not the token itself) for all active troves.\n *\n * When a trove is liquidated, it's coll and debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract StoragePool is LiquityBase, Ownable(msg.sender), CheckContract, IStoragePool {\n  string public constant NAME = 'StoragePool';\n\n  address public borrowerOperationsAddress;\n  address public troveManagerAddress;\n  address public redemptionOperationsAddress;\n  address public liquidationOperationsAddress;\n  address public stabilityPoolManagerAddress;\n  IPriceFeed public priceFeed;\n\n  struct PoolEntry {\n    address tokenAddress;\n    uint256 totalAmount;\n    mapping(PoolType => uint256) poolTypes;\n    bool exists;\n  }\n  mapping(address => mapping(bool => PoolEntry)) internal poolEntries; // [tokenAddress][isColl] => PoolEntry\n  address[] public collTokenAddresses;\n  address[] public debtTokenAddresses;\n\n  // --- Contract setters ---\n\n  function setAddresses(\n    address _borrowerOperationsAddress,\n    address _troveManagerAddress,\n    address _redemptionOperationsAddress,\n    address _liquidationOperationsAddress,\n    address _stabilityPoolManagerAddress,\n    address _priceFeedAddress\n  ) external onlyOwner {\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_troveManagerAddress);\n    checkContract(_redemptionOperationsAddress);\n    checkContract(_liquidationOperationsAddress);\n    checkContract(_stabilityPoolManagerAddress);\n    checkContract(_priceFeedAddress);\n\n    borrowerOperationsAddress = _borrowerOperationsAddress;\n    troveManagerAddress = _troveManagerAddress;\n    redemptionOperationsAddress = _redemptionOperationsAddress;\n    liquidationOperationsAddress = _liquidationOperationsAddress;\n    stabilityPoolManagerAddress = _stabilityPoolManagerAddress;\n    priceFeed = IPriceFeed(_priceFeedAddress);\n\n    emit StoragePoolInitialized(\n      _borrowerOperationsAddress,\n      _troveManagerAddress,\n      _redemptionOperationsAddress,\n      _liquidationOperationsAddress,\n      _stabilityPoolManagerAddress,\n      _priceFeedAddress\n    );\n\n    renounceOwnership();\n  }\n\n  // --- Getters for public variables. Required by IPool interface ---\n\n  function getValue(address _tokenAddress, bool _isColl, PoolType _poolType) external view override returns (uint) {\n    return poolEntries[_tokenAddress][_isColl].poolTypes[_poolType];\n  }\n\n  // --- Pool functionality ---\n\n  function addValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) external override {\n    _requireCallerIsProtocol();\n\n    PoolEntry storage entry = poolEntries[_tokenAddress][_isColl];\n    if (!entry.exists) {\n      poolEntries[_tokenAddress][_isColl].exists = true;\n      poolEntries[_tokenAddress][_isColl].tokenAddress = _tokenAddress;\n\n      if (_isColl) collTokenAddresses.push(_tokenAddress);\n      else debtTokenAddresses.push(_tokenAddress);\n    }\n\n    entry.poolTypes[_poolType] += _amount;\n    entry.totalAmount += _amount;\n    emit StoragePoolValueUpdated(_tokenAddress, _isColl, _poolType, entry.poolTypes[_poolType]);\n  }\n\n  function subtractValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) external override {\n    _requireCallerIsProtocol();\n    _subtractValue(_tokenAddress, _isColl, _poolType, _amount);\n  }\n\n  function withdrawalValue(\n    address _receiver,\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _poolType,\n    uint _amount\n  ) external override {\n    _requireCallerIsProtocol();\n    _subtractValue(_tokenAddress, _isColl, _poolType, _amount);\n    IERC20(_tokenAddress).transfer(_receiver, _amount);\n  }\n\n  function _subtractValue(address _tokenAddress, bool _isColl, PoolType _poolType, uint _amount) internal {\n    PoolEntry storage entry = poolEntries[_tokenAddress][_isColl];\n    if (!entry.exists) revert PoolEntryDoesntExist();\n\n    entry.poolTypes[_poolType] -= _amount;\n    entry.totalAmount -= _amount;\n    emit StoragePoolValueUpdated(_tokenAddress, _isColl, _poolType, entry.poolTypes[_poolType]);\n  }\n\n  function transferBetweenTypes(\n    address _tokenAddress,\n    bool _isColl,\n    PoolType _fromType,\n    PoolType _toType,\n    uint _amount\n  ) external override {\n    _requireCallerIsProtocol();\n\n    PoolEntry storage entry = poolEntries[_tokenAddress][_isColl];\n    if (!entry.exists) revert PoolEntryDoesntExist();\n\n    entry.poolTypes[_fromType] -= _amount;\n    emit StoragePoolValueUpdated(_tokenAddress, _isColl, _fromType, entry.poolTypes[_fromType]);\n\n    entry.poolTypes[_toType] += _amount;\n    emit StoragePoolValueUpdated(_tokenAddress, _isColl, _toType, entry.poolTypes[_toType]);\n  }\n\n  function getEntireSystemColl() public view returns (uint entireSystemColl) {\n    IPriceFeed priceFeedCached = priceFeed;\n    for (uint i = 0; i < collTokenAddresses.length; i++)\n      entireSystemColl += priceFeedCached.getUSDValue(\n        collTokenAddresses[i],\n        poolEntries[collTokenAddresses[i]][true].totalAmount\n      );\n\n    return entireSystemColl;\n  }\n\n  function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\n    IPriceFeed priceFeedCached = priceFeed;\n    for (uint i = 0; i < debtTokenAddresses.length; i++)\n      entireSystemDebt += priceFeedCached.getUSDValue(\n        debtTokenAddresses[i],\n        poolEntries[debtTokenAddresses[i]][false].totalAmount\n      );\n\n    return entireSystemDebt;\n  }\n\n  function getTokenTotalAmount(address _tokenAddress, bool _isColl) external view override returns (uint) {\n    return poolEntries[_tokenAddress][_isColl].totalAmount;\n  }\n\n  function checkRecoveryMode()\n    external\n    view\n    returns (bool isInRecoveryMode, uint TCR, uint entireSystemColl, uint entireSystemDebt)\n  {\n    entireSystemColl = getEntireSystemColl();\n    entireSystemDebt = getEntireSystemDebt();\n    TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt);\n    isInRecoveryMode = TCR < CCR;\n  }\n\n  // --- 'require' functions ---\n\n  function _requireCallerIsProtocol() internal view {\n    if (\n      msg.sender != borrowerOperationsAddress &&\n      msg.sender != troveManagerAddress &&\n      msg.sender != stabilityPoolManagerAddress &&\n      msg.sender != redemptionOperationsAddress &&\n      msg.sender != liquidationOperationsAddress\n    ) revert NotFromBOorTroveMorSP();\n  }\n}\n"
    },
    "contracts/SwapERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport './Interfaces/ISwapERC20.sol';\n\ncontract SwapERC20 is ISwapERC20 {\n  string public constant name = 'Swap';\n  string public constant symbol = 'SWAP';\n  uint8 public constant decimals = 18;\n  uint public totalSupply;\n  mapping(address => uint) public balanceOf;\n  mapping(address => mapping(address => uint)) public allowance;\n\n  bytes32 public DOMAIN_SEPARATOR;\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n  mapping(address => uint) public nonces;\n\n  constructor() {\n    uint chainId;\n    assembly {\n      chainId := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256(bytes(name)),\n        keccak256(bytes('1')),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  function _mint(address to, uint value) internal {\n    totalSupply += value;\n    balanceOf[to] += value;\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(address from, uint value) internal {\n    balanceOf[from] -= value;\n    totalSupply -= value;\n    emit Transfer(from, address(0), value);\n  }\n}\n"
    },
    "contracts/SwapOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './SwapPair.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Interfaces/ISwapOperations.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IDebtTokenManager.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ITroveManager.sol';\n\ncontract SwapOperations is ISwapOperations, Ownable(msg.sender), CheckContract, LiquityBase {\n\n  // --- Connected contract declarations ---\n\n  ITroveManager public troveManager;\n  IBorrowerOperations public borrowerOperations;\n  address public priceFeedAddress;\n  IDebtTokenManager public debtTokenManager;\n\n  // --- Data structures ---\n\n  mapping(address => mapping(address => address)) public getPair;\n  address[] public allPairs;\n\n  // --- Dependency setters ---\n\n  function setAddresses(\n    address _borrowerOperationsAddress,\n    address _troveManagerAddress,\n    address _priceFeedAddress,\n    address _debtTokenManager\n  ) external onlyOwner {\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_troveManagerAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_debtTokenManager);\n\n    borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n    troveManager = ITroveManager(_troveManagerAddress);\n    priceFeedAddress = _priceFeedAddress;\n    debtTokenManager = IDebtTokenManager(_debtTokenManager);\n\n    emit SwapOperationsInitialized(\n      _borrowerOperationsAddress,\n      _troveManagerAddress,\n      _priceFeedAddress,\n      _debtTokenManager\n    );\n\n    // Disabled to create pairs later\n    // renounceOwnership();\n  }\n\n  modifier ensure(uint deadline) {\n    if (deadline < block.timestamp) revert Expired();\n    _;\n  }\n\n  // --- Pair Management ---\n\n  function allPairsLength() external view returns (uint) {\n    return allPairs.length;\n  }\n\n  function createPair(address tokenA, address tokenB) external onlyOwner returns (address pair) {\n    if (tokenA == tokenB) revert IdenticalAddresses();\n    if (tokenA != address(debtTokenManager.getStableCoin()) && tokenB != address(debtTokenManager.getStableCoin()))\n      revert PairRequiresStable();\n\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    if (token0 == address(0)) revert ZeroAddress();\n    if (getPair[token0][token1] != address(0)) revert PairExists(); // single check is sufficient\n\n    bytes memory bytecode = type(SwapPair).creationCode;\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n    assembly {\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n    }\n\n    ISwapPair(pair).initialize(token0, token1, address(debtTokenManager), priceFeedAddress);\n    getPair[token0][token1] = pair;\n    getPair[token1][token0] = pair; // populate mapping in the reverse direction\n    allPairs.push(pair);\n\n    emit PairCreated(token0, token1, pair, allPairs.length);\n  }\n\n  // --- Getter functions ---\n\n  function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n    if (amountA == 0) revert InsufficientAmount();\n    if (reserveA == 0 || reserveB == 0) revert InsufficientLiquidity();\n\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) public pure virtual override returns (uint amountOut) {\n    if (amountIn == 0) revert InsufficientInputAmount();\n    if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n\n    uint amountInWithFee = amountIn * (SWAP_FEE_PRECISION - swapFee);\n    uint numerator = amountInWithFee * reserveOut;\n    uint denominator = reserveIn * SWAP_FEE_PRECISION + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut,\n    uint32 swapFee\n  ) public pure virtual override returns (uint amountIn) {\n    if (amountOut == 0) revert InsufficientOutputAmount();\n    if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n\n    uint numerator = reserveIn * amountOut * SWAP_FEE_PRECISION;\n    uint denominator = (reserveOut - amountOut) * (SWAP_FEE_PRECISION - swapFee);\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    if (path.length < 2) revert InvalidPath();\n\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i < path.length - 1; i++) {\n      (uint reserveIn, uint reserveOut, uint32 swapFee) = getReserves(path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, swapFee);\n    }\n  }\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    if (path.length < 2) revert InvalidPath();\n\n    amounts = new uint[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint i = path.length - 1; i > 0; i--) {\n      (uint reserveIn, uint reserveOut, uint32 swapFee) = getReserves(path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, swapFee);\n    }\n  }\n\n  // --- Liquidity functions ---\n\n  struct ProvidingVars {\n    address pair;\n    uint senderBalanceA;\n    uint senderBalanceB;\n    uint fromBalanceA;\n    uint fromBalanceB;\n    uint fromMintA;\n    uint fromMintB;\n  }\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n    ProvidingVars memory vars;\n    vars.pair = getPair[tokenA][tokenB];\n    if (vars.pair == address(0)) revert PairDoesNotExist();\n\n    {\n      (uint reserveA, uint reserveB, ) = getReserves(tokenA, tokenB);\n      if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n      } else {\n        uint amountBOptimal = quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n          if (amountBOptimal < amountBMin) revert InsufficientBAmount();\n          (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n          uint amountAOptimal = quote(amountBDesired, reserveB, reserveA);\n          assert(amountAOptimal <= amountADesired);\n          if (amountAOptimal < amountAMin) revert InsufficientAAmount();\n          (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n      }\n    }\n\n    vars.senderBalanceA = IERC20(tokenA).balanceOf(msg.sender);\n    vars.senderBalanceB = IERC20(tokenB).balanceOf(msg.sender);\n\n    vars.fromBalanceA = LiquityMath._min(vars.senderBalanceA, amountA);\n    vars.fromBalanceB = LiquityMath._min(vars.senderBalanceB, amountB);\n\n    vars.fromMintA = amountA - vars.fromBalanceA;\n    vars.fromMintB = amountB - vars.fromBalanceB;\n\n    // mint new tokens if the sender did not have enough\n    if (vars.fromMintA != 0 || vars.fromMintB != 0) {\n      TokenAmount[] memory debtsToMint;\n      if (vars.fromMintA != 0 && vars.fromMintB != 0) {\n        // mint both\n        debtsToMint = new TokenAmount[](2);\n        debtsToMint[0] = TokenAmount(tokenA, vars.fromMintA);\n        debtsToMint[1] = TokenAmount(tokenB, vars.fromMintB);\n      } else {   \n        // mint only 1 token    \n        debtsToMint = new TokenAmount[](1);\n        debtsToMint[0] = (vars.fromMintA != 0\n          ? TokenAmount(tokenA, vars.fromMintA) // mint A\n          : TokenAmount(tokenB, vars.fromMintB) // mint B\n        );\n      }\n      borrowerOperations.increaseDebt(msg.sender, vars.pair, debtsToMint, _mintMeta);\n    }\n\n    // transfer tokens sourced from senders balance\n    if (vars.fromBalanceA != 0) safeTransferFrom(tokenA, msg.sender, vars.pair, vars.fromBalanceA);\n    if (vars.fromBalanceB != 0) safeTransferFrom(tokenB, msg.sender, vars.pair, vars.fromBalanceB);\n\n    liquidity = ISwapPair(vars.pair).mint(msg.sender);\n  }\n\n  function addLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    MintMeta memory _mintMeta,\n    uint deadline,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external returns (uint amountA, uint amountB, uint liquidity) {\n    IERC20Permit(tokenA).permit(msg.sender, address(this), amountADesired, deadline, v[0], r[0], s[0]);\n    IERC20Permit(tokenB).permit(msg.sender, address(this), amountBDesired, deadline, v[1], r[1], s[1]);\n    return addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, _mintMeta, deadline);\n  }\n\n  struct RemovalVars {\n    address token0;\n    address token1;\n    uint amount0;\n    uint amount1;\n    uint burned0;\n    uint burned1;\n  }\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address _upperHint,\n    address _lowerHint,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n    RemovalVars memory vars;\n    (vars.token0, vars.token1) = sortTokens(tokenA, tokenB);\n\n    // receive tokens from pair\n    address pair = getPair[tokenA][tokenB];\n    (vars.amount0, vars.amount1, vars.burned0, vars.burned1) = ISwapPair(pair).burn(\n      msg.sender,\n      liquidity,\n      // check if there are some debts which has to be repaid first\n      troveManager.getTroveRepayableDebt(msg.sender, vars.token0, false),\n      troveManager.getTroveRepayableDebt(msg.sender, vars.token1, false)\n    );\n\n    // handle trove debt repayment\n    if (vars.burned0 != 0 || vars.burned1 != 0) {\n      TokenAmount[] memory debtsToRepay;\n      if (vars.burned0 != 0 && vars.burned1 != 0) {\n        // repay both\n        debtsToRepay = new TokenAmount[](2);\n        debtsToRepay[0] = TokenAmount(vars.token0, vars.burned0);\n        debtsToRepay[1] = TokenAmount(vars.token1, vars.burned1);\n      } else {\n        // repay only 1 token\n        debtsToRepay = new TokenAmount[](1);\n        debtsToRepay[0] = (vars.burned0 != 0\n          ? TokenAmount(vars.token0, vars.burned0)\n          : TokenAmount(vars.token1, vars.burned1)\n        );\n      }\n      borrowerOperations.repayDebtFromPoolBurn(msg.sender, debtsToRepay, _upperHint, _lowerHint);\n    }\n\n    (amountA, amountB) = tokenA == vars.token0 ? (vars.amount0, vars.amount1) : (vars.amount1, vars.amount0);\n    if (amountA < amountAMin) revert InsufficientAAmount();\n    if (amountB < amountBMin) revert InsufficientBAmount();\n  }\n\n  // **** SWAP ****\n  // requires the initial amount to have already been sent to the first pair\n  // --- Swap functions ---\n\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = sortTokens(input, output);\n\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n\n      address to = i < path.length - 2 ? getPair[output][path[i + 2]] : _to;\n      ISwapPair(getPair[input][output]).swap(amount0Out, amount1Out, to);\n    }\n  }\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = getAmountsOut(amountIn, path);\n    if (amounts[amounts.length - 1] < amountOutMin) revert InsufficientOutputAmount();\n    safeTransferFrom(path[0], msg.sender, getPair[path[0]][path[1]], amounts[0]);\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = getAmountsIn(amountOut, path);\n    if (amounts[0] > amountInMax) revert ExcessiveInputAmount();\n    safeTransferFrom(path[0], msg.sender, getPair[path[0]][path[1]], amounts[0]);\n    _swap(amounts, path, to);\n  }\n\n  function swapExactTokensForTokensWithPermit(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint[] memory amounts) {\n    IERC20Permit(path[0]).permit(msg.sender, address(this), amountIn, deadline, v, r, s);\n    return swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);\n  }\n  // --- Position functions ---\n\n  function openLongPosition(\n    uint stableToMintIn,\n    uint debtOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external override ensure(deadline) returns (uint[] memory amounts) {\n    address[] memory path = new address[](2);\n    path[0] = address(debtTokenManager.getStableCoin());\n    path[1] = debtTokenAddress;\n\n    return _openPosition(stableToMintIn, debtOutMin, path, to, _mintMeta);\n  }\n\n  function openShortPosition(\n    uint debtToMintIn,\n    uint stableOutMin,\n    address debtTokenAddress,\n    address to,\n    MintMeta memory _mintMeta,\n    uint deadline\n  ) external override ensure(deadline) returns (uint[] memory amounts) {\n    address[] memory path = new address[](2);\n    path[0] = debtTokenAddress;\n    path[1] = address(debtTokenManager.getStableCoin());\n\n    return _openPosition(debtToMintIn, stableOutMin, path, to, _mintMeta);\n  }\n\n  function _openPosition(\n    uint amountIn,\n    uint amountOutMin,\n    address[] memory path,\n    address to,\n    MintMeta memory _mintMeta\n  ) internal returns (uint[] memory amounts) {\n    address pair = getPair[path[0]][path[1]];\n    if (pair == address(0)) revert PairDoesNotExist();        \n\n    amounts = getAmountsOut(amountIn, path);\n    if (amounts[amounts.length - 1] < amountOutMin) revert InsufficientOutputAmount();\n\n    debtTokenManager.getDebtToken(path[0]); //check if debt token\n\n    // mint the debt token and transfer it to the pair\n    TokenAmount[] memory debtsToMint = new TokenAmount[](1);\n    debtsToMint[0] = TokenAmount(path[0], amounts[0]);\n    borrowerOperations.increaseDebt(msg.sender, pair, debtsToMint, _mintMeta);\n\n    // execute the swap\n    _swap(amounts, path, to);\n\n    return amounts;\n  }\n\n  // --- Helper functions ---\n\n  function getReserves(\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint reserveA, uint reserveB, uint32 swapFee) {\n    ISwapPair pair = ISwapPair(getPair[tokenA][tokenB]);\n    swapFee = pair.getSwapFee();\n\n    (uint reserve0, uint reserve1, ) = pair.getReserves();\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  function sortTokens(address tokenA, address tokenB) internal view returns (address token0, address token1) {\n    if (tokenA == tokenB) revert IdenticalAddresses();\n    if (tokenA == address(0) || tokenB == address(0)) revert ZeroAddress();\n\n    address stableCoin = address(debtTokenManager.getStableCoin());\n    if (tokenA == stableCoin) return (tokenA, tokenB);\n    if (tokenB == stableCoin) return (tokenB, tokenA);\n    return tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n  }\n\n  function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFromFailed();\n  }\n}\n"
    },
    "contracts/SwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './Dependencies/LiquityMath.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/UQ112x112.sol';\nimport './Interfaces/ISwapPair.sol';\nimport './Interfaces/ISwapOperations.sol';\nimport './Interfaces/ISwapCallee.sol';\nimport './SwapERC20.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IDebtTokenManager.sol';\n\ncontract SwapPair is ISwapPair, SwapERC20, LiquityBase {\n  using UQ112x112 for uint224;\n\n  uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n  address public operations;\n  IPriceFeed public priceFeed;\n  IDebtTokenManager public debtTokenManager;\n\n  address public token0;\n  address public token1;\n\n  uint112 private reserve0; // uses single storage slot, accessible via getReserves\n  uint112 private reserve1; // uses single storage slot, accessible via getReserves\n  uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n  uint public price0CumulativeLast;\n  uint public price1CumulativeLast;\n\n  constructor() {\n    operations = msg.sender;\n  }\n\n  // called once by the operations at time of deployment\n  function initialize(address _token0, address _token1, address _debtTokenManager, address _priceFeedAddress) external {\n    if (msg.sender != operations) revert Forbidden();\n\n    token0 = _token0;\n    token1 = _token1;\n    debtTokenManager = IDebtTokenManager(_debtTokenManager);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n  }\n\n  uint private unlocked = 1;\n  modifier lock() {\n    if (unlocked == 0) revert Locked();\n\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }\n\n  function _safeTransfer(address token, address to, uint value) private {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n\n    if (!success || (data.length > 0 && abi.decode(data, (bool)) == false)) revert TransferFailed();\n  }\n\n  // update reserves and, on the first call per block, price accumulators\n  function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n    if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\n\n    uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      // * never overflows, and + overflow is desired\n      price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n      price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n    }\n\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function mint(address to) external lock returns (uint liquidity) {\n    _requireCallerIsOperations();\n\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n    uint amount0 = balance0 - _reserve0;\n    uint amount1 = balance1 - _reserve1;\n\n    uint _totalSupply = totalSupply; // gas savings\n    if (_totalSupply == 0) {\n      liquidity = LiquityMath._sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n      _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = LiquityMath._min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n    }\n\n    if (liquidity == 0) revert InsufficientLiquidityMinted();\n    _mint(to, liquidity);\n    _update(balance0, balance1, _reserve0, _reserve1);\n\n    emit Mint(msg.sender, amount0, amount1);\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  // directly burns debt tokens if the user has any left to repay\n  function burn(\n    address to,\n    uint liquidity,\n    uint debt0,\n    uint debt1\n  ) external lock returns (uint amount0, uint amount1, uint burned0, uint burned1) {\n    _requireCallerIsOperations();\n\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n\n    uint balance0 = IERC20(token0).balanceOf(address(this));\n    uint balance1 = IERC20(token1).balanceOf(address(this));\n\n    {\n      uint _totalSupply = totalSupply; // gas savings\n      amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n      amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n\n      if (amount0 == 0 || amount1 == 0) revert InsufficientLiquidityBurned();\n      _burn(to, liquidity);\n    }\n\n    // check if the user has any debts left to repay\n    burned0 = LiquityMath._min(debt0, amount0);\n    burned1 = LiquityMath._min(debt1, amount1);\n    if (burned0 != 0) IDebtToken(token0).burn(address(this), burned0);\n    if (burned1 != 0) IDebtToken(token1).burn(address(this), burned1);\n\n    // payout whats left\n    _safeTransfer(token0, to, amount0 - burned0);\n    _safeTransfer(token1, to, amount1 - burned1);\n\n    balance0 = IERC20(token0).balanceOf(address(this));\n    balance1 = IERC20(token1).balanceOf(address(this));\n    _update(balance0, balance1, _reserve0, _reserve1);\n\n    emit Burn(msg.sender, amount0, amount1, to);\n  }\n\n  // fee is returned in 1e6 (SWAP_FEE_PRECISION)\n  function getSwapFee() public view override returns (uint32 swapFee) {\n    // find stable coin\n    address nonStableCoin = token1;\n    if (!debtTokenManager.isDebtToken(nonStableCoin)) return SWAP_BASE_FEE; // no dynamic fee if the pool is not an stable/stock pool\n    if (totalSupply == 0) return SWAP_BASE_FEE; //inital mint\n\n    // query prices\n    uint oraclePrice = priceFeed.getPrice(nonStableCoin);\n    uint dexPrice = (reserve0 * DECIMAL_PRECISION) / reserve1; // todo does the token digits matter here?\n\n    if (oraclePrice < dexPrice) return SWAP_BASE_FEE;\n    uint priceRatio = (oraclePrice * DECIMAL_PRECISION) / dexPrice;\n    return uint32((priceRatio * SWAP_BASE_FEE) / DECIMAL_PRECISION); // todo missing real fee calculation\n  }\n\n  // this low-level function should be called from a contract which performs important safety checks\n  function swap(uint amount0Out, uint amount1Out, address to) external lock {\n    _requireCallerIsOperations();\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputAmount();\n    if (amount0Out > reserve0 || amount1Out > reserve1) revert InsufficientLiquidity();\n\n    uint balance0;\n    uint balance1;\n    address _token0 = token0;\n    address _token1 = token1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      if (to == _token0 || to == _token1) revert InvalidTo();\n\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n      balance0 = IERC20(_token0).balanceOf(address(this));\n      balance1 = IERC20(_token1).balanceOf(address(this));\n    }\n\n    uint amount0In = balance0 > reserve0 - amount0Out ? balance0 - (reserve0 - amount0Out) : 0;\n    uint amount1In = balance1 > reserve1 - amount1Out ? balance1 - (reserve1 - amount1Out) : 0;\n    if (amount0In == 0 && amount1In == 0) revert InsufficientInputAmount();\n\n    uint32 currentSwapFee = getSwapFee();\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint balance0Adjusted = balance0 * SWAP_FEE_PRECISION - (amount0In * currentSwapFee);\n      uint balance1Adjusted = balance1 * SWAP_FEE_PRECISION - (amount1In * currentSwapFee);\n      if (balance0Adjusted * balance1Adjusted < uint(reserve0) * uint(reserve1) * (uint(SWAP_FEE_PRECISION) ** 2))\n        revert K();\n    }\n\n    // gov swap fee payment\n    if (amount0In > 0) {\n      uint amount0GovFee = (amount0In * currentSwapFee * GOV_SWAP_FEE) / (uint(SWAP_FEE_PRECISION) ** 2);\n      _safeTransfer(_token0, GOV_STAKING_ADDRESS, amount0GovFee);\n      balance0 -= amount0GovFee;\n    }\n    if (amount1In > 0) {\n      uint amount1GovFee = (amount1In * currentSwapFee * GOV_SWAP_FEE) / (uint(SWAP_FEE_PRECISION) ** 2);\n      _safeTransfer(_token1, GOV_STAKING_ADDRESS, amount1GovFee);\n      balance1 -= amount1GovFee;\n    }\n\n    _update(balance0, balance1, reserve0, reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, currentSwapFee, to);\n  }\n\n  // force balances to match reserves\n  function skim(address to) external lock {\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);\n    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);\n  }\n\n  // force reserves to match balances\n  function sync() external lock {\n    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n  }\n\n  function _requireCallerIsOperations() internal view {\n    if (msg.sender != address(operations)) revert NotFromSwapOperations();\n  }\n}\n"
    },
    "contracts/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './Dependencies/LiquityBase.sol';\nimport './Dependencies/CheckContract.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/IDebtToken.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/IStoragePool.sol';\nimport './Interfaces/IBBase.sol';\nimport './Interfaces/ISortedTroves.sol';\n\ncontract TroveManager is LiquityBase, Ownable(msg.sender), CheckContract, ITroveManager {\n  string public constant NAME = 'TroveManager';\n\n  // --- Connected contract declarations ---\n\n  address public borrowerOperationsAddress;\n  address public redemptionOperationsAddress;\n  address public liquidationOperationsAddress;\n  IStoragePool public storagePool;\n  IPriceFeed public priceFeed;\n  ISortedTroves public sortedTroves;\n\n  // --- Data structures ---\n\n  /*\n   * Half-life of 12h. 12h = 720 min\n   * (1/2) = d^720 => d = (1/2)^(1/720)\n   */\n  uint public constant MINUTE_DECAY_FACTOR = 999037758833783000;\n\n  // During bootsrap period redemptions are not allowed\n  uint public constant BOOTSTRAP_PERIOD = 14 days;\n\n  /*\n   * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n   * Corresponds to (1 / ALPHA) in the white paper.\n   */\n  uint public constant BETA = 2;\n  uint public stableCoinBaseRate;\n\n  // The timestamp of the latest fee operation (redemption or new dToken issuance)\n  uint public lastFeeOperationTime;\n\n  // Store the neccessary data for a trove\n  struct Trove {\n    Status status;\n    uint128 arrayIndex;\n    //\n    IDebtToken[] debtTokens;\n    mapping(address => bool) debtsRegistered;\n    mapping(IDebtToken => uint) debts;\n    //\n    address[] collTokens;\n    mapping(address => bool) collsRegistered;\n    mapping(address => uint) colls;\n    //\n    // the troves stake is depends on the current collateral token prices\n    // therefore the partial stakes relative to the collateral needs to be stored\n    mapping(address => uint) stakes; // [collTokenAddress] -> stake\n  }\n  mapping(address => Trove) public Troves;\n\n  // stakes gets stored relative to the coll token, total stake needs to be calculated on runtime using token prices\n  // in token amount (not usd)\n  mapping(address => uint) public totalStakes; // [collTokenAddress] => total system stake, relative to the coll token\n  mapping(address => uint) public totalStakesSnapshot; // [collTokenAddress] => system stake, taken immediately after the latest liquidation (without default pool / rewards)\n  mapping(address => uint) public totalCollateralSnapshots; // [collTokenAddress] => system stake, taken immediately after the latest liquidation (including default pool / rewards)\n\n  // L_Tokens track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n  // A gain of ( stake * [L_TOKEN[T] - L_TOKEN[T](0)] )\n  // Where L_TOKEN[T](0) are snapshots of token T for the active Trove taken at the instant the stake was made\n  //\n  // in token amount (not usd)\n  mapping(address => mapping(bool => uint)) public liquidatedTokens; // [tokenAddress][isColl] -> liquidated/redistributed amount, per unit staked\n  mapping(address => mapping(address => mapping(bool => uint))) public rewardSnapshots; // [user][tokenAddress][isColl] -> value, snapshot amount, per unit staked\n  mapping(address => mapping(bool => uint)) public lastErrorRedistribution; // [tokenAddress][isColl] -> value, Error trackers for the trove redistribution calculation\n\n  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n  address[] public TroveOwners;\n\n  // --- Dependency setter ---\n\n  function setAddresses(\n    address _borrowerOperationsAddress,\n    address _redemptionOperationsAddress,\n    address _liquidationOperationsAddress,\n    address _storagePoolAddress,\n    address _priceFeedAddress,\n    address _sortedTrovesAddress\n  ) external onlyOwner {\n    checkContract(_borrowerOperationsAddress);\n    checkContract(_redemptionOperationsAddress);\n    checkContract(_liquidationOperationsAddress);\n    checkContract(_storagePoolAddress);\n    checkContract(_priceFeedAddress);\n    checkContract(_sortedTrovesAddress);\n\n    borrowerOperationsAddress = _borrowerOperationsAddress;\n    redemptionOperationsAddress = _redemptionOperationsAddress;\n    liquidationOperationsAddress = _liquidationOperationsAddress;\n    storagePool = IStoragePool(_storagePoolAddress);\n    priceFeed = IPriceFeed(_priceFeedAddress);\n    sortedTroves = ISortedTroves(_sortedTrovesAddress);\n\n    emit TroveManagerInitialized(\n      _borrowerOperationsAddress,\n      _redemptionOperationsAddress,\n      _liquidationOperationsAddress,\n      _storagePoolAddress,\n      _priceFeedAddress,\n      _sortedTrovesAddress\n    );\n\n    renounceOwnership();\n  }\n\n  /**\n   *\n   * troves status\n   *\n   **/\n\n  function getTroveOwnersCount() external view override returns (uint) {\n    return TroveOwners.length;\n  }\n\n  function getTroveOwners() external view returns (address[] memory) {\n    return TroveOwners;\n  }\n\n  function getTroveStatus(address _borrower) external view override returns (uint) {\n    return uint(Troves[_borrower].status);\n  }\n\n  function isTroveActive(address _borrower) external view override returns (bool) {\n    return Troves[_borrower].status == Status.active;\n  }\n\n  function setTroveStatus(address _borrower, uint _num) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n    Troves[_borrower].status = Status(_num);\n  }\n\n  /**\n   *\n   * collateral ratios\n   *\n   **/\n\n  // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n  function getCurrentICR(address _borrower) external view override returns (uint ICR, uint currentDebtInUSD) {\n    uint currentCollInUSD;\n    (currentCollInUSD, currentDebtInUSD) = _getCurrentTrovesUSDValues(_borrower);\n    ICR = LiquityMath._computeCR(currentCollInUSD, currentDebtInUSD);\n    return (ICR, currentDebtInUSD);\n  }\n\n  function getICRIncludingPatch(\n    address _borrower,\n    TokenAmount[] memory addedColl,\n    TokenAmount[] memory removedColl,\n    TokenAmount[] memory addedDebt,\n    TokenAmount[] memory removedDebt\n  ) external view override returns (uint ICR) {\n    Trove storage _trove = Troves[_borrower];\n    if (_trove.status != Status.active) return 0;\n\n    (uint currentCollInUSD, uint currentDebtInUSD) = _getCurrentTrovesUSDValues(_borrower);\n\n    currentCollInUSD += _getCompositeUSD(addedColl);\n    uint removedCollInUSD = _getCompositeUSD(removedColl);\n    if (currentCollInUSD < removedCollInUSD) currentCollInUSD = 0;\n    else currentCollInUSD -= _getCompositeUSD(removedColl);\n\n    currentDebtInUSD += _getCompositeUSD(addedDebt);\n    uint removedDebtInUSD = _getCompositeUSD(removedDebt);\n    if (currentDebtInUSD < removedDebtInUSD) currentDebtInUSD = 0;\n    else currentDebtInUSD -= _getCompositeUSD(removedDebt);\n\n    return LiquityMath._computeCR(currentCollInUSD, currentDebtInUSD);\n  }\n\n  function _getCompositeUSD(TokenAmount[] memory _amounts) internal view returns (uint inUSD) {\n    for (uint i = 0; i < _amounts.length; i++)\n      inUSD += priceFeed.getUSDValue(_amounts[i].tokenAddress, _amounts[i].amount);\n    return inUSD;\n  }\n\n  function _getCurrentTrovesUSDValues(\n    address _borrower\n  ) internal view returns (uint currentCollInUSD, uint currentDebtInUSD) {\n    Trove storage _trove = Troves[_borrower];\n\n    for (uint i = 0; i < _trove.collTokens.length; i++) {\n      address token = _trove.collTokens[i];\n\n      uint pendingRewards = getPendingReward(_borrower, token, true);\n      currentCollInUSD += priceFeed.getUSDValue(token, _trove.colls[token] + pendingRewards);\n    }\n\n    for (uint i = 0; i < _trove.debtTokens.length; i++) {\n      IDebtToken token = _trove.debtTokens[i];\n\n      uint pendingRewards = getPendingReward(_borrower, address(token), true);\n      currentDebtInUSD += priceFeed.getUSDValue(address(token), _trove.debts[token] + pendingRewards);\n    }\n\n    return (currentCollInUSD, currentDebtInUSD);\n  }\n\n  /**\n   *\n   * collateral stakes\n   *\n   **/\n\n  // Update borrower's stake based on their latest collateral value\n  function updateStakeAndTotalStakes(address[] memory collTokenAddresses, address _borrower) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    TokenAmount[] memory totalStakesCopy = new TokenAmount[](collTokenAddresses.length);\n    for (uint i = 0; i < collTokenAddresses.length; i++) {\n      address _collAddress = collTokenAddresses[i];\n\n      uint newBorrowerCollStake;\n      uint borrowersCollAmount = Troves[_borrower].colls[_collAddress];\n\n      uint totalCollateralSnapshot = totalCollateralSnapshots[_collAddress];\n      if (totalCollateralSnapshot == 0) newBorrowerCollStake = borrowersCollAmount;\n      else {\n        /*\n         * The following assert() holds true because:\n         * - The system always contains >= 1 trove\n         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n         */\n        uint stakedSnapshot = totalStakesSnapshot[_collAddress];\n        assert(stakedSnapshot > 0);\n        newBorrowerCollStake = (borrowersCollAmount * stakedSnapshot) / totalCollateralSnapshot;\n      }\n\n      uint oldBorrowerStake = Troves[_borrower].stakes[_collAddress];\n      uint newTotalStake = totalStakes[_collAddress] - oldBorrowerStake + newBorrowerCollStake;\n      totalStakes[_collAddress] = newTotalStake;\n      totalStakesCopy[i] = TokenAmount(_collAddress, newTotalStake);\n      Troves[_borrower].stakes[_collAddress] = newBorrowerCollStake;\n    }\n\n    emit TotalStakesUpdated(totalStakesCopy);\n  }\n\n  // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n  function removeStake(address[] memory collTokenAddresses, address _borrower) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    for (uint i = 0; i < collTokenAddresses.length; i++) {\n      address tokenAddress = collTokenAddresses[i];\n\n      totalStakes[tokenAddress] -= Troves[_borrower].stakes[tokenAddress];\n      Troves[_borrower].stakes[tokenAddress] = 0;\n    }\n  }\n\n  /*\n   * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n   * Used in a liquidation sequence.\n   */\n  function updateSystemSnapshots_excludeCollRemainder(TokenAmount[] memory totalCollGasCompensation) external override {\n    TokenAmount[] memory _totalStakesSnapshot = new TokenAmount[](totalCollGasCompensation.length);\n    TokenAmount[] memory _totalCollateralSnapshots = new TokenAmount[](totalCollGasCompensation.length);\n\n    // totalCollGasCompensation array included every available coll in the system, even if there is 0 gas compensation\n    for (uint i = 0; i < totalCollGasCompensation.length; i++) {\n      address tokenAddress = totalCollGasCompensation[i].tokenAddress;\n\n      uint totalStake = totalStakes[tokenAddress];\n      totalStakesSnapshot[tokenAddress] = totalStake;\n      _totalStakesSnapshot[i] = TokenAmount(tokenAddress, totalStake);\n\n      uint totalCollateralSnapshot = storagePool.getValue(tokenAddress, true, PoolType.Active) +\n        storagePool.getValue(tokenAddress, true, PoolType.Default) -\n        totalCollGasCompensation[i].amount;\n      totalCollateralSnapshots[tokenAddress] = totalCollateralSnapshot;\n      _totalCollateralSnapshots[i] = TokenAmount(tokenAddress, totalCollateralSnapshot);\n    }\n\n    emit SystemSnapshotsUpdated(_totalStakesSnapshot, _totalCollateralSnapshots);\n  }\n\n  /**\n   * @notice Get Borrower's staked token amount, not in USD value\n   * @param _borrower Address of borrower\n   * @param _token Address of collateral token\n   * @return stakes Staked amount of given collateral token of user\n   */\n  function getTroveStakes(address _borrower, address _token) external view override returns (uint) {\n    return Troves[_borrower].stakes[_token];\n  }\n\n  /**\n   * @notice Return borrowers staked value in USD\n   * @param _borrower Address of borrower\n   * @return stakedUSDValue USD value of total staked collaterals of borrower\n   */\n  function getTroveStakeValue(address _borrower) external view override returns (uint) {\n    return _calculateTrovesStake(_borrower);\n  }\n\n  // the current stake of the trove is depended on the current collateral prices\n  function _calculateTrovesStake(address _borrower) internal view returns (uint stake) {\n    Trove storage trove = Troves[_borrower];\n\n    for (uint i = 0; i < trove.collTokens.length; i++) {\n      address tokenAddress = trove.collTokens[i];\n      stake += priceFeed.getUSDValue(tokenAddress, trove.stakes[tokenAddress]);\n    }\n\n    return stake;\n  }\n\n  /**\n   *\n   * redistribution\n   *\n   **/\n\n  function redistributeDebtAndColl(\n    address[] memory collTokenAddresses,\n    CAmount[] memory toRedistribute\n  ) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    /*\n     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n     * error correction, to keep the cumulative error low in the running totals:\n     *\n     * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n     * function was called.\n     * 2) Calculate \"per-unit-staked\" ratios.\n     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store these errors for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n     */\n\n    uint totalStake = _getTotalStakesValue(collTokenAddresses);\n    CAmount[] memory _liquidatedTokens = new CAmount[](toRedistribute.length);\n\n    for (uint i = 0; i < toRedistribute.length; i++) {\n      CAmount memory redistributeEntry = toRedistribute[i];\n      if (redistributeEntry.amount == 0) continue;\n\n      // Get the per-unit-staked terms\n      uint numerator = redistributeEntry.amount *\n        DECIMAL_PRECISION +\n        lastErrorRedistribution[redistributeEntry.tokenAddress][redistributeEntry.isColl];\n      uint rewardPerUnitStaked = numerator / totalStake;\n\n      lastErrorRedistribution[redistributeEntry.tokenAddress][redistributeEntry.isColl] =\n        numerator -\n        (rewardPerUnitStaked * totalStake);\n\n      // Add per-unit-staked terms to the running totals\n      uint liquidated = liquidatedTokens[redistributeEntry.tokenAddress][redistributeEntry.isColl] +\n        rewardPerUnitStaked;\n\n      liquidatedTokens[redistributeEntry.tokenAddress][redistributeEntry.isColl] = liquidated;\n      _liquidatedTokens[i] = CAmount(redistributeEntry.tokenAddress, redistributeEntry.isColl, liquidated);\n\n      storagePool.transferBetweenTypes(\n        redistributeEntry.tokenAddress,\n        redistributeEntry.isColl,\n        PoolType.Active,\n        PoolType.Default,\n        redistributeEntry.amount\n      );\n    }\n\n    emit LTermsUpdated(_liquidatedTokens);\n  }\n\n  function _getTotalStakesValue(address[] memory collTokenAddresses) internal view returns (uint stake) {\n    for (uint i = 0; i < collTokenAddresses.length; i++) {\n      address tokenAddress = collTokenAddresses[i];\n      stake += priceFeed.getUSDValue(tokenAddress, totalStakes[tokenAddress]);\n    }\n\n    return stake;\n  }\n\n  // Get the borrower's pending accumulated rewards, earned by their stake through their redistribution\n  function getPendingReward(\n    address _borrower,\n    address _tokenAddress,\n    bool _isColl\n  ) public view returns (uint pendingReward) {\n    uint snapshotValue = rewardSnapshots[_borrower][_tokenAddress][_isColl];\n    uint rewardPerUnitStaked = liquidatedTokens[_tokenAddress][_isColl] - snapshotValue;\n    if (rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) return 0;\n\n    uint trovesStakeInUSD = _calculateTrovesStake(_borrower);\n    pendingReward = (trovesStakeInUSD * rewardPerUnitStaked) / DECIMAL_PRECISION;\n  }\n\n  function applyPendingRewards(address _borrower) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n    _requireTroveIsActive(_borrower);\n\n    Trove storage _trove = Troves[_borrower];\n    CAmount[] memory appliedRewards = new CAmount[](_trove.collTokens.length + _trove.debtTokens.length);\n\n    // coll rewards\n    for (uint i = 0; i < _trove.collTokens.length; i++) {\n      address token = _trove.collTokens[i];\n\n      uint pendingRewards = getPendingReward(_borrower, token, true);\n      appliedRewards[i] = CAmount(token, true, pendingRewards);\n      if (pendingRewards == 0) continue;\n\n      _trove.colls[token] += pendingRewards;\n      storagePool.transferBetweenTypes(token, true, PoolType.Default, PoolType.Active, pendingRewards);\n    }\n\n    // debt rewards\n    for (uint i = 0; i < _trove.debtTokens.length; i++) {\n      IDebtToken token = _trove.debtTokens[i];\n      address tokenAddress = address(token);\n\n      uint pendingRewards = getPendingReward(_borrower, tokenAddress, false);\n      appliedRewards[_trove.collTokens.length + i] = CAmount(tokenAddress, false, pendingRewards);\n      if (pendingRewards == 0) continue;\n\n      _trove.debts[token] += pendingRewards;\n      storagePool.transferBetweenTypes(tokenAddress, false, PoolType.Default, PoolType.Active, pendingRewards);\n    }\n\n    emit TroveAppliedRewards(_borrower, appliedRewards);\n    _updateTroveRewardSnapshots(_borrower);\n  }\n\n  // Update borrower's snapshots to reflect the current values\n  function updateTroveRewardSnapshots(address _borrower) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n    return _updateTroveRewardSnapshots(_borrower);\n  }\n\n  function _updateTroveRewardSnapshots(address _borrower) internal {\n    Trove storage _trove = Troves[_borrower];\n    CAmount[] memory _troveSnapshots = new CAmount[](_trove.collTokens.length + _trove.debtTokens.length);\n\n    for (uint i = 0; i < _trove.debtTokens.length; i++) {\n      address token = address(_trove.debtTokens[i]);\n\n      uint snapshot = liquidatedTokens[token][false];\n      rewardSnapshots[_borrower][token][false] = snapshot;\n      _troveSnapshots[i] = CAmount(token, false, snapshot);\n    }\n    for (uint i = 0; i < _trove.collTokens.length; i++) {\n      address token = _trove.collTokens[i];\n\n      uint snapshot = liquidatedTokens[token][true];\n      rewardSnapshots[_borrower][token][true] = snapshot;\n      _troveSnapshots[_trove.debtTokens.length + i] = CAmount(token, true, snapshot);\n    }\n\n    emit TroveSnapshotsUpdated(_troveSnapshots);\n  }\n\n  /**\n   *\n   * collateral and debt setters\n   *\n   **/\n\n  function increaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    Trove storage trove = Troves[_borrower];\n    address[] memory collTokenAddresses = new address[](_collTokenAmounts.length);\n    for (uint i = 0; i < _collTokenAmounts.length; i++) {\n      address tokenAddress = _collTokenAmounts[i].tokenAddress;\n      trove.colls[tokenAddress] += _collTokenAmounts[i].amount;\n\n      if (!trove.collsRegistered[tokenAddress]) {\n        trove.collsRegistered[tokenAddress] = true;\n        trove.collTokens.push(tokenAddress);\n      }\n      collTokenAddresses[i] = tokenAddress;\n    }\n\n    emit TroveCollChanged(_borrower, collTokenAddresses);\n  }\n\n  function decreaseTroveColl(address _borrower, TokenAmount[] memory _collTokenAmounts) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    Trove storage trove = Troves[_borrower];\n    address[] memory collTokenAddresses = new address[](_collTokenAmounts.length);\n\n    for (uint i = 0; i < _collTokenAmounts.length; i++) {\n      address tokenAddress = _collTokenAmounts[i].tokenAddress;\n      trove.colls[tokenAddress] -= _collTokenAmounts[i].amount;\n      collTokenAddresses[i] = tokenAddress;\n    }\n\n    emit TroveCollChanged(_borrower, collTokenAddresses);\n  }\n\n  function increaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    Trove storage trove = Troves[_borrower];\n    for (uint i = 0; i < _debtTokenAmounts.length; i++) {\n      IDebtToken debtToken = _debtTokenAmounts[i].debtToken;\n      trove.debts[debtToken] += _debtTokenAmounts[i].netDebt;\n\n      if (!trove.debtsRegistered[address(debtToken)]) {\n        trove.debtsRegistered[address(debtToken)] = true;\n        trove.debtTokens.push(debtToken);\n      }\n    }\n  }\n\n  function decreaseTroveDebt(address _borrower, DebtTokenAmount[] memory _debtTokenAmounts) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    Trove storage trove = Troves[_borrower];\n    for (uint i = 0; i < _debtTokenAmounts.length; i++) {\n      trove.debts[_debtTokenAmounts[i].debtToken] -= _debtTokenAmounts[i].netDebt;\n    }\n  }\n\n  /**\n   *\n   * trove debt + coll getters\n   *\n   **/\n\n  // Return the Troves entire debt and coll, including pending rewards from redistributions.\n  function getEntireDebtAndColl(\n    address _borrower\n  )\n    external\n    view\n    override\n    returns (\n      RAmount[] memory amounts,\n      uint troveCollInUSD,\n      uint troveDebtInUSD,\n      uint troveDebtInUSDWithoutGasCompensation\n    )\n  {\n    Trove storage trove = Troves[_borrower];\n    amounts = new RAmount[](trove.collTokens.length + trove.debtTokens.length);\n\n    // initialize empty coll tokens\n    for (uint i = 0; i < trove.collTokens.length; i++) {\n      address token = address(trove.collTokens[i]);\n      amounts[i] = RAmount(token, true, trove.colls[trove.collTokens[i]], 0, 0, 0, 0, 0, 0);\n    }\n\n    // initialize empty debt tokens and find the stable entry\n    uint stableCoinIndex;\n    for (uint i = 0; i < trove.debtTokens.length; i++) {\n      if (trove.debtTokens[i].isStableCoin()) stableCoinIndex = i + trove.collTokens.length;\n\n      address token = address(trove.debtTokens[i]);\n      amounts[i + trove.collTokens.length] = RAmount(token, false, trove.debts[trove.debtTokens[i]], 0, 0, 0, 0, 0, 0);\n    }\n\n    // applying rewards (from default pool) + adding gas compensation + toLiquidate\n    for (uint i = 0; i < amounts.length; i++) {\n      RAmount memory amountEntry = amounts[i];\n\n      amountEntry.pendingReward = getPendingReward(_borrower, amountEntry.tokenAddress, amountEntry.isColl);\n      uint totalAmount = amountEntry.amount + amountEntry.pendingReward;\n      uint InUSD = priceFeed.getUSDValue(amountEntry.tokenAddress, totalAmount);\n\n      if (amountEntry.isColl) {\n        amountEntry.gasCompensation = _getCollGasCompensation(totalAmount);\n        amountEntry.toLiquidate = totalAmount - amountEntry.gasCompensation;\n        troveCollInUSD += InUSD;\n      } else {\n        if (i == stableCoinIndex) {\n          // stable coin gas compensation should not be liquidated, it will be paid out as reward for the liquidator\n          amountEntry.toLiquidate = totalAmount - STABLE_COIN_GAS_COMPENSATION;\n          troveDebtInUSDWithoutGasCompensation += priceFeed.getUSDValue(\n            amountEntry.tokenAddress,\n            amountEntry.toLiquidate\n          );\n        } else {\n          amountEntry.toLiquidate = totalAmount;\n          troveDebtInUSDWithoutGasCompensation += InUSD;\n        }\n\n        troveDebtInUSD += InUSD;\n      }\n    }\n\n    return (amounts, troveCollInUSD, troveDebtInUSD, troveDebtInUSDWithoutGasCompensation);\n  }\n\n  function getTroveDebt(address _borrower) public view override returns (TokenAmount[] memory) {\n    Trove storage trove = Troves[_borrower];\n    if (trove.status != Status.active) return new TokenAmount[](0);\n\n    TokenAmount[] memory debts = new TokenAmount[](trove.debtTokens.length);\n    for (uint i = 0; i < debts.length; i++)\n      debts[i] = TokenAmount(address(trove.debtTokens[i]), trove.debts[trove.debtTokens[i]]);\n\n    return debts;\n  }\n\n  function getTroveRepayableDebt(\n    address _borrower,\n    address _debtTokenAddress,\n    bool _includingStableCoinGasCompensation\n  ) external view override returns (uint amount) {\n    if (Troves[_borrower].status != Status.active) return 0;\n\n    return _getTroveRepayableDebt(\n      _borrower,\n      _debtTokenAddress,\n      _includingStableCoinGasCompensation\n    );\n  }\n\n  function getTroveRepayableDebts(\n    address _borrower,\n    bool _includingStableCoinGasCompensation\n  ) external view override returns (TokenAmount[] memory debts) {\n    Trove storage trove = Troves[_borrower];\n    if (trove.status != Status.active) return new TokenAmount[](0);\n\n    address debtTokenAddress;\n    debts = new TokenAmount[](trove.debtTokens.length);\n    for (uint i = 0; i < debts.length; i++) {\n      debtTokenAddress = address(trove.debtTokens[i]);\n      debts[i] = TokenAmount(\n        debtTokenAddress,\n        _getTroveRepayableDebt(\n          _borrower,\n          debtTokenAddress,\n          _includingStableCoinGasCompensation\n        )\n      );\n    }\n\n    return debts;\n  }\n\n  function _getTroveRepayableDebt(\n    address _borrower,\n    address _debtTokenAddress,\n    bool _includingStableCoinGasCompensation\n  ) internal view returns (uint amount) {\n    Trove storage trove = Troves[_borrower];\n    if (trove.status != Status.active) return 0;\n\n    return trove.debts[IDebtToken(_debtTokenAddress)]\n      + getPendingReward(_borrower, _debtTokenAddress, false)\n      - (!_includingStableCoinGasCompensation && IDebtToken(_debtTokenAddress).isStableCoin()\n        ? STABLE_COIN_GAS_COMPENSATION\n        : 0\n      );\n  }\n\n  function getTroveColl(address _borrower) public view override returns (TokenAmount[] memory colls) {\n    Trove storage trove = Troves[_borrower];\n    if (trove.status != Status.active) return new TokenAmount[](0);\n\n    colls = new TokenAmount[](trove.collTokens.length);\n    for (uint i = 0; i < colls.length; i++)\n      colls[i] = TokenAmount(trove.collTokens[i], trove.colls[trove.collTokens[i]]);\n\n    return colls;\n  }\n\n  function getTroveWithdrawableColl(\n    address _borrower,\n    address _collTokenAddress\n  ) external view override returns (uint amount) {\n    Trove storage trove = Troves[_borrower];\n    if (trove.status != Status.active) return 0;\n\n    return trove.colls[_collTokenAddress] + getPendingReward(_borrower, _collTokenAddress, true);\n  }\n\n  function getTroveWithdrawableColls(address _borrower) external view override returns (TokenAmount[] memory colls) {\n    colls = getTroveColl(_borrower);\n    for (uint i = 0; i < colls.length; i++) colls[i].amount += getPendingReward(_borrower, colls[i].tokenAddress, true);\n\n    return colls;\n  }\n\n  /**\n   *\n   * trove opening + closing\n   *\n   **/\n\n  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n  /* Max array size is 2**128 - 1, i.e. ~3e30 troves. 3e30 LUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n  function addTroveOwnerToArray(address _borrower) external override returns (uint128 index) {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    // Push the Troveowner to the array\n    TroveOwners.push(_borrower);\n\n    // Record the index of the new Troveowner on their Trove struct\n    index = uint128(TroveOwners.length - 1);\n    Troves[_borrower].arrayIndex = index;\n\n    return index;\n  }\n\n  function closeTroveByProtocol(\n    address[] memory collTokenAddresses,\n    address _borrower,\n    Status closedStatus\n  ) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\n\n    uint numOfOwners = TroveOwners.length;\n    if (numOfOwners <= 1) revert OnlyOneTrove();\n\n    Trove storage trove = Troves[_borrower];\n    trove.status = closedStatus;\n    for (uint i = 0; i < trove.debtTokens.length; i++) trove.debts[trove.debtTokens[i]] = 0;\n    for (uint i = 0; i < trove.collTokens.length; i++) trove.colls[trove.collTokens[i]] = 0;\n    for (uint i = 0; i < collTokenAddresses.length; i++) trove.stakes[collTokenAddresses[i]] = 0;\n    delete trove.debtTokens;\n    delete trove.collTokens;\n\n    _removeTroveOwner(_borrower, numOfOwners);\n    sortedTroves.remove(_borrower);\n    emit TroveClosed(_borrower, closedStatus);\n  }\n\n  /*\n   * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n   * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n   */\n  function _removeTroveOwner(address _borrower, uint _length) internal {\n    Status troveStatus = Troves[_borrower].status;\n    // It’s set in caller function `_closeTrove`\n    assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\n\n    uint128 index = Troves[_borrower].arrayIndex;\n\n    assert(index <= _length - 1);\n\n    address addressToMove = TroveOwners[_length - 1];\n\n    TroveOwners[index] = addressToMove;\n    Troves[addressToMove].arrayIndex = index;\n    emit TroveIndexUpdated(addressToMove, index);\n\n    TroveOwners.pop();\n  }\n\n  /**\n   *\n   * Helper\n   *\n   **/\n\n  function getStableCoinBaseRate() external view override returns (uint) {\n    return stableCoinBaseRate;\n  }\n\n  function getBorrowingRate(bool isStableCoin) public view override returns (uint) {\n    if (!isStableCoin) return BORROWING_FEE_FLOOR;\n    return _calcBorrowingRate(stableCoinBaseRate);\n  }\n\n  function getBorrowingRateWithDecay(bool isStableCoin) public view override returns (uint) {\n    if (!isStableCoin) return BORROWING_FEE_FLOOR;\n    return _calcBorrowingRate(calcDecayedStableCoinBaseRate());\n  }\n\n  function _calcBorrowingRate(uint _stableCoinBaseRate) internal pure returns (uint) {\n    return LiquityMath._min(BORROWING_FEE_FLOOR + _stableCoinBaseRate, MAX_BORROWING_FEE);\n  }\n\n  function getBorrowingFee(uint _debtValue, bool isStableCoin) external view override returns (uint) {\n    return _calcBorrowingFee(getBorrowingRate(isStableCoin), _debtValue);\n  }\n\n  function getBorrowingFeeWithDecay(uint _debtValue, bool isStableCoin) external view override returns (uint) {\n    return _calcBorrowingFee(getBorrowingRateWithDecay(isStableCoin), _debtValue);\n  }\n\n  function _calcBorrowingFee(uint _borrowingRate, uint _debtValue) internal pure returns (uint) {\n    return (_borrowingRate * _debtValue) / DECIMAL_PRECISION;\n  }\n\n  // Updates the stableCoinBaseRate state variable based on time elapsed since the last redemption or stable borrowing operation.\n  function decayStableCoinBaseRateFromBorrowing(uint borrowedStable) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    if (borrowedStable == 0) return; // only decay the stableCoinBaseRate if stable was borrowed (not stocks)\n\n    uint decayedStableCoinBaseRate = calcDecayedStableCoinBaseRate();\n    assert(decayedStableCoinBaseRate <= DECIMAL_PRECISION); // The stableCoinBaseRate can decay to 0\n    _updateLastFeeOpTime(decayedStableCoinBaseRate);\n  }\n\n  /*\n   * This function has two impacts on the stableCoinBaseRate state variable:\n   * 1) decays the stableCoinBaseRate based on time passed since last redemption or stable coin borrowing operation.\n   * then,\n   * 2) increases the stableCoinBaseRate based on the amount redeemed, as a proportion of total supply\n   */\n  function updateStableCoinBaseRateFromRedemption(\n    uint _totalRedeemedStable,\n    uint _totalStableCoinSupply\n  ) external override {\n    _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps();\n\n    uint decayedStableCoinBaseRate = calcDecayedStableCoinBaseRate();\n    uint redeemedStableFraction = (_totalRedeemedStable * DECIMAL_PRECISION) / _totalStableCoinSupply;\n\n    uint newStableCoinBaseRate = LiquityMath._min(\n      decayedStableCoinBaseRate + (redeemedStableFraction / BETA),\n      DECIMAL_PRECISION\n    ); // cap stableCoinBaseRate at a maximum of 100%\n    assert(newStableCoinBaseRate > 0); // Base rate is always non-zero after redemption\n    _updateLastFeeOpTime(newStableCoinBaseRate);\n  }\n\n  // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n  function _updateLastFeeOpTime(uint newStableCoinBaseRate) internal {\n    stableCoinBaseRate = newStableCoinBaseRate; // Update the StableCoinBaseRate state variable\n    emit StableCoinBaseRateUpdated(newStableCoinBaseRate);\n\n    uint timePassed = block.timestamp - lastFeeOperationTime;\n    if (timePassed >= 1 minutes) {\n      lastFeeOperationTime = block.timestamp;\n      emit LastFeeOpTimeUpdated(block.timestamp);\n    }\n  }\n\n  function calcDecayedStableCoinBaseRate() public view override returns (uint) {\n    uint minutesPassed = _minutesPassedSinceLastFeeOp();\n    uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n    return (stableCoinBaseRate * decayFactor) / DECIMAL_PRECISION;\n  }\n\n  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n    return (block.timestamp - lastFeeOperationTime) / 1 minutes;\n  }\n\n  function _requireCallerIsBorrowerOpsOrRedemptionOpsOrLiquidationOps() internal view {\n    if (\n      msg.sender != borrowerOperationsAddress &&\n      msg.sender != redemptionOperationsAddress &&\n      msg.sender != liquidationOperationsAddress\n    ) revert NotFromBorrowerOrRedemptionOps();\n  }\n\n  function _requireTroveIsActive(address _borrower) internal view {\n    if (Troves[_borrower].status != Status.active) revert InvalidTrove();\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}