
# TODO: wasa mapper for swap pools PairCreated event
type Token @entity {
  # contract address
  id: Bytes!
  address: Bytes! # contract address
  symbol: String!
  createdAt: BigInt!
  #
  # TODO: wasa 
  # PoolPrice, update when pool ratio changes or price feed updates
  priceUSD: BigInt!
  # TODO: wasa Lookup from the candle chart on TokenPriceChanged event.
  priceUSD24hAgo: BigInt!
  #
  isPoolToken: Boolean!
}

type DebtTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToDebtTokenMeta")
  timestamp: BigInt!

  # global

  # TODO: wasa not sure how to calculate the APY, lets discuss this together
  # Es geht bei dieser Metric um einen laufenden 30 Tage Durchschnitt, welcher anzeigt wie viel die depositors in dieser Zeit, aufs Jahr hochgerechenet, verdient haben.
  # Das muss auf dem graphen berechnet werden, über das offset event. Alle offsets der letzten 30 Tage immer zusammenfassen und schauen wie groß der Profit (debt token heraus gezogen, coll token bekommen) war.
  # On creation of the entity we must save just the current APY
  stabilityDepositAPY: Int!
  totalDepositedStability: BigInt!
  # TODO: wasa Implement the event handlers to update this field
  totalReserve: BigInt!
  # TODO: Fetch this from the client side
  # totalReserve24hAgo: BigInt!
  # TODO: wasa Implement the event handlers to update this field
  totalSupplyUSD: BigInt!
  # TODO: Fetch this from the client side
  # totalSupplyUSD24hAgo: BigInt!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type StabilityDepositAPY @entity {
  # "StabilityDepositAPY" + token
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

# A chunk is added once every 60min are over and is deducted at the end of 30d
type StabilityDepositChunk @entity {
  # "StabilityDepositChunk" + token + index
  id: String!
  timestamp: BigInt!
  profit: BigInt!
  volume: BigInt!
}

# type UserDebtTokenMeta @entity {
#   # "UserDebtTokenMeta" + token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!

#   walletAmount: BigInt!
#   troveMintedAmount: BigInt!
#   # When user claims rewards set to deposit => track any increase/decrease but claimed stability
#   providedStablitySinceLastCollClaim: BigInt!
#   stabilityCompoundAmount: BigInt!
# }

type CollateralTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Bytes!
  timestamp: BigInt!

  # global
  # TODO: wasa Link to event when ReservePool is implemented
  totalValueLockedUSD: BigInt!
  # TODO: Fetch this from the client side
  # totalValueLockedUSD24hAgo: BigInt!
}

# type UserCollateralTokenMeta @entity {
#   # "UserDebtTokenMeta" + token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!
#   # borrower specific
#   walletAmount: BigInt!
#   troveLockedAmount: BigInt!

#   # TODO: This call is made from the client to the contract because there is no event for this
#   # stabilityGainedAmount: BigInt!
# }

# TODO: Positions and Pools are not yet implemented.
# enum LongShortDirection {
#   LONG
#   SHORT
# }

# type Position @entity {
#   # TODO: I need a unqiue ID to fetch the Position once its closed. What could that be?
#   id: String!
#   borrower: Bytes!
#   openedAt: BigInt!
#   closedAt: BigInt # undefined until closed
#   #
#   token: Bytes!
#   direction: LongShortDirection!
#   size: BigInt! # always positive, applied by direction
#   #
#   totalPriceInStable: BigInt!
#   feesInStable: BigInt! # protocol fees, without gas
#   profitInStable: BigInt # undefined until closed
# }

type PoolLiquidity @entity {
  # unique Byte combination of tokenA + tokenB
  id: Bytes!
  token: Bytes!
  # TODO: wasa Swap event swapPair.getReserves 
  totalAmount: BigInt!
}

# type UserPoolLiquidity @entity {
#   # "UserPoolLiquidity" + main Token + paired Token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!
#   borrowerAmount: BigInt!
# }

# type PoolReward @entity(immutable: true) {
#   id: Bytes!
#   token: Bytes!
#   amount: BigInt!
# }

# type UserPool @entity {
#   # "UserPool" + TokenA + TokenB + borrower
#   id: String!
#   borrower: Bytes!

#   # Always updated on a user basis
#   userLiquidity: [UserPoolLiquidity!]! @relation(name: "UserPoolLiquidityToPool")
#   # Just pushed once, never updated
#   rewards: [PoolReward!]!
# }

type Pool @entity {
  # TODO: wasa We need some distict logic to create the ID
  # This is the trainding pair address! Please hardcode it for the paired tokens or use singleton.
  id: String!

  # Percent value applied when opening the first position for this pool. Can be negative and positive.
  # swapFee: BigInt!
  # Just linked once, always updated for all users
  # TODO: wasa update the general data on the Pool singletons
  liquidity: [PoolLiquidity!]! @relation(name: "PoolLiquidityToPool")
  # TODO: die fee in USD bitte ebenfalls im laufenden durchschnitt mitberechen, diese wird dann notwenidg um die APY zu ermitteln
  # TODO: wasa => not sure how to do this yet, lets delay this for now
  liquidityDepositAPY: BigInt!

  # TODO: wasa => We need to aggregate all Deposits/Withdrawals and update every time a new Transaction comes in
  volume30dUSD: PoolVolume30d!
  # once the first PoolEvent of the array is > 24h ago, we can remove it from the array and push it to the 24hAgo field
  volume30dUSD30dAgo: PoolVolume30d!

  # TODO: wasa Proxy Token amount 
  totalSupply: Float!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type PoolVolume30d @entity {
  id: Bytes!
  index: Int!
  value: BigInt!
  # die fee in USD bitte ebenfalls im laufenden durchschnitt mitberechen, diese wird dann notwenidg um die APY zu ermitteln
  feeUSD: BigInt!
}

# TODO: wasa => there are probably more => alle vier events: mint, burn, swap, sync können die reserven verändern
enum PoolEventType {
  DEPOSIT
  WITHDRAW
}

# A chunk is added once 5min are over and is deducted at the end of 30d
type PoolVolumeChunk @entity {
  # "PoolVolumeChunk" + TokenA + TokenB + index
  id: String!
  timestamp: BigInt!
  # determines if value is added of deducted
  type: PoolEventType! 
  value: BigInt!
}


# TODO: wasa not sure about contract/event limitations of the BorrowerHistory, lets analyze this together first before implementation.
type TokenAmount @entity(immutable: true) {
  id: Bytes!
  token: Bytes!
  amount: BigInt!
}

enum BorrowerHistoryType {
  DEPOSITED
  WITHDRAWN
  CLAIMED_REWARDS
}

type BorrowerHistory @entity(immutable: true) {
  id: Bytes!
  pool: Bytes!
  borrower: Bytes!
  timestamp: BigInt!
  # Group transactions together in accumulated view
  block: Int!
  type: BorrowerHistoryType!
  values: [TokenAmount!]! @relation(name: "TokenAmountToBorrowerHistory")
  # worth of the claimed tokens in USD at the time of the event, only set on CLAIMED_REWARDS
  claimInUSD: BigInt
  # collGains - depositLoss
  resultInUSD: BigInt
}

# CHARTS

# TODO: wasa => I would start with this.
# We have different candle sizes for 5min, 1h .... ???
# We add to a singleton cande and then save it as soon as the candlesize is reached
type TokenCandleSingleton @entity {
  # "TokenCandleSingleton" + token + candleSize
  id: String!
  token: Bytes!
  # last candle + candleSize
  timestamp: BigInt!
  # last candle
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}

type TokenCandle @entity(immutable: true) {
  id: Bytes!
  token: Bytes! @relation(name: "TokenToTokenCandle")
  timestamp: BigInt!
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}
