# SINGLETON FOR SYSTEM INFO
type SystemInfo @entity {
  # "SystemInfo"
  id: String!
  timestamp: BigInt!
  stableCoin: Bytes!
  storagePool: Bytes!
}

# TODO: wasa mapper for swap pools PairCreated event
type Token @entity {
  # contract address
  id: Bytes!
  address: Bytes! # contract address
  symbol: String!
  createdAt: BigInt!
  #
  # TODO: wasa
  # PoolPrice, update when pool ratio changes or price feed updates
  priceUSD: BigInt!
  # TODO: Do it from the client side, too difficult to implement in the graph, just fetch minute candle
  # priceUSD24hAgo: BigInt!
  #
  isPoolToken: Boolean!
}

type DebtTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToDebtTokenMeta")
  timestamp: BigInt!

  # global

  # TODO: wasa not sure how to calculate the APY, lets discuss this together
  # Es geht bei dieser Metric um einen laufenden 30 Tage Durchschnitt, welcher anzeigt wie viel die depositors in dieser Zeit, aufs Jahr hochgerechenet, verdient haben.
  # Das muss auf dem graphen berechnet werden, Ã¼ber das offset event. Alle offsets der letzten 30 Tage immer zusammenfassen und schauen wie groÃŸ der Profit (debt token heraus gezogen, coll token bekommen) war.
  # On creation of the entity we must save just the current APY
  stabilityDepositAPY: StabilityDepositAPY! @relation(name: "StabilityDepositAPYToDebtTokenMeta")
  # event: StabilityProvided StabilityWithdrawn  StabilityOffset
  totalDepositedStability: BigInt!
  # TODO: wasa Implement the event handlers to update this field
  # - token: es gibt nur zwei, kannst du hardcoden, oder von reservePool.`stableDebtToken` und reservePool.`govToken`
  # - deposited: `stableReserveCap` und `govReserveCap`
  # - event: `WithdrewReserves` und borrowerOps.increaseDebt, dort haben wir aber aktuell kein Event ðŸ˜Ÿ
  totalReserve: BigInt!
  # TODO: Fetch this from the client side
  # totalReserve30dAverage: BigInt!
  # event StoragePoolValueUpdated
  totalSupplyUSD: BigInt!
  # event StoragePoolValueUpdated
  # totalSupplyUSD30dAverage: BigInt!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type StabilityDepositAPY @entity {
  # "StabilityDepositAPY" + token
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

# A chunk is added once every 60min are over and is deducted at the end of 30d
type StabilityDepositChunk @entity {
  # "StabilityDepositChunk" + token + index
  id: String!
  timestamp: BigInt!
  profit: BigInt!
  volume: BigInt!
}

# type UserDebtTokenMeta @entity {
#   # "UserDebtTokenMeta" + token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!

#   walletAmount: BigInt!
#   troveMintedAmount: BigInt!
#   # When user claims rewards set to deposit => track any increase/decrease but claimed stability
#   providedStablitySinceLastCollClaim: BigInt!
#   stabilityCompoundAmount: BigInt!
# }

type CollateralTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Bytes!
  timestamp: BigInt!

  # global
  totalValueLockedUSD: BigInt!
  totalValueLockedUSD30dAverage: TotalValueLockedAverage!
}

# aggregator for 30d average, each chunk is 60min
type TotalValueLockedAverage @entity {
  # "TotalValueLockedAverage" + token
  id: String!
  index: Int!
  value: BigInt!
}

# A chunk is added once every 60min are over and is deducted at the end of 30d
type TotalValueLockedChunk @entity {
  # "TotalValueLockedChunk" + token + index
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

# type UserCollateralTokenMeta @entity {
#   # "UserDebtTokenMeta" + token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!
#   # borrower specific
#   walletAmount: BigInt!
#   troveLockedAmount: BigInt!

#   # TODO: This call is made from the client to the contract because there is no event for this
#   # stabilityGainedAmount: BigInt!
# }

enum LongShortDirection {
  LONG
  SHORT
}

type SwapEvent @entity(immutable: true) {
  id: Bytes!
  borrower: Bytes!
  timestamp: BigInt!
  #
  token: Token! @relation(name: "TokenToSwapEvent")
  direction: LongShortDirection! # Indicates whether the swap is LONG or SHORT
  size: BigInt! # always positive, applied by direction. The size of the "non-stable" coin involved in the swap
  totalPriceInStable: BigInt! # The total price at the time of the swap, always in stable coin
  # die currentSwapFee wird in dem event als 1e6 angegeben â†’ 1000000 sind 100%, 3000 sind 0.3%
  swapFee: BigInt! # protocol fees, without gas. Long => jUSD / Short => DebtToken
}

type PoolLiquidity @entity {
  # unique Byte combination of tokenA + tokenB
  id: Bytes!
  token: Bytes!
  # TODO: wasa Swap event swapPair.getReserves
  totalAmount: BigInt!
}

# type UserPoolLiquidity @entity {
#   # "UserPoolLiquidity" + main Token + paired Token + borrower
#   id: String!
#   borrower: Bytes!
#   token: Bytes!
#   borrowerAmount: BigInt!
# }

# type PoolReward @entity(immutable: true) {
#   id: Bytes!
#   token: Bytes!
#   amount: BigInt!
# }

# type UserPool @entity {
#   # "UserPool" + TokenA + TokenB + borrower
#   id: String!
#   borrower: Bytes!

#   # Always updated on a user basis
#   userLiquidity: [UserPoolLiquidity!]! @relation(name: "UserPoolLiquidityToPool")
#   # Just pushed once, never updated
#   rewards: [PoolReward!]!
# }

type Pool @entity {
  # TODO: wasa We need some distict logic to create the ID
  # `Pool-${token0.toHexString()}-${token1.toHexString()}`
  id: String!

  # Percent value applied when opening the first position for this pool. Can be negative and positive.
  # swapFee: BigInt!
  # Just linked once, always updated for all users
  # TODO: wasa update the general data on the Pool singletons
  liquidity: [PoolLiquidity!]! @relation(name: "PoolLiquidityToPool")
  # TODO: die fee in USD bitte ebenfalls im laufenden durchschnitt mitberechen, diese wird dann notwenidg um die APY zu ermitteln
  # TODO: wasa => not sure how to do this yet, lets delay this for now
  liquidityDepositAPY: BigInt!

  # TODO: wasa => We need to aggregate all Deposits/Withdrawals and update every time a new Transaction comes in
  volume30dUSD: PoolVolume30d!
  # once the first PoolEvent of the array is > 24h ago, we can remove it from the array and push it to the 24hAgo field
  volume30dUSD30dAgo: PoolVolume30d!

  # TODO: wasa Proxy Token amount
  totalSupply: BigInt!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type PoolVolume30d @entity {
  id: Bytes!
  leadingIndex: Int!
  lastIndex: Int!
  value: BigInt!
  # die fee in USD bitte ebenfalls im laufenden durchschnitt mitberechen, diese wird dann notwenidg um die APY zu ermitteln
  feeUSD: BigInt!
}

# A chunk is added once 5min are over and is deducted at the end of 30d
type PoolVolumeChunk @entity {
  # "PoolVolumeChunk" + TokenA + TokenB + index
  id: String!
  timestamp: BigInt!
  value: BigInt!
}

# TODO: wasa not sure about contract/event limitations of the BorrowerHistory, lets analyze this together first before implementation.
type TokenAmount @entity(immutable: true) {
  id: Bytes!
  token: Bytes!
  amount: BigInt!
}

enum BorrowerHistoryType {
  DEPOSITED
  WITHDRAWN
  CLAIMED_REWARDS
}

type BorrowerHistory @entity(immutable: true) {
  id: Bytes!
  pool: Bytes!
  borrower: Bytes!
  timestamp: BigInt!
  # Group transactions together in accumulated view
  block: Int!
  type: BorrowerHistoryType!
  values: [TokenAmount!]! @relation(name: "TokenAmountToBorrowerHistory")
  # worth of the claimed tokens in USD at the time of the event, only set on CLAIMED_REWARDS
  claimInUSD: BigInt
  # collGains - depositLoss
  resultInUSD: BigInt
}

# CHARTS

# TODO: wasa => I would start with this.
# 1min, 10min, 1hour, 6hour, 1day, 1week
# const CandleSizes = [1, 10, 60, 360, 1440, 10080];
# We add to a singleton cande and then save it as soon as the candlesize is reached
type TokenCandleSingleton @entity {
  # "TokenCandleSingleton" + token + candleSize
  id: String!
  token: Bytes!
  # last candle + candleSize
  timestamp: BigInt!
  # last candle
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}

type TokenCandle @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToTokenCandle")
  timestamp: BigInt!
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}
