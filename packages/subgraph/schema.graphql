# # Custom

# Singleton entity to store the ID of the last created Token

type Token @entity {
  id: Bytes!
  address: Bytes! # contract address
  symbol: String!
  createdAt: BigInt!
  #
  priceUSD: BigInt!
  # TODO: Fetch this from the client side and get it from the TradingView entities
  # priceUSD24hAgo: BigInt!
  #
  isPoolToken: Boolean!
}

type DebtTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToDebtTokenMeta")
  timestamp: BigInt!

  # global
  # TODO: Must be calculated in the subgraph

  # Es geht bei dieser Metric um einen laufenden 30 Tage Durchschnitt, welcher anzeigt wie viel die depositors in dieser Zeit, aufs Jahr hochgerechenet, verdient haben.
  # Das muss auf dem graphen berechnet werden, über das offset event. Alle offsets der letzten 30 Tage immer zusammenfassen und schauen wie groß der Profit (debt token heraus gezogen, coll token bekommen) war.

  stabilityDepositAPY: StabilityDepositAPY!
  totalDepositedStability: BigInt!
  totalReserve: BigInt!
  # TODO: Fetch this from the client side
  # totalReserve24hAgo: BigInt!
  totalSupplyUSD: BigInt!
  # TODO: Fetch this from the client side
  # totalSupplyUSD24hAgo: BigInt!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type StabilityDepositAPY @entity {
  # "StabilityDepositAPY" + token
  id: String!
  index: Int!
  profit: BigInt!
  volume: BigInt!
}

# A chunk is added once every 60min are over and is deducted at the end of 30d
type StabilityDepositChunk @entity {
  # "StabilityDepositChunk" + token + index
  id: String!
  timestamp: BigInt!
  profit: BigInt!
  volume: BigInt!
}

type UserDebtTokenMeta @entity {
  # "UserDebtTokenMeta" + token + borrower
  id: String!
  borrower: Bytes!
  token: Token! @relation(name: "TokenToUserDebtTokenMeta")

  walletAmount: BigInt!
  troveMintedAmount: BigInt!
  # When user claims rewards set to deposit => track any increase/decrease but claimed stability
  providedStablitySinceLastCollClaim: BigInt!
  stabilityCompoundAmount: BigInt!
}

type CollateralTokenMeta @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToCollateralTokenMeta")
  timestamp: BigInt!

  # global
  totalValueLockedUSD: BigInt!
  # TODO: Fetch this from the client side
  # totalValueLockedUSD24hAgo: BigInt!
}

type UserCollateralTokenMeta @entity {
  # "UserDebtTokenMeta" + token + borrower
  id: String!
  borrower: Bytes!
  token: Token! @relation(name: "TokenToUserCollateralTokenMeta")
  # borrower specific
  walletAmount: BigInt!
  troveLockedAmount: BigInt!
  stabilityGainedAmount: BigInt!
}

enum LongShortDirection {
  LONG
  SHORT
}

type Position @entity {
  # TODO: I need a unqiue ID to fetch the Position once its closed. What could that be?
  id: String!
  borrower: Bytes!
  openedAt: BigInt!
  closedAt: BigInt # undefined until closed
  #
  token: Token! @relation(name: "TokenToPosition")
  direction: LongShortDirection!
  size: BigInt! # always positive, applied by direction
  #
  totalPriceInStable: BigInt!
  feesInStable: BigInt! # protocol fees, without gas
  profitInStable: BigInt # undefined until closed
}

type PoolLiquidity @entity {
  # unique Byte combination of tokenA + tokenB
  id: Bytes!
  token: Token! @relation(name: "TokenToPoolLiquidity")
  totalAmount: BigInt!
}

type UserPoolLiquidity @entity {
  # "UserPoolLiquidity" + main Token + paired Token + borrower
  id: String!
  borrower: Bytes!
  token: Token! @relation(name: "TokenToUserPoolLiquidity")
  borrowerAmount: BigInt!
}

type PoolReward @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToPoolReward")
  amount: BigInt!
}

type UserPool @entity {
  # "UserPool" + TokenA + TokenB + borrower
  id: String!
  borrower: Bytes!

  # Always updated on a user basis
  userLiquidity: [UserPoolLiquidity!]! @relation(name: "UserPoolLiquidityToPool")
  # Just pushed once, never updated
  rewards: [PoolReward!]!
}

type Pool @entity {
  # "Pool" + TokenA + TokenB
  id: Bytes!

  # Percent value applied when opening the first position for this pool. Can be negative and positive.
  openingFee: BigInt!
  # Just linked once, always updated for all users
  liquidity: [PoolLiquidity!]! @relation(name: "PoolLiquidityToPool")
  # TODO: Must be calculated in the subgraph but when
  liquidityDepositAPY: BigInt!

  # TODO: We need to aggregate all Deposits/Withdrawals and update every time a new Transaction comes in
  volume24hUSD: PoolVolume24h!
  # once the first PoolEvent of the array is > 24h ago, we can remove it from the array and push it to the 24hAgo field
  volume24hUSD24hAgo: PoolVolume24h!
}

# Aggregator, pushed old events out and lets new in, recalculating the acc value each time
type PoolVolume24h @entity {
  id: Bytes!
  index: Int!
  value: BigInt!
}

enum PoolEventType {
  DEPOSIT
  WITHDRAW
}

# A chunk is added once 5min are over and is deducted at the end of 24h
type PoolVolumeChunk @entity {
  # "PoolVolumeChunk" + TokenA + TokenB + index
  id: String!
  timestamp: BigInt!
  # determines if value is added of deducted
  type: PoolEventType!
  value: BigInt!
}

type TokenAmount @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToTokenAmount")
  amount: Float!
}

enum BorrowerHistoryType {
  DEPOSITED
  WITHDRAWN
  CLAIMED_REWARDS
}

type BorrowerHistory @entity(immutable: true) {
  id: Bytes!
  borrower: Bytes!
  timestamp: BigInt!
  type: BorrowerHistoryType!
  values: [TokenAmount!]! @relation(name: "TokenAmountToBorrowerHistory")
  # worth of the claimed tokens in USD at the time of the event, only set on CLAIMED_REWARDS
  claimInUSD: BigInt
  # collGains - depositLoss
  resultInUSD: BigInt
}

# CHARTS

# We have different candle sizes for 5min, 1h .... TODO:
# We add to a singleton cande and then save it as soon as the candlesize is reached

type TokenCandleSingleton {
  # "TokenCandleSingleton" + token + candleSize
  id: String!
  token: Token! @relation(name: "TokenToTokenCandleSingleton")
  # last candle + candleSize
  timestamp: BigInt!
  # last candle
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}

type TokenCandle @entity(immutable: true) {
  id: Bytes!
  token: Token! @relation(name: "TokenToTokenCandle")
  timestamp: BigInt!
  open: BigInt!
  high: BigInt!
  low: BigInt!
  close: BigInt!
  volume: BigInt!
  candleSize: Int!
}
